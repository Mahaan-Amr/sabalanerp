'use client';

import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { 
  FaArrowRight, 
  FaArrowLeft, 
  FaCheck,
  FaCalendarAlt,
  FaUser,
  FaBuilding,
  FaWarehouse,
  FaTruck,
  FaCreditCard,
  FaSignature,
  FaFileContract,
  FaPlus,
  FaTrash,
  FaSearch,
  FaTimes,
  FaEdit,
  FaLayerGroup,
  FaRuler,
  FaSquare,
  FaCubes,
  FaThLarge,
  FaChevronDown,
  FaChevronUp,
  FaTools
} from 'react-icons/fa';
import { salesAPI, crmAPI, dashboardAPI, servicesAPI } from '@/lib/api';
import PersianCalendar from '@/lib/persian-calendar';
import PersianCalendarComponent from '@/components/PersianCalendar';
import { formatDisplayNumber, formatPrice, formatPriceWithRial, formatDimensions, formatSquareMeters, formatQuantity, tomanToRial } from '@/lib/numberFormat';
import FormattedNumberInput from '@/components/FormattedNumberInput';
import StoneCanvas from '@/components/StoneCanvas';
import { StoneCADDesigner } from '@/components/stone-cad/StoneCADDesigner';

// Import new step components
import { Step1ContractDate } from '@/features/contract-creation/components/steps/Step1ContractDate';
import { Step2CustomerSelection } from '@/features/contract-creation/components/steps/Step2CustomerSelection';
import { Step3ProjectManagement } from '@/features/contract-creation/components/steps/Step3ProjectManagement';
import { Step4ProductTypeSelection } from '@/features/contract-creation/components/steps/Step4ProductTypeSelection';
import { Step5ProductSelection } from '@/features/contract-creation/components/steps/Step5ProductSelection';
import { Step6DeliverySchedule } from '@/features/contract-creation/components/steps/Step6DeliverySchedule';
import { Step7PaymentMethod } from '@/features/contract-creation/components/steps/Step7PaymentMethod';
import { Step8DigitalSignature } from '@/features/contract-creation/components/steps/Step8DigitalSignature';

// Import shared components
import { WizardProgressBar, type WizardStep } from '@/features/contract-creation/components/shared/WizardProgressBar';
import { WizardNavigation } from '@/features/contract-creation/components/shared/WizardNavigation';

// Import modal components
import { ProductConfigurationModal } from '@/features/contract-creation/components/modals/ProductConfigurationModal';
import { StairSystemModal } from '@/features/contract-creation/components/modals/StairSystemModal';
import { RemainingStoneModal } from '@/features/contract-creation/components/modals/RemainingStoneModal';
import { SubServiceModal } from '@/features/contract-creation/components/modals/SubServiceModal';

// Types
interface CrmCustomer {
  id: string;
  firstName: string;
  lastName: string;
  companyName?: string;
  customerType: string;
  status: string;
  projectAddresses: ProjectAddress[];
  phoneNumbers: PhoneNumber[];
  nationalCode?: string;
  homeAddress?: string;
  homeNumber?: string;
  workAddress?: string;
  workNumber?: string;
  projectManagerName?: string;
  projectManagerNumber?: string;
  brandName?: string;
  brandNameDescription?: string;
  isBlacklisted: boolean;
  isLocked: boolean;
}

interface ProjectAddress {
  id: string;
  address: string;
  city: string;
  postalCode?: string;
  projectName?: string;
  projectType?: string;
  projectManagerName?: string;
  projectManagerNumber?: string;
  isActive: boolean;
}

interface PhoneNumber {
  id: string;
  number: string;
  type: 'mobile' | 'home' | 'work' | 'other';
  isPrimary: boolean;
  isActive: boolean;
}

interface Product {
  id: string;
  code: string;
  name: string;
  namePersian: string;
  fullName?: string;
  basePrice?: number;
  currency: string;
  isAvailable: boolean;
  leadTime?: number;
  description?: string;
  // Product attributes
  cuttingDimensionNamePersian: string;
  stoneTypeNamePersian: string;
  widthValue: number;
  thicknessValue: number;
  widthName: string;
  thicknessName: string;
  mineNamePersian: string;
  finishNamePersian: string;
  colorNamePersian: string;
  qualityNamePersian: string;
  availableInLongitudinalContracts?: boolean;
  availableInStairContracts?: boolean;
  availableInSlabContracts?: boolean;
  availableInVolumetricContracts?: boolean;
}

interface StoneCut {
  id: string;
  originalWidth: number; // عرض اصلی سنگ
  cutWidth: number; // عرض برش خورده
  remainingWidth: number; // عرض باقی‌مانده
  length: number; // طول برش
  cuttingCost: number; // هزینه برش
  cuttingCostPerMeter: number; // هزینه برش به ازای هر متر
  orientation?: 'longitudinal' | 'cross';
}

interface RemainingStone {
  id: string;
  width: number; // عرض باقی‌مانده (in cm)
  length: number; // طول باقی‌مانده (in meters)
  squareMeters: number; // متر مربع باقی‌مانده
  isAvailable: boolean; // آیا قابل استفاده است
  sourceCutId: string; // شناسه برش اصلی
  position?: { // موقعیت در سنگ اصلی (برای نمایش در canvas) - فقط برای پارتیشن‌ها
    startWidth: number; // شروع عرض (in cm)
    startLength: number; // شروع طول (in meters)
  };
  // Cutting cost fields for partitions (when created from remaining stone)
  cuttingCost?: number; // هزینه برش برای این پارتیشن
  cuttingCostPerMeter?: number; // هزینه برش به ازای هر متر
  cutType?: 'longitudinal' | 'cross' | null; // نوع برش
  quantity?: number; // تعداد (برای محاسبه هزینه برش)
}

interface SlabStandardDimensionEntry {
  id: string; // Unique ID for this entry
  standardLengthCm: number; // طول استاندارد (in cm)
  standardWidthCm: number; // عرض استاندارد (in cm)
  quantity: number; // تعداد این ابعاد استاندارد
}

interface StonePartition {
  id: string;
  width: number; // عرض پارتیشن (in cm)
  length: number; // طول پارتیشن (in meters)
  squareMeters: number; // متر مربع (محاسبه شده)
  position?: { // موقعیت در سنگ اصلی (برای نمایش در canvas)
    startWidth: number; // شروع عرض (in cm)
    startLength: number; // شروع طول (in meters)
  };
  validationError?: string; // خطای اعتبارسنجی برای این پارتیشن خاص
}

interface SubService {
  id: string;
  code: string;
  name?: string;
  namePersian: string;
  description?: string;
  pricePerMeter: number; // هزینه هر متر ابزار (تومان)
  calculationBase: 'length' | 'squareMeters'; // بر اساس طول یا متر مربع
  isActive: boolean;
}

interface StoneFinishing {
  id: string;
  name?: string;
  namePersian: string;
  description?: string;
  pricePerSquareMeter: number;
  isActive: boolean;
}

interface AppliedSubService {
  id: string; // Unique ID for this applied service
  subServiceId: string; // Reference to SubService
  subService: SubService; // Full SubService object
  meter: number; // مقدار استفاده شده (طول یا متر مربع)
  cost: number; // هزینه محاسبه شده
  calculationBase: 'length' | 'squareMeters'; // مبنای محاسبه
}

interface CuttingBreakdownEntry {
  type: 'longitudinal' | 'cross';
  meters: number;
  rate: number;
  cost: number;
}

interface ServiceEntry {
  key: string;
  type: 'tool' | 'layer' | 'cut' | 'finishing';
  productName: string;
  description: string;
  amountLabel: string;
  cost: number;
  meta?: {
    rateLabel?: string;
  };
}

// Stair Part interface for individual parts of a stair system
interface StairPart {
  // Part identification
  partType: 'tread' | 'riser' | 'landing'; // کف پله, خیز پله, پاگرد
  isSelected: boolean; // Whether this part is included in the stair system
  
  // Product selection
  productId: string | null;
  product: Product | null;
  
  // Part-specific dimensions
  // For Tread (کف پله):
  treadWidth?: number; // طول پله (width of staircase) - in cm or m
  treadDepth?: number; // عرض پله (depth of step) - in cm
  // For Riser (خیز پله):
  riserHeight?: number; // ارتفاع قائمه - in cm
  // For Landing (پاگرد):
  landingWidth?: number; // عرض پاگرد - in cm
  landingDepth?: number; // عمق پاگرد - in cm
  numberOfLandings?: number; // تعداد پاگرد
  
  // Quantity and pricing
  quantity: number; // تعداد
  squareMeters: number; // متر مربع
  pricePerSquareMeter: number; // فی هر متر مربع
  totalPrice: number; // قیمت کل
  
  // Nosing (only for tread)
  nosingType?: string;
  nosingOverhang?: number; // mm
  nosingCuttingCost?: number;
  nosingCuttingCostPerMeter?: number;
  
  // Mandatory pricing
  isMandatory: boolean;
  mandatoryPercentage: number;
  originalTotalPrice: number;
  
  // Other fields
  description: string;
  currency: string;
  lengthUnit?: 'cm' | 'm'; // For tread width
}

// Stair System configuration
interface StairSystemConfig {
  // Common configuration
  numberOfSteps: number; // تعداد پله
  quantityType: 'steps' | 'staircases'; // نوع تعداد
  numberOfStaircases?: number; // if quantityType === 'staircases'
  
  // Default product (used when user first selects a product)
  defaultProduct: Product | null;
  
  // Three parts
  tread: StairPart;      // کف پله
  riser: StairPart;      // خیز پله
  landing: StairPart;    // پاگرد
}

interface ContractProduct {
  productId: string;
  product: Product;
  // Product type
  productType: 'longitudinal' | 'stair' | 'slab'; // نوع محصول
  // Stair system linking (only for stair parts)
  stairSystemId?: string; // ID to link multiple items belonging to same stair system
  stairPartType?: 'tread' | 'riser' | 'landing'; // نوع بخش پله
  // Stone-specific fields (shared)
  stoneCode: string; // کد سنگ
  stoneName: string; // نام یا نوع سنگ
  diameterOrWidth: number; // قطر یا عرض (constant for تایل and طولی)
  length: number; // طول
  width: number; // عرض
  quantity: number; // تعداد
  squareMeters: number; // متر مربع
  pricePerSquareMeter: number; // فی هر متر مربع
  totalPrice: number; // قیمت کل
  description: string; // توضیحات
  currency: string;
  // Unit information for proper display
  lengthUnit: 'cm' | 'm'; // واحد طول
  widthUnit: 'cm' | 'm'; // واحد عرض
  standardLengthValue?: number | null;
  standardLengthUnit?: 'cm' | 'm';
  actualLengthMeters?: number | null;
  layerTypeId?: string | null;
  layerTypeName?: string | null;
  layerTypePrice?: number | null;
  layerUseDifferentStone?: boolean;
  layerStoneProductId?: string | null;
  layerStoneName?: string | null;
  layerStonePricePerSquareMeter?: number | null;
  layerStoneBasePricePerSquareMeter?: number | null;
  layerUseMandatory?: boolean;
  layerMandatoryPercentage?: number | null;
  // Mandatory pricing fields
  isMandatory: boolean; // حکمی
  mandatoryPercentage: number; // درصد حکمی (default 20%)
  originalTotalPrice: number; // قیمت اصلی قبل از حکمی
  // Stone cutting fields
  isCut: boolean; // آیا سنگ برش خورده است
  cutType: 'longitudinal' | 'cross' | null; // نوع برش
  originalWidth: number; // عرض اصلی سنگ قبل از برش
  originalLength: number; // طول اصلی سنگ قبل از استفاده (in meters) - برای محاسبه باقی‌مانده
  cuttingCost: number; // هزینه برش
  cuttingCostPerMeter: number; // هزینه برش به ازای هر متر
  cutDescription: string; // توضیحات برش
  remainingStones: RemainingStone[]; // سنگ‌های باقی‌مانده
  cutDetails: StoneCut[]; // جزئیات برش‌ها
  // Legacy single standard dimension fields (kept for backward compatibility)
  slabStandardLengthCm?: number | null;
  slabStandardWidthCm?: number | null;
  // New multiple standard dimensions support
  slabStandardDimensions?: SlabStandardDimensionEntry[]; // Array of standard dimension entries
  slabCuttingMode?: 'perSquareMeter' | 'lineBased';
  slabCuttingPricePerSquareMeter?: number | null;
  slabLineCuttingStrategy?: 'length' | 'width';
  slabLineCuttingLongitudinalMeters?: number | null;
  slabLineCuttingCrossMeters?: number | null;
  // برش قائم (vertical/perpendicular edge cuts) for slab stones
  slabVerticalCutSides?: {
    top: boolean;    // بالا
    bottom: boolean; // پایین
    left: boolean;  // چپ
    right: boolean; // راست
  };
  slabVerticalCutCost?: number; // هزینه برش قائم
  slabVerticalCutCostPerMeter?: number; // هزینه برش قائم به ازای هر متر
      // Remaining stone usage tracking
      usedRemainingStones: RemainingStone[]; // سنگ‌های باقی‌مانده استفاده شده
      totalUsedRemainingWidth: number; // مجموع عرض باقی‌مانده استفاده شده
      totalUsedRemainingLength: number; // مجموع طول باقی‌مانده استفاده شده (in meters)
      // Parent-child relationship (explicit reference instead of stoneCode parsing)
      parentProductIndex?: number; // Index of parent product in wizardData.products array (for remaining stone relationships)
      // SubService tracking
      appliedSubServices: AppliedSubService[]; // ابزارهای اعمال شده
      totalSubServiceCost: number; // مجموع هزینه ابزارها
      usedLengthForSubServices: number; // طول استفاده شده برای ابزارهای مبتنی بر طول (in meters)
      usedSquareMetersForSubServices: number; // متر مربع استفاده شده برای ابزارهای مبتنی بر متر مربع
  cuttingBreakdown?: CuttingBreakdownEntry[];
  // Stair-specific fields (for backward compatibility and display)
  treadWidth?: number;
  treadDepth?: number;
  riserHeight?: number;
  numberOfSteps?: number;
  quantityType?: 'steps' | 'staircases';
  nosingType?: string;
  nosingOverhang?: number;
  nosingCuttingCost?: number;
  nosingCuttingCostPerMeter?: number;
  landingWidth?: number;
  landingDepth?: number;
  numberOfLandings?: number;
  // Metadata for stair stepper V2 and other extensions
  meta?: any;
  // Stone finishing
  finishingId?: string | null;
  finishingName?: string | null;
  finishingPricePerSquareMeter?: number | null;
  finishingCost?: number | null;
  finishingSquareMeters?: number | null;
  // CAD Design (for visual design storage)
  cadDesign?: any; // Stores the CAD design data for future reference
}

interface DeliveryProductItem {
  productIndex: number; // Index in wizardData.products array
  productId: string;
  quantity: number; // Quantity for this specific delivery
}

interface DeliverySchedule {
  deliveryDate: string;
  projectManagerName: string; // نام مدیر پروژه
  receiverName: string; // نام تحویل‌گیرنده
  products: DeliveryProductItem[]; // Products with quantities for this delivery
  notes?: string;
}

interface PaymentEntry {
  id: string; // Unique ID for this payment entry
  method: 'CASH' | 'CHECK'; // Payment method types
  amount: number; // Amount for this specific payment
  status: 'PAID' | 'WILL_BE_PAID'; // پرداخت شده | پرداخت خواهد شد
  paymentDate: string; // Persian date - paid date if PAID, due date if WILL_BE_PAID
  description?: string; // Optional description
  nationalCode?: string; // Optional national code for CHECK payments
  checkNumber?: string; // Required check number for CHECK payments
  cashType?: string; // Required cash type for CASH payments (e.g., فوری, عادی, پیش‌پرداخت, پس‌پرداخت)
}

interface PaymentMethod {
  payments: PaymentEntry[]; // Array of payment entries (compound payments)
  currency: string; // Default: 'تومان'
  totalContractAmount: number; // Sum of all products (for validation)
}

// Keep PaymentInstallment for backward compatibility if needed elsewhere
interface PaymentInstallment {
  installmentNumber: number;
  amount: number;
  dueDate: string;
  notes?: string;
}

interface ContractWizardData {
  // Step 1: Contract Date
  contractDate: string;
  contractNumber: string;
  
  // Step 2: Customer
  customerId: string;
  customer: CrmCustomer | null;
  
  // Step 3: Project
  projectId: string;
  project: ProjectAddress | null;
  
  // Step 4: Product Type Selection (NEW)
  selectedProductTypeForAddition: 'longitudinal' | 'stair' | 'slab' | null; // Temporary selection for adding products
  
  // Step 5: Products (was Step 4)
  products: ContractProduct[];
  
  // Step 6: Delivery (was Step 5)
  deliveries: DeliverySchedule[];
  
  // Step 7: Payment (was Step 6)
  payment: PaymentMethod;
  
  // Step 8: Signature (Digital Signature with SMS Verification)
  signature: {
    phoneNumber: string | null;
    verificationCode: string;
    codeSent: boolean;
    codeVerified: boolean;
    contractId: string | null; // Store contract ID after creation
  } | null;
}

// Mock nosing types (will be replaced with inventory services in future)
const NOSING_TYPES = [
  {
    id: 'bullnose',
    name: 'پیشانی گرد (Bullnose)',
    nameEn: 'Bullnose',
    description: 'پیشانی گرد و نرم',
    cuttingCostPerMeter: 15000, // Mock price - will come from services
    available: true
  },
  {
    id: 'square',
    name: 'مربعی (Square)',
    nameEn: 'Square',
    description: 'پیشانی مربعی و تیز',
    cuttingCostPerMeter: 12000, // Mock price
    available: true
  },
  {
    id: 'rounded',
    name: 'گرد (Rounded)',
    nameEn: 'Rounded',
    description: 'پیشانی گرد با شعاع کوچک',
    cuttingCostPerMeter: 14000, // Mock price
    available: true
  },
  {
    id: 'none',
    name: 'بدون پیشانی',
    nameEn: 'No Nosing',
    description: 'بدون پیشانی',
    cuttingCostPerMeter: 0,
    available: true
  }
] as const;

// Product type definitions
const PRODUCT_TYPES = [
  {
    id: 'longitudinal',
    name: 'سنگ طولی',
    nameEn: 'Longitudinal Stone',
    icon: FaRuler,
    description: 'سنگ‌های طولی با برش طولی',
    available: true
  },
  {
    id: 'stair',
    name: 'سنگ پله',
    nameEn: 'Stair Stone',
    icon: FaSquare,
    description: 'سنگ‌های مخصوص پله',
    available: true
  },
  {
    id: 'slab',
    name: 'سنگ اسلب',
    nameEn: 'Slab Stone',
    icon: FaThLarge,
    description: 'سنگ‌های اسلب با برش دو بعدی (طول و عرض)',
    available: true
  },
  {
    id: 'volumetric',
    name: 'سنگ حجمی',
    nameEn: 'Volumetric Stone',
    icon: FaCubes,
    description: 'به‌زودی: مدیریت سفارش سنگ‌های حجمی',
    available: false
  }
] as const;

type ContractUsageType = 'longitudinal' | 'stair' | 'slab' | 'volumetric';
type ContractVisibilityField =
  | 'availableInLongitudinalContracts'
  | 'availableInStairContracts'
  | 'availableInSlabContracts'
  | 'availableInVolumetricContracts';

const CONTRACT_VISIBILITY_FIELD_MAP: Record<ContractUsageType, ContractVisibilityField> = {
  longitudinal: 'availableInLongitudinalContracts',
  stair: 'availableInStairContracts',
  slab: 'availableInSlabContracts',
  volumetric: 'availableInVolumetricContracts'
};

const productSupportsContractType = (
  product: Product,
  contractType?: ContractUsageType | null
): boolean => {
  if (!contractType) return true;
  const fieldName = CONTRACT_VISIBILITY_FIELD_MAP[contractType];
  const flagValue = product[fieldName as keyof Product];
  if (flagValue === undefined || flagValue === null) {
    return true;
  }
  return Boolean(flagValue);
};

interface SlabLineCutPlan {
  axisUsingStandard: 'length' | 'width';
  longitudinalMeters: number;
  crossMeters: number;
}

const determineSlabLineCutPlan = ({
  requestedLengthCm,
  requestedWidthCm,
  standardLengthCm,
  standardWidthCm
}: {
  requestedLengthCm: number;
  requestedWidthCm: number;
  standardLengthCm: number;
  standardWidthCm: number;
}): SlabLineCutPlan => {
  const axes = [
    { key: 'length' as const, requested: requestedLengthCm, standard: standardLengthCm },
    { key: 'width' as const, requested: requestedWidthCm, standard: standardWidthCm }
  ];
  
  const positiveAxes = axes.filter(ax => ax.requested > 0 && ax.standard > 0);
  const longestRequestedValue = positiveAxes.length > 0
    ? Math.max(...positiveAxes.map(ax => ax.requested))
    : Math.max(requestedLengthCm, requestedWidthCm);
  
  let candidates = positiveAxes.filter(ax => ax.requested === longestRequestedValue && ax.requested > 0);
  if (candidates.length === 0) {
    candidates = axes.filter(ax => ax.requested > 0 && ax.standard > 0);
  }
  if (candidates.length === 0) {
    candidates = axes;
  }
  
  const selectedAxis = candidates.reduce((best, current) => {
    if (!best) return current;
    const bestDiff = Math.abs(best.requested - best.standard);
    const currentDiff = Math.abs(current.requested - current.standard);
    return currentDiff <= bestDiff ? current : best;
  }, candidates[0] || { key: 'length' as const, requested: 0, standard: 0 });
  
  const axisUsingStandard = selectedAxis.key;
  const longitudinalMeters = axisUsingStandard === 'length'
    ? (standardLengthCm > 0 ? standardLengthCm / 100 : requestedLengthCm / 100)
    : (requestedLengthCm > 0 ? requestedLengthCm / 100 : standardLengthCm / 100);
  const crossMeters = axisUsingStandard === 'width'
    ? (standardWidthCm > 0 ? standardWidthCm / 100 : requestedWidthCm / 100)
    : (requestedWidthCm > 0 ? requestedWidthCm / 100 : standardWidthCm / 100);
  
  return {
    axisUsingStandard,
    longitudinalMeters: Number.isFinite(longitudinalMeters) ? longitudinalMeters : 0,
    crossMeters: Number.isFinite(crossMeters) ? crossMeters : 0
  };
};

// Step definitions
const WIZARD_STEPS = [
  {
    id: 1,
    title: 'تاریخ قرارداد',
    titleEn: 'Contract Date',
    icon: FaCalendarAlt,
    description: 'انتخاب تاریخ قرارداد'
  },
  {
    id: 2,
    title: 'انتخاب مشتری',
    titleEn: 'Customer Selection',
    icon: FaUser,
    description: 'انتخاب مشتری از سیستم CRM'
  },
  {
    id: 3,
    title: 'مدیریت پروژه',
    titleEn: 'Project Management',
    icon: FaBuilding,
    description: 'انتخاب یا ایجاد پروژه'
  },
  {
    id: 4,
    title: 'انتخاب نوع محصول',
    titleEn: 'Product Type Selection',
    icon: FaLayerGroup,
    description: 'نوع محصول را انتخاب کنید'
  },
  {
    id: 5,
    title: 'انتخاب محصولات',
    titleEn: 'Product Selection',
    icon: FaWarehouse,
    description: 'انتخاب محصولات از کاتالوگ'
  },
  {
    id: 6,
    title: 'برنامه تحویل',
    titleEn: 'Delivery Schedule',
    icon: FaTruck,
    description: 'تعیین تاریخ و آدرس تحویل'
  },
  {
    id: 7,
    title: 'روش پرداخت',
    titleEn: 'Payment Method',
    icon: FaCreditCard,
    description: 'انتخاب روش پرداخت'
  },
  {
    id: 8,
    title: 'امضای دیجیتال',
    titleEn: 'Digital Signature',
    icon: FaSignature,
    description: 'تایید نهایی قرارداد'
  }
];

// Stone cutting calculation utilities
const calculateStoneCutting = (data: {
  originalWidth: number;
  desiredWidth: number;
  length: number;
  cuttingCostPerMeter: number;
  quantity?: number;
  lengthUnit?: 'cm' | 'm';
}) => {
  const { originalWidth, desiredWidth, length, cuttingCostPerMeter, quantity = 1, lengthUnit = 'cm' } = data;
  
  // Convert length to cm for calculations
  const lengthInCm = lengthUnit === 'm' ? length * 100 : length;
  
  // Calculate remaining width after cut
  const remainingWidth = originalWidth - desiredWidth;
  
  // Calculate cutting cost
  const cuttingCost = (lengthInCm / 100) * cuttingCostPerMeter * quantity; // Convert cm to meters and multiply by quantity
  
  // Create cut details
  const cutId = `cut_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const cutDetails: StoneCut = {
    id: cutId,
    originalWidth,
    cutWidth: desiredWidth,
    remainingWidth,
    length: lengthInCm,
    cuttingCost,
    cuttingCostPerMeter
  };
  
  // Create remaining stone
  const remainingStoneId = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  // Include quantity in square meters calculation: length × width × quantity
  const remainingStone: RemainingStone = {
    id: remainingStoneId,
    width: remainingWidth,
    length: lengthInCm,
    squareMeters: (remainingWidth * lengthInCm * quantity) / 10000, // Convert cm² to m², including quantity
    isAvailable: remainingWidth > 0,
    sourceCutId: cutId
  };
  
  return {
    cutDetails,
    remainingStone,
    cuttingCost,
    remainingWidth
  };
};

// Slab stone cutting calculation utilities (2D cutting: longitudinal + cross)
const calculateSlabCutting = (data: {
  originalLength: number; // طول اصلی اسلب (in cm or m)
  originalWidth: number; // عرض اصلی اسلب (in cm)
  desiredLength: number; // طول مورد نظر (in cm or m)
  desiredWidth: number; // عرض مورد نظر (in cm or m)
  lengthUnit?: 'cm' | 'm';
  widthUnit?: 'cm' | 'm';
  cuttingCostPerMeterLongitudinal?: number; // هزینه برش طولی
  cuttingCostPerMeterCross?: number; // هزینه برش عرضی
  quantity?: number;
  longitudinalCutLengthMeters?: number;
  crossCutLengthMeters?: number;
}) => {
  const {
    originalLength,
    originalWidth,
    desiredLength,
    desiredWidth,
    lengthUnit = 'm',
    widthUnit = 'cm',
    cuttingCostPerMeterLongitudinal = 0,
    cuttingCostPerMeterCross = 0,
    quantity = 1,
    longitudinalCutLengthMeters,
    crossCutLengthMeters
  } = data;
  
  // Convert all dimensions to cm for calculations
  const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
  const originalWidthCm = widthUnit === 'm' ? originalWidth * 100 : originalWidth;
  const desiredLengthCm = lengthUnit === 'm' ? desiredLength * 100 : desiredLength;
  const desiredWidthCm = widthUnit === 'm' ? desiredWidth * 100 : desiredWidth;
  
  // Determine if cuts are needed
  const needsLongitudinalCut = desiredWidthCm < originalWidthCm && desiredWidthCm > 0;
  const needsCrossCut = desiredLengthCm < originalLengthCm && desiredLengthCm > 0;
  
  // Calculate cutting costs
  let longitudinalCuttingCost = 0;
  let crossCuttingCost = 0;
  
  const effectiveLongitudinalMeters = longitudinalCutLengthMeters ?? (desiredLengthCm / 100);
  const effectiveCrossMeters = crossCutLengthMeters ?? (desiredWidthCm / 100);
  
  if (needsLongitudinalCut && cuttingCostPerMeterLongitudinal > 0) {
    longitudinalCuttingCost = effectiveLongitudinalMeters * cuttingCostPerMeterLongitudinal * quantity;
  }
  
  if (needsCrossCut && cuttingCostPerMeterCross > 0) {
    crossCuttingCost = effectiveCrossMeters * cuttingCostPerMeterCross * quantity;
  }
  
  const totalCuttingCost = longitudinalCuttingCost + crossCuttingCost;
  
  // Generate cut IDs once for reuse in both cut details and remaining pieces
  const timestamp = Date.now();
  const longitudinalCutId = needsLongitudinalCut ? `cut_longitudinal_${timestamp}_${Math.random().toString(36).substr(2, 9)}` : '';
  const crossCutId = needsCrossCut ? `cut_cross_${timestamp}_${Math.random().toString(36).substr(2, 9)}` : '';
  
  // Calculate remaining pieces (can be multiple pieces for 2D cutting)
  const remainingPieces: RemainingStone[] = [];
  
  if (needsLongitudinalCut || needsCrossCut) {
    const remainingWidth = originalWidthCm - desiredWidthCm;
    const remainingLength = originalLengthCm - desiredLengthCm;
    
    // Piece 1: Remaining width piece (if longitudinal cut)
    if (remainingWidth > 0 && desiredLengthCm > 0) {
      const pieceId1 = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      remainingPieces.push({
        id: pieceId1,
        width: remainingWidth,
        length: desiredLengthCm,
        squareMeters: (remainingWidth * desiredLengthCm * quantity) / 10000,
        isAvailable: remainingWidth > 0,
        sourceCutId: longitudinalCutId || crossCutId || '',
        position: {
          startWidth: desiredWidthCm,
          startLength: 0
        }
      });
    }
    
    // Piece 2: Remaining length piece (if cross cut)
    if (remainingLength > 0 && desiredWidthCm > 0) {
      const pieceId2 = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      remainingPieces.push({
        id: pieceId2,
        width: desiredWidthCm,
        length: remainingLength,
        squareMeters: (desiredWidthCm * remainingLength * quantity) / 10000,
        isAvailable: remainingLength > 0,
        sourceCutId: crossCutId || longitudinalCutId || '',
        position: {
          startWidth: 0,
          startLength: desiredLengthCm
        }
      });
    }
    
    // Piece 3: Corner piece (if both cuts)
    if (remainingWidth > 0 && remainingLength > 0) {
      const pieceId3 = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      remainingPieces.push({
        id: pieceId3,
        width: remainingWidth,
        length: remainingLength,
        squareMeters: (remainingWidth * remainingLength * quantity) / 10000,
        isAvailable: remainingWidth > 0 && remainingLength > 0,
        sourceCutId: crossCutId || longitudinalCutId || '',
        position: {
          startWidth: desiredWidthCm,
          startLength: desiredLengthCm
        }
      });
    }
  }
  
  // Create cut details (using the IDs generated above)
  const cutDetails: StoneCut[] = [];
  
  if (needsLongitudinalCut && cuttingCostPerMeterLongitudinal > 0) {
    cutDetails.push({
      id: longitudinalCutId,
      originalWidth: originalWidthCm,
      cutWidth: desiredWidthCm,
      remainingWidth: originalWidthCm - desiredWidthCm,
      length: effectiveLongitudinalMeters * 100,
      cuttingCost: longitudinalCuttingCost,
      cuttingCostPerMeter: cuttingCostPerMeterLongitudinal
    });
  }
  
  if (needsCrossCut && cuttingCostPerMeterCross > 0) {
    cutDetails.push({
      id: crossCutId,
      originalWidth: originalLengthCm, // For cross cut, we use length as "width" conceptually
      cutWidth: desiredLengthCm,
      remainingWidth: originalLengthCm - desiredLengthCm,
      length: effectiveCrossMeters * 100,
      cuttingCost: crossCuttingCost,
      cuttingCostPerMeter: cuttingCostPerMeterCross
    });
  }
  
  return {
    cutDetails,
    remainingPieces,
    totalCuttingCost,
    longitudinalCuttingCost,
    crossCuttingCost,
    needsLongitudinalCut,
    needsCrossCut,
    remainingWidth: originalWidthCm - desiredWidthCm,
    remainingLength: originalLengthCm - desiredLengthCm
  };
};

// Multi-partition positioning and validation utilities
// This function positions partitions in user-defined order, respecting sequential cutting logic
// Width slice interface for tracking remaining areas
interface WidthSlice {
  startWidth: number; // Where this slice starts (in cm)
  width: number; // Width of this slice (in cm)
  remainingLength: number; // Remaining length in this slice (in meters)
  startLength: number; // Where current cutting position starts in this slice (in meters)
}

interface PartitionPositioningResult {
  positionedPartitions: StonePartition[];
  remainingWidthSlices: WidthSlice[]; // Remaining areas after all partitions are placed
}
const calculatePartitionPositions = (
  partitions: StonePartition[],
  availableWidth: number, // in cm
  availableLength: number // in meters
): StonePartition[] => {
  // Filter out empty partitions
  const validPartitions = partitions.filter(p => p.width > 0 && p.length > 0);
  
  if (validPartitions.length === 0) return partitions;
  
  // IMPORTANT: Respect user-defined order (no sorting) for sequential cutting
  // Users add partitions in the order they want to cut them
  
  // Start with one full width slice
  const widthSlices: WidthSlice[] = [{
    startWidth: 0,
    width: availableWidth,
    remainingLength: availableLength,
    startLength: 0
  }];
  
  const positionedPartitions: StonePartition[] = [];
  const partitionErrors: Map<string, string> = new Map();
  
  for (const partition of validPartitions) {
    // Find a width slice that can accommodate this partition
    let placed = false;
    
    for (let i = 0; i < widthSlices.length; i++) {
      const slice = widthSlices[i];
      
      // Check if partition fits in this slice
      if (partition.width <= slice.width && partition.length <= slice.remainingLength) {
        // Fits! Place it in this slice
        positionedPartitions.push({
          ...partition,
          position: {
            startWidth: slice.startWidth,
            startLength: slice.startLength
          },
          validationError: undefined
        });
        
        // Update the slice based on how the partition was cut
        if (partition.width === slice.width) {
          // Used full width of this slice - just update remaining length
          slice.remainingLength -= partition.length;
          slice.startLength += partition.length;
          
          // If this slice is now fully used, remove it
          if (slice.remainingLength <= 0) {
            widthSlices.splice(i, 1);
          }
        } else {
          // Used partial width - need to split the slice
          // The used portion: from slice.startWidth to slice.startWidth + partition.width
          // The remaining portion: from slice.startWidth + partition.width to slice.startWidth + slice.width
          
          // Create new slice for the remaining width portion (unused width)
          const remainingWidthSlice: WidthSlice = {
            startWidth: slice.startWidth + partition.width,
            width: slice.width - partition.width,
            remainingLength: slice.remainingLength, // Full length still available
            startLength: slice.startLength // Same starting position
          };
          
          // Update the used slice (now represents the used width portion)
          slice.width = partition.width; // This slice now represents only the used width
          slice.remainingLength -= partition.length; // Reduce by partition length
          slice.startLength += partition.length; // Move start forward
          
          // Add the remaining width slice if it has positive dimensions
          if (remainingWidthSlice.width > 0 && remainingWidthSlice.remainingLength > 0) {
            widthSlices.splice(i + 1, 0, remainingWidthSlice);
          }
          
          // Remove the used slice if it's fully used
          if (slice.remainingLength <= 0) {
            widthSlices.splice(i, 1);
            // Adjust index since we removed an element
            i--;
          }
          
          // Sort slices by startWidth for easier management
          widthSlices.sort((a, b) => a.startWidth - b.startWidth);
        }
        
        placed = true;
        break;
      }
    }
    
    if (!placed) {
      // Couldn't place this partition - find the best slice to show error
      let bestSlice: WidthSlice | null = null;
      let bestFit = false;
      
      for (const slice of widthSlices) {
        if (partition.width <= slice.width && partition.length <= slice.remainingLength) {
          bestSlice = slice;
          bestFit = true;
          break;
        }
        
        // Track the slice with the most available space
        if (!bestSlice || (slice.width * slice.remainingLength) > (bestSlice.width * bestSlice.remainingLength)) {
          bestSlice = slice;
        }
      }
      
      // Set appropriate error message
      if (bestSlice) {
        if (partition.width > bestSlice.width) {
          partitionErrors.set(partition.id, `عرض پارتیشن (${formatDisplayNumber(partition.width)}cm) بیش از عرض باقی‌مانده (${formatDisplayNumber(bestSlice.width)}cm) است`);
        } else if (partition.length > bestSlice.remainingLength) {
          partitionErrors.set(partition.id, `طول پارتیشن (${formatDisplayNumber(partition.length)}m) بیش از طول باقی‌مانده (${formatDisplayNumber(bestSlice.remainingLength)}m) است`);
        } else {
          partitionErrors.set(partition.id, `این پارتیشن نمی‌تواند در محدوده باقی‌مانده قرار گیرد`);
        }
      } else {
        partitionErrors.set(partition.id, `این پارتیشن نمی‌تواند در محدوده باقی‌مانده قرار گیرد`);
      }
      
      positionedPartitions.push({
        ...partition,
        position: undefined,
        validationError: partitionErrors.get(partition.id)
      });
    }
  }
  
  // Map back to original order using IDs, preserving errors
  const resultMap = new Map<string, StonePartition>();
  positionedPartitions.forEach(p => resultMap.set(p.id, p));
  
  // Merge with empty partitions (keep them as-is)
  const emptyPartitions = partitions.filter(p => !p.width || !p.length);
  const result = partitions
    .filter(p => p.width > 0 && p.length > 0)
    .map(p => resultMap.get(p.id) || { ...p, validationError: partitionErrors.get(p.id) || undefined })
    .concat(emptyPartitions);
  
  return result;
};

// Internal function that returns both positioned partitions AND remaining width slices
// This uses the same logic as calculatePartitionPositions but also returns the remaining width slices
const calculatePartitionPositionsWithSlices = (
  partitions: StonePartition[],
  availableWidth: number, // in cm
  availableLength: number // in meters
): PartitionPositioningResult => {
  // Filter out empty partitions
  const validPartitions = partitions.filter(p => p.width > 0 && p.length > 0);
  
  if (validPartitions.length === 0) {
    return {
      positionedPartitions: partitions,
      remainingWidthSlices: [{
        startWidth: 0,
        width: availableWidth,
        remainingLength: availableLength,
        startLength: 0
      }]
    };
  }
  
  // Start with one full width slice
  const widthSlices: WidthSlice[] = [{
    startWidth: 0,
    width: availableWidth,
    remainingLength: availableLength,
    startLength: 0
  }];
  
  const positionedPartitions: StonePartition[] = [];
  const partitionErrors: Map<string, string> = new Map();
  
  for (const partition of validPartitions) {
    // Find a width slice that can accommodate this partition
    let placed = false;
    
    for (let i = 0; i < widthSlices.length; i++) {
      const slice = widthSlices[i];
      
      // Check if partition fits in this slice
      if (partition.width <= slice.width && partition.length <= slice.remainingLength) {
        // Fits! Place it in this slice
        positionedPartitions.push({
          ...partition,
          position: {
            startWidth: slice.startWidth,
            startLength: slice.startLength
          },
          validationError: undefined
        });
        
        // Update the slice based on how the partition was cut
        if (partition.width === slice.width) {
          // Used full width of this slice - just update remaining length
          slice.remainingLength -= partition.length;
          slice.startLength += partition.length;
          
          // If this slice is now fully used, remove it
          if (slice.remainingLength <= 0) {
            widthSlices.splice(i, 1);
          }
        } else {
          // Used partial width - need to split the slice
          // The used portion: from slice.startWidth to slice.startWidth + partition.width
          // The remaining portion: from slice.startWidth + partition.width to slice.startWidth + slice.width
          
          // Create new slice for the remaining width portion (unused width)
          const remainingWidthSlice: WidthSlice = {
            startWidth: slice.startWidth + partition.width,
            width: slice.width - partition.width,
            remainingLength: slice.remainingLength, // Full length still available
            startLength: slice.startLength // Same starting position
          };
          
          // Update the used slice (now represents the used width portion)
          slice.width = partition.width; // This slice now represents only the used width
          slice.remainingLength -= partition.length; // Reduce by partition length
          slice.startLength += partition.length; // Move start forward
          
          // Add the remaining width slice if it has positive dimensions
          if (remainingWidthSlice.width > 0 && remainingWidthSlice.remainingLength > 0) {
            widthSlices.splice(i + 1, 0, remainingWidthSlice);
          }
          
          // Remove the used slice if it's fully used
          if (slice.remainingLength <= 0) {
            widthSlices.splice(i, 1);
            // Adjust index since we removed an element
            i--;
          }
          
          // Sort slices by startWidth for easier management
          widthSlices.sort((a, b) => a.startWidth - b.startWidth);
        }
        
        placed = true;
        break;
      }
    }
    
    if (!placed) {
      // Couldn't place this partition - find the best slice to show error
      let bestSlice: WidthSlice | null = null;
      let bestFit = false;
      
      for (const slice of widthSlices) {
        if (partition.width <= slice.width && partition.length <= slice.remainingLength) {
          bestSlice = slice;
          bestFit = true;
          break;
        }
        
        // Track the slice with the most available space
        if (!bestSlice || (slice.width * slice.remainingLength) > (bestSlice.width * bestSlice.remainingLength)) {
          bestSlice = slice;
        }
      }
      
      // Set appropriate error message
      if (bestSlice) {
        if (partition.width > bestSlice.width) {
          partitionErrors.set(partition.id, `عرض پارتیشن (${formatDisplayNumber(partition.width)}cm) بیش از عرض باقی‌مانده (${formatDisplayNumber(bestSlice.width)}cm) است`);
        } else if (partition.length > bestSlice.remainingLength) {
          partitionErrors.set(partition.id, `طول پارتیشن (${formatDisplayNumber(partition.length)}m) بیش از طول باقی‌مانده (${formatDisplayNumber(bestSlice.remainingLength)}m) است`);
        } else {
          partitionErrors.set(partition.id, `این پارتیشن نمی‌تواند در محدوده باقی‌مانده قرار گیرد`);
        }
      } else {
        partitionErrors.set(partition.id, `این پارتیشن نمی‌تواند در محدوده باقی‌مانده قرار گیرد`);
      }
      
      positionedPartitions.push({
        ...partition,
        position: undefined,
        validationError: partitionErrors.get(partition.id)
      });
    }
  }
  
  // Map back to original order using IDs, preserving errors
  const resultMap = new Map<string, StonePartition>();
  positionedPartitions.forEach(p => resultMap.set(p.id, p));
  
  // Merge with empty partitions (keep them as-is)
  const emptyPartitions = partitions.filter(p => !p.width || !p.length);
  const result = partitions
    .filter(p => p.width > 0 && p.length > 0)
    .map(p => resultMap.get(p.id) || { ...p, validationError: partitionErrors.get(p.id) || undefined })
    .concat(emptyPartitions);
  
  // Filter out fully used slices (remainingLength <= 0 or width <= 0)
  const remainingWidthSlices = widthSlices.filter(slice => slice.remainingLength > 0 && slice.width > 0);
  
  return {
    positionedPartitions: result,
    remainingWidthSlices
  };
};

interface PartitionValidationResult {
  isValid: boolean;
  error?: string; // General error message
  partitionErrors: Map<string, string>; // Partition ID -> error message
  validatedPartitions: StonePartition[]; // Partitions with validation errors attached
}

const validatePartitions = (
  partitions: StonePartition[],
  availableWidth: number, // in cm
  availableLength: number, // in meters
  availableSquareMeters: number
): PartitionValidationResult => {
  const validPartitions = partitions.filter(p => p.width > 0 && p.length > 0);
  const partitionErrors = new Map<string, string>();
  
  if (validPartitions.length === 0) {
    return {
      isValid: false,
      error: 'لطفاً حداقل یک پارتیشن با ابعاد معتبر تعریف کنید',
      partitionErrors,
      validatedPartitions: partitions
    };
  }
  
  // Validate each partition fits within bounds (basic dimension checks)
  for (const partition of validPartitions) {
    if (partition.width > availableWidth) {
      partitionErrors.set(partition.id, `عرض (${formatDisplayNumber(partition.width)}cm) بیش از عرض موجود (${formatDisplayNumber(availableWidth)}cm) است`);
    }
    if (partition.length > availableLength) {
      partitionErrors.set(partition.id, `طول (${formatDisplayNumber(partition.length)}m) بیش از طول موجود (${formatDisplayNumber(availableLength)}m) است`);
    }
  }
  
  // Calculate total area used
  const totalUsedSquareMeters = validPartitions.reduce((sum, p) => sum + p.squareMeters, 0);
  
  if (totalUsedSquareMeters > availableSquareMeters) {
    // Add area error to all partitions that contributed
    validPartitions.forEach(partition => {
      if (!partitionErrors.has(partition.id)) {
        partitionErrors.set(partition.id, `مجموع متر مربع پارتیشن‌ها (${formatDisplayNumber(totalUsedSquareMeters)}) بیش از متر مربع موجود (${formatDisplayNumber(availableSquareMeters)}) است`);
      }
    });
    
    return {
      isValid: false,
      error: `مجموع متر مربع پارتیشن‌ها (${formatDisplayNumber(totalUsedSquareMeters)}) نمی‌تواند بیشتر از متر مربع موجود (${formatDisplayNumber(availableSquareMeters)}) باشد`,
      partitionErrors,
      validatedPartitions: partitions.map(p => ({
        ...p,
        validationError: partitionErrors.get(p.id)
      }))
    };
  }
  
  // Check positioning - this will identify which specific partitions don't fit
  const positionedPartitions = calculatePartitionPositions(validPartitions, availableWidth, availableLength);
  
  // Collect errors from positioning
  positionedPartitions.forEach(partition => {
    if (partition.validationError && !partitionErrors.has(partition.id)) {
      partitionErrors.set(partition.id, partition.validationError);
    }
    if (!partition.position && !partitionErrors.has(partition.id)) {
      partitionErrors.set(partition.id, 'این پارتیشن نمی‌تواند در محدوده موجود قرار گیرد. لطفاً ابعاد را کاهش دهید یا آن را حذف کنید.');
    }
  });
  
  // Check for overlaps between partitions (shouldn't happen with proper positioning, but verify)
  for (let i = 0; i < positionedPartitions.length; i++) {
    const p1 = positionedPartitions[i];
    if (!p1.position) continue;
    
    for (let j = i + 1; j < positionedPartitions.length; j++) {
      const p2 = positionedPartitions[j];
      if (!p2.position) continue;
      
      // Check if rectangles overlap
      const p1EndWidth = p1.position.startWidth + p1.width;
      const p1EndLength = p1.position.startLength + p1.length;
      const p2EndWidth = p2.position.startWidth + p2.width;
      const p2EndLength = p2.position.startLength + p2.length;
      
      const overlaps = !(
        p1EndWidth <= p2.position.startWidth ||
        p2EndWidth <= p1.position.startWidth ||
        p1EndLength <= p2.position.startLength ||
        p2EndLength <= p1.position.startLength
      );
      
      if (overlaps) {
        partitionErrors.set(p1.id, 'این پارتیشن با پارتیشن دیگر همپوشانی دارد');
        partitionErrors.set(p2.id, 'این پارتیشن با پارتیشن دیگر همپوشانی دارد');
      }
    }
  }
  
  // Build result with errors mapped to original partition order
  const validatedPartitions = partitions.map(p => {
    const positioned = positionedPartitions.find(pos => pos.id === p.id);
    return {
      ...p,
      validationError: partitionErrors.get(p.id) || positioned?.validationError || undefined,
      position: positioned?.position
    };
  });
  
  const hasErrors = partitionErrors.size > 0;
  
  return {
    isValid: !hasErrors,
    error: hasErrors 
      ? `${partitionErrors.size} پارتیشن دارای مشکل است. لطفاً ابعاد را بررسی و اصلاح کنید.`
      : undefined,
    partitionErrors,
    validatedPartitions
  };
};

// Unified function to calculate remaining stone dimensions
const calculateRemainingStoneDimensions = (
  originalWidth: number, // in cm
  originalLength: number, // in meters
  productWidth: number, // in cm
  productLength: number, // in meters (or cm, will be converted)
  productLengthUnit: 'cm' | 'm',
  usedRemainingWidth: number = 0, // in cm
  usedRemainingLength: number = 0 // in meters
): { remainingWidth: number; remainingLength: number; canHaveRemaining: boolean } => {
  const productLengthInMeters = productLengthUnit === 'm' ? productLength : (productLength / 100);
  const remainingWidth = originalWidth - productWidth - usedRemainingWidth;
  const remainingLength = originalLength - productLengthInMeters - usedRemainingLength;
  const canHaveRemaining = originalWidth > 0 && productWidth > 0 && productWidth < originalWidth && remainingWidth > 0 && remainingLength > 0;
  
  return {
    remainingWidth: Math.max(0, remainingWidth),
    remainingLength: Math.max(0, remainingLength),
    canHaveRemaining
  };
};

// Recalculate totalUsedRemainingWidth/Length from usedRemainingStones array
const recalculateUsedRemainingDimensions = (usedRemainingStones: RemainingStone[]): {
  totalUsedWidth: number;
  totalUsedLength: number;
} => {
  const totalUsedWidth = usedRemainingStones.reduce((sum, stone) => sum + (stone.width || 0), 0);
  const totalUsedLength = usedRemainingStones.reduce((max, stone) => Math.max(max, stone.length || 0), 0);
  
  return {
    totalUsedWidth,
    totalUsedLength
  };
};

const calculateRemainingAreasAfterPartitions = (
  partitions: StonePartition[],
  availableWidth: number, // in cm
  availableLength: number // in meters
): RemainingStone[] => {
  const validPartitions = partitions.filter(p => p.width > 0 && p.length > 0);
  if (validPartitions.length === 0) {
    // No partitions - entire area is remaining
    return [{
      id: `remaining_all_${Date.now()}`,
      width: availableWidth,
      length: availableLength,
      squareMeters: (availableWidth * availableLength * 100) / 10000, // Convert to m²
      isAvailable: true,
      sourceCutId: ''
    }];
  }
  
  // CRITICAL FIX: Use the positioning function that returns remaining width slices
  // This ensures we use the EXACT same logic that was used to position partitions
  const positioningResult = calculatePartitionPositionsWithSlices(validPartitions, availableWidth, availableLength);
  const remainingWidthSlices = positioningResult.remainingWidthSlices;
  
  // Convert remaining width slices to RemainingStone objects
  const remainingPieces: RemainingStone[] = [];
  const timestampForIds = Date.now();
  
  for (let i = 0; i < remainingWidthSlices.length; i++) {
    const slice = remainingWidthSlices[i];
    
    // Each width slice represents a remaining rectangular area
    // The slice has:
    // - startWidth: where it starts in width (cm)
    // - width: the width of the remaining area (cm)
    // - startLength: where it starts in length (meters) - this is where the last partition in this slice ended
    // - remainingLength: how much length is remaining from startLength (meters)
    
    if (slice.width > 0 && slice.remainingLength > 0) {
      remainingPieces.push({
        id: `remaining_slice_${timestampForIds}_${i}`,
        width: slice.width,
        length: slice.remainingLength,
        squareMeters: (slice.width * slice.remainingLength * 100) / 10000, // Convert to m²
        isAvailable: true,
        sourceCutId: '',
        position: {
          startWidth: slice.startWidth,
          startLength: slice.startLength
        }
      });
    }
  }
  
  // Filter out pieces with invalid dimensions
  return remainingPieces.filter(p => p.width > 0 && p.length > 0 && p.squareMeters > 0);
};

// Product name generation utilities
const generateFullProductName = (product: Product): string => {
  const parts = [
    product.stoneTypeNamePersian,
    product.cuttingDimensionNamePersian,
    `عرض ${product.widthValue}×ضخامت ${product.thicknessValue}cm`,
    product.mineNamePersian,
    product.finishNamePersian,
    product.colorNamePersian,
    product.qualityNamePersian
  ].filter(part => part && part.trim() !== '');
  
  return parts.join(' - ');
};

// Stone calculation utilities
// Smart calculation function to handle bidirectional calculations
const handleSmartCalculation = (
  changedField: 'length' | 'width' | 'squareMeters' | 'quantity',
  value: number,
  currentConfig: any,
  lengthUnit: 'cm' | 'm',
  widthUnit: 'cm' | 'm',
  effectiveQuantity?: number
) => {
  const { length, width, squareMeters, quantity } = currentConfig;
  
  // Use effective quantity if provided, otherwise use quantity from config
  const actualQuantity = effectiveQuantity !== undefined ? effectiveQuantity : (quantity || 1);
  
  console.log('🧮 Smart Calculation Triggered:', {
    changedField,
    value,
    currentConfig: { length, width, squareMeters, quantity },
    lengthUnit,
    widthUnit
  });
  
  // Convert dimensions to cm for calculations
  const lengthInCm = length ? (lengthUnit === 'm' ? length * 100 : length) : 0;
  const widthInCm = width ? (widthUnit === 'm' ? width * 100 : width) : 0;
  
  let newLength = length;
  let newWidth = width;
  let newSquareMeters = squareMeters;
  
  // Update the changed field
  if (changedField === 'length') {
    newLength = value;
  } else if (changedField === 'width') {
    newWidth = value;
  } else if (changedField === 'squareMeters') {
    newSquareMeters = value;
  } else if (changedField === 'quantity') {
    // Quantity change affects square meters calculation
    if (lengthInCm && widthInCm) {
      newSquareMeters = (lengthInCm * widthInCm * actualQuantity) / 10000;
    }
  }
  
  // Smart calculation logic
  if (changedField === 'length' || changedField === 'width' || changedField === 'quantity') {
    // If we have both length and width, calculate square meters
    const updatedLengthInCm = changedField === 'length' ? (lengthUnit === 'm' ? value * 100 : value) : lengthInCm;
    const updatedWidthInCm = changedField === 'width' ? (widthUnit === 'm' ? value * 100 : value) : widthInCm;
    const updatedQuantity = changedField === 'quantity' ? actualQuantity : actualQuantity;
    
    console.log('📐 Dimension Calculation:', {
      updatedLengthInCm,
      updatedWidthInCm,
      updatedQuantity,
      actualQuantity,
      willCalculate: !!(updatedLengthInCm && updatedWidthInCm)
    });
    
    if (updatedLengthInCm && updatedWidthInCm) {
      newSquareMeters = (updatedLengthInCm * updatedWidthInCm * updatedQuantity) / 10000;
      console.log('✅ Calculated Square Meters:', newSquareMeters);
    }
  } else if (changedField === 'squareMeters') {
    // If square meters is manually changed, recalculate length based on current width
    const updatedQuantity = actualQuantity;
    
    if (widthInCm) {
      // Calculate length from width and square meters (width takes priority)
      const calculatedLengthInCm = (value * 10000) / (widthInCm * updatedQuantity);
      newLength = lengthUnit === 'm' ? calculatedLengthInCm / 100 : calculatedLengthInCm;
      console.log('✅ Calculated Length from Width and Square Meters:', newLength);
    } else if (lengthInCm) {
      // Calculate width from length and square meters (if no width available)
      const calculatedWidthInCm = (value * 10000) / (lengthInCm * updatedQuantity);
      newWidth = widthUnit === 'm' ? calculatedWidthInCm / 100 : calculatedWidthInCm;
      console.log('✅ Calculated Width from Length and Square Meters:', newWidth);
    }
  }
  
  const result = {
    length: newLength,
    width: newWidth,
    squareMeters: newSquareMeters
  };
  
  console.log('🎯 Smart Calculation Result:', result);
  
  return result;
};
const calculateStoneMetrics = (data: {
  length?: number;
  width?: number;
  quantity?: number;
  squareMeters?: number;
  pricePerSquareMeter?: number;
  lengthUnit?: 'cm' | 'm';
  widthUnit?: 'cm' | 'm';
  isMandatory?: boolean;
  mandatoryPercentage?: number;
  isCut?: boolean;
  originalWidth?: number;
  cuttingCostPerMeter?: number;
}) => {
  const { length, width, quantity = 1, squareMeters, pricePerSquareMeter, lengthUnit = 'cm', widthUnit = 'cm', isMandatory = false, mandatoryPercentage = 20, isCut = false, originalWidth = 0, cuttingCostPerMeter = 0 } = data;
  
  let calculatedSquareMeters = 0;
  let calculatedLength = 0;
  let calculatedWidth = 0;
  let calculatedTotalPrice = 0;
  let originalTotalPrice = 0;
  
  // Convert dimensions to cm for calculations
  const lengthInCm = length ? (lengthUnit === 'm' ? length * 100 : length) : 0;
  const widthInCm = width ? (widthUnit === 'm' ? width * 100 : width) : 0;
  
  // Scenario 1: We have length and width, calculate square meters
  if (lengthInCm && widthInCm && !squareMeters) {
    calculatedSquareMeters = (lengthInCm * widthInCm * quantity) / 10000; // Convert cm² to m²
  }
  // Scenario 2: We have square meters and width, calculate length
  else if (squareMeters && widthInCm && !length) {
    calculatedLength = (squareMeters * 10000) / (widthInCm * quantity); // Convert m² to cm²
    // Convert back to original unit
    calculatedLength = lengthUnit === 'm' ? calculatedLength / 100 : calculatedLength;
  }
  // Scenario 3: We have square meters and length, calculate width
  else if (squareMeters && lengthInCm && !width) {
    calculatedWidth = (squareMeters * 10000) / (lengthInCm * quantity); // Convert m² to cm²
    // Convert back to original unit
    calculatedWidth = widthUnit === 'm' ? calculatedWidth / 100 : calculatedWidth;
  }
  // Scenario 4: We have all dimensions, use provided square meters
  else if (squareMeters) {
    calculatedSquareMeters = squareMeters;
  }
  
  // Calculate total price if we have price per square meter
  if (pricePerSquareMeter && calculatedSquareMeters) {
    console.log('💰 Starting price calculation:', {
      isCut,
      originalWidth,
      widthInCm,
      calculatedSquareMeters,
      pricePerSquareMeter
    });
    
    // 🎯 CRITICAL FIX: Always use original width for pricing when available
    let pricingSquareMeters = calculatedSquareMeters;
    
    if (originalWidth > 0 && widthInCm > 0) {
      // Always calculate pricing based on ORIGINAL width when available
      const originalWidthInCm = typeof originalWidth === 'string' ? parseFloat(originalWidth) : originalWidth;
      const lengthInCmForPricing = lengthInCm;
      
      // Calculate square meters for pricing using ORIGINAL width
      pricingSquareMeters = (lengthInCmForPricing * originalWidthInCm * quantity) / 10000;
      
      console.log('🔧 Pricing with Original Width:', {
        userEnteredWidth: widthInCm,
        originalWidth: originalWidthInCm,
        length: lengthInCmForPricing,
        quantity,
        displaySquareMeters: calculatedSquareMeters, // For display (user-entered width)
        pricingSquareMeters: pricingSquareMeters, // For pricing (original width)
        pricePerSquareMeter,
        isCut,
        isMandatory
      });
    } else {
      console.log('💰 Regular pricing (no original width available):', {
        isCut,
        originalWidth,
        widthInCm,
        pricingSquareMeters: calculatedSquareMeters
      });
    }
    
    originalTotalPrice = pricingSquareMeters * pricePerSquareMeter;
    
    console.log('💰 Final Pricing Calculation:', {
      pricingSquareMeters,
      pricePerSquareMeter,
      originalTotalPrice,
      isMandatory,
      mandatoryPercentage
    });
    
    // Calculate cutting cost if stone is cut (but DON'T add it to totalPrice)
    // Cutting cost will be shown separately in خلاصه هزینه‌های برش only
    let cuttingCost = 0;
    if (isCut && originalWidth > 0 && cuttingCostPerMeter > 0) {
      const lengthInCm = lengthUnit === 'm' ? (length || 0) * 100 : (length || 0);
      cuttingCost = (lengthInCm / 100) * cuttingCostPerMeter * quantity; // Convert cm to meters and multiply by quantity
    }
    
    // Apply mandatory percentage increase if enabled
    // IMPORTANT: cuttingCost is NOT added to calculatedTotalPrice - it's shown separately
    if (isMandatory && mandatoryPercentage > 0) {
      calculatedTotalPrice = originalTotalPrice * (1 + mandatoryPercentage / 100);
    } else {
      calculatedTotalPrice = originalTotalPrice;
    }
  }
  
  return {
    squareMeters: calculatedSquareMeters, // This remains the cut piece square meters for display
    length: calculatedLength || length || 0,
    width: calculatedWidth || width || 0,
    totalPrice: calculatedTotalPrice, // This now uses original width for pricing
    originalTotalPrice: originalTotalPrice, // This now uses original width for pricing
    cuttingCost: isCut && originalWidth > 0 && cuttingCostPerMeter > 0 ? 
      ((lengthUnit === 'm' ? (length || 0) * 100 : (length || 0)) / 100) * cuttingCostPerMeter * quantity : 0
  };
};

// Helper function to calculate cutting cost for a single standard dimension entry
const calculateSlabCuttingCostForEntry = (data: {
  standardLengthCm: number;
  standardWidthCm: number;
  requestedLengthCm: number;
  requestedWidthCm: number;
  quantity: number;
  cuttingCostPerMeterLongitudinal: number;
  cuttingCostPerMeterCross: number;
  lineCutLongitudinalMeters?: number;
  lineCutCrossMeters?: number;
}): number => {
  const {
    standardLengthCm,
    standardWidthCm,
    requestedLengthCm,
    requestedWidthCm,
    quantity,
    cuttingCostPerMeterLongitudinal,
    cuttingCostPerMeterCross,
    lineCutLongitudinalMeters,
    lineCutCrossMeters
  } = data;
  
  let entryCuttingCost = 0;
  
  const needsLongitudinalCut = requestedWidthCm < standardWidthCm && requestedWidthCm > 0;
  const needsCrossCut = requestedLengthCm < standardLengthCm && requestedLengthCm > 0;
  
  if (needsLongitudinalCut && cuttingCostPerMeterLongitudinal > 0) {
    const longitudinalMeters = lineCutLongitudinalMeters ?? (requestedLengthCm / 100);
    entryCuttingCost += longitudinalMeters * cuttingCostPerMeterLongitudinal * quantity;
  }
  
  if (needsCrossCut && cuttingCostPerMeterCross > 0) {
    const crossMeters = lineCutCrossMeters ?? (requestedWidthCm / 100);
    entryCuttingCost += crossMeters * cuttingCostPerMeterCross * quantity;
  }
  
  return entryCuttingCost;
};

// Helper function to calculate برش قائم (vertical/perpendicular edge cuts) cost for slab stones
const calculateSlabVerticalCutCost = (data: {
  requestedLengthCm: number;
  requestedWidthCm: number;
  quantity: number;
  verticalCutSides: {
    top: boolean;
    bottom: boolean;
    left: boolean;
    right: boolean;
  };
  verticalCutCostPerMeter: number;
}): number => {
  const {
    requestedLengthCm,
    requestedWidthCm,
    quantity,
    verticalCutSides,
    verticalCutCostPerMeter
  } = data;
  
  // If no cost per meter or no active sides, return 0
  if (verticalCutCostPerMeter <= 0) {
    return 0;
  }
  
  // Calculate total meters for active sides
  let totalMeters = 0;
  
  // Top and bottom sides use width
  if (verticalCutSides.top) {
    totalMeters += requestedWidthCm / 100; // Convert cm to meters
  }
  if (verticalCutSides.bottom) {
    totalMeters += requestedWidthCm / 100;
  }
  
  // Left and right sides use length
  if (verticalCutSides.left) {
    totalMeters += requestedLengthCm / 100; // Convert cm to meters
  }
  if (verticalCutSides.right) {
    totalMeters += requestedLengthCm / 100;
  }
  
  // Calculate total cost: total meters × cost per meter × quantity
  return totalMeters * verticalCutCostPerMeter * quantity;
};

// Slab stone metrics calculation (similar to calculateStoneMetrics but for 2D cutting)
// Now supports multiple standard dimensions
const calculateSlabMetrics = (data: {
  length?: number;
  width?: number;
  quantity?: number;
  squareMeters?: number;
  pricePerSquareMeter?: number;
  lengthUnit?: 'cm' | 'm';
  widthUnit?: 'cm' | 'm';
  isMandatory?: boolean;
  mandatoryPercentage?: number;
  originalLength?: number; // طول اصلی اسلب (legacy single dimension)
  originalWidth?: number; // عرض اصلی اسلب (legacy single dimension)
  standardDimensions?: SlabStandardDimensionEntry[]; // New: multiple standard dimensions
  cuttingCostPerMeterLongitudinal?: number;
  cuttingCostPerMeterCross?: number;
  slabCuttingMode?: 'perSquareMeter' | 'lineBased';
  slabCuttingPricePerSquareMeter?: number;
  lineCutLongitudinalMeters?: number;
  lineCutCrossMeters?: number;
}) => {
  const {
    length,
    width,
    quantity = 1,
    squareMeters,
    pricePerSquareMeter,
    lengthUnit = 'm',
    widthUnit = 'cm',
    isMandatory = false,
    mandatoryPercentage = 20,
    originalLength = 0,
    originalWidth = 0,
    standardDimensions = [],
    cuttingCostPerMeterLongitudinal = 0,
    cuttingCostPerMeterCross = 0,
    slabCuttingMode = 'lineBased',
    slabCuttingPricePerSquareMeter = 0,
    lineCutLongitudinalMeters,
    lineCutCrossMeters
  } = data;
  
  let calculatedSquareMeters = 0;
  let calculatedLength = 0;
  let calculatedWidth = 0;
  let calculatedTotalPrice = 0;
  let originalTotalPrice = 0;
  
  // Convert dimensions to cm for calculations
  const lengthInCm = length ? (lengthUnit === 'm' ? length * 100 : length) : 0;
  const widthInCm = width ? (widthUnit === 'm' ? width * 100 : width) : 0;
  
  // Scenario 1: We have length and width, calculate square meters
  if (lengthInCm && widthInCm && !squareMeters) {
    calculatedSquareMeters = (lengthInCm * widthInCm * quantity) / 10000; // Convert cm² to m²
  }
  // Scenario 2: We have square meters and width, calculate length
  else if (squareMeters && widthInCm && !length) {
    calculatedLength = (squareMeters * 10000) / (widthInCm * quantity); // Convert m² to cm²
    calculatedLength = lengthUnit === 'm' ? calculatedLength / 100 : calculatedLength;
  }
  // Scenario 3: We have square meters and length, calculate width
  else if (squareMeters && lengthInCm && !width) {
    calculatedWidth = (squareMeters * 10000) / (lengthInCm * quantity); // Convert m² to cm²
    calculatedWidth = widthUnit === 'm' ? calculatedWidth / 100 : calculatedWidth;
  }
  // Scenario 4: We have all dimensions, use provided square meters
  else if (squareMeters) {
    calculatedSquareMeters = squareMeters;
  }
  
  // Calculate total price if we have price per square meter
  if (pricePerSquareMeter && calculatedSquareMeters) {
    // For slabs, pricing is based on original dimensions (like longitudinal stones)
    let pricingSquareMeters = calculatedSquareMeters;
    
    // If we have multiple standard dimensions, calculate pricing for each entry
    if (standardDimensions.length > 0) {
      pricingSquareMeters = standardDimensions.reduce((total, entry) => {
        const entrySqm = (entry.standardLengthCm * entry.standardWidthCm * entry.quantity) / 10000;
        return total + entrySqm;
      }, 0);
    } else if (originalLength > 0 && originalWidth > 0 && lengthInCm > 0 && widthInCm > 0) {
      // Fallback to legacy single dimension calculation
      const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
      const originalWidthCm = widthUnit === 'm' ? originalWidth * 100 : originalWidth;
      pricingSquareMeters = (originalLengthCm * originalWidthCm * quantity) / 10000;
    }
    
    originalTotalPrice = pricingSquareMeters * pricePerSquareMeter;
    
    // Apply mandatory percentage increase if enabled
    if (isMandatory && mandatoryPercentage > 0) {
      calculatedTotalPrice = originalTotalPrice * (1 + mandatoryPercentage / 100);
    } else {
      calculatedTotalPrice = originalTotalPrice;
    }
  }
  
  // Calculate cutting costs (2D: longitudinal + cross)
  let totalCuttingCost = 0;
  if (slabCuttingMode === 'perSquareMeter' && slabCuttingPricePerSquareMeter > 0) {
    const targetSqm = calculatedSquareMeters || ((lengthInCm && widthInCm)
      ? (lengthInCm * widthInCm * quantity) / 10000
      : 0);
    totalCuttingCost = targetSqm * slabCuttingPricePerSquareMeter;
  } else if (lengthInCm > 0 && widthInCm > 0) {
    // If we have multiple standard dimensions, calculate cutting cost for each entry
    if (standardDimensions.length > 0) {
      totalCuttingCost = standardDimensions.reduce((total, entry) => {
        const entryCuttingCost = calculateSlabCuttingCostForEntry({
          standardLengthCm: entry.standardLengthCm,
          standardWidthCm: entry.standardWidthCm,
          requestedLengthCm: lengthInCm,
          requestedWidthCm: widthInCm,
          quantity: entry.quantity,
          cuttingCostPerMeterLongitudinal,
          cuttingCostPerMeterCross,
          lineCutLongitudinalMeters,
          lineCutCrossMeters
        });
        return total + entryCuttingCost;
      }, 0);
    } else if (originalLength > 0 && originalWidth > 0) {
      // Fallback to legacy single dimension calculation
    const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
    const originalWidthCm = widthUnit === 'm' ? originalWidth * 100 : originalWidth;
    
      const longitudinalMeters = lineCutLongitudinalMeters ?? (lengthInCm / 100);
      const crossMeters = lineCutCrossMeters ?? (widthInCm / 100);
      
    if (widthInCm < originalWidthCm && cuttingCostPerMeterLongitudinal > 0) {
        const longitudinalCost = longitudinalMeters * cuttingCostPerMeterLongitudinal * quantity;
      totalCuttingCost += longitudinalCost;
    }
    
    if (lengthInCm < originalLengthCm && cuttingCostPerMeterCross > 0) {
        const crossCost = crossMeters * cuttingCostPerMeterCross * quantity;
      totalCuttingCost += crossCost;
      }
    }
  }
  
  return {
    squareMeters: calculatedSquareMeters,
    length: calculatedLength || length || 0,
    width: calculatedWidth || width || 0,
    totalPrice: calculatedTotalPrice,
    originalTotalPrice: originalTotalPrice,
    cuttingCost: totalCuttingCost
  };
};

// Stair stone calculation utilities
const calculateStairStoneMetrics = (data: {
  treadWidth: number; // طول پله (cm or m)
  treadWidthUnit: 'cm' | 'm';
  treadDepth: number; // عرض پله (cm)
  numberOfSteps: number; // تعداد پله
  numberOfLandings?: number; // تعداد پاگرد
  landingWidth?: number; // عرض پاگرد (cm)
  landingDepth?: number; // عمق پاگرد (cm)
  numberOfStaircases?: number; // تعداد پله‌کان کامل (if quantityType === 'staircases')
  quantityType?: 'steps' | 'staircases';
}) => {
  const {
    treadWidth,
    treadWidthUnit,
    treadDepth,
    numberOfSteps,
    numberOfLandings = 0,
    landingWidth = 0,
    landingDepth = 0,
    numberOfStaircases = 1,
    quantityType = 'steps'
  } = data;
  
  // Convert tread width to cm
  const treadWidthInCm = treadWidthUnit === 'm' ? treadWidth * 100 : treadWidth;
  
  // Calculate area per step (tread width × tread depth)
  const areaPerStep = (treadWidthInCm * treadDepth) / 10000; // Convert cm² to m²
  
  // Calculate total steps based on quantity type
  const totalSteps = quantityType === 'staircases' 
    ? numberOfSteps * numberOfStaircases 
    : numberOfSteps;
  
  // Calculate total area for steps
  const totalStepsArea = areaPerStep * totalSteps;
  
  // Calculate landing area if applicable
  const landingArea = numberOfLandings > 0 && landingWidth > 0 && landingDepth > 0
    ? ((landingWidth * landingDepth) / 10000) * numberOfLandings * (quantityType === 'staircases' ? numberOfStaircases : 1)
    : 0;
  
  // Total area (steps + landings)
  const totalArea = totalStepsArea + landingArea;
  
  // Calculate total linear length (tread width × number of steps)
  const totalLinearLength = (treadWidthInCm / 100) * totalSteps; // Convert cm to meters
  
  return {
    areaPerStep, // متر مربع per step
    totalStepsArea, // Total area for all steps
    landingArea, // Total area for all landings
    totalArea, // Total area (steps + landings)
    totalLinearLength, // Total linear length in meters
    totalSteps // Total number of steps
  };
};

// Calculate nosing cutting cost
const calculateNosingCuttingCost = (data: {
  nosingType: string;
  treadWidth: number; // طول پله (cm or m)
  treadWidthUnit: 'cm' | 'm';
  numberOfSteps: number;
  numberOfStaircases?: number;
  quantityType?: 'steps' | 'staircases';
}) => {
  const {
    nosingType,
    treadWidth,
    treadWidthUnit,
    numberOfSteps,
    numberOfStaircases = 1,
    quantityType = 'steps'
  } = data;
  
  // Find nosing type
  const nosing = NOSING_TYPES.find(n => n.id === nosingType);
  if (!nosing || nosingType === 'none' || !nosing.cuttingCostPerMeter) {
    return { cuttingCost: 0, cuttingCostPerMeter: 0 };
  }
  
  // Convert tread width to meters
  const treadWidthInMeters = treadWidthUnit === 'm' ? treadWidth : treadWidth / 100;
  
  // Calculate total steps
  const totalSteps = quantityType === 'staircases' 
    ? numberOfSteps * numberOfStaircases 
    : numberOfSteps;
  
  // Calculate total length for nosing (tread width × number of steps)
  const totalLength = treadWidthInMeters * totalSteps;
  
  // Calculate cutting cost
  const cuttingCost = totalLength * nosing.cuttingCostPerMeter;
  
  return {
    cuttingCost,
    cuttingCostPerMeter: nosing.cuttingCostPerMeter
  };
};

// Calculate metrics for Tread (کف پله)
const calculateTreadMetrics = (data: {
  treadWidth: number; // طول پله
  treadWidthUnit: 'cm' | 'm';
  treadDepth: number; // عرض پله (cm)
  quantity: number; // تعداد پله
  quantityType: 'steps' | 'staircases';
  numberOfStaircases?: number;
}) => {
  const { treadWidth, treadWidthUnit, treadDepth, quantity, quantityType, numberOfStaircases = 1 } = data;
  
  // Convert tread width to cm
  const treadWidthInCm = treadWidthUnit === 'm' ? treadWidth * 100 : treadWidth;
  
  // Calculate area per step (tread width × tread depth) in m²
  const areaPerStep = (treadWidthInCm * treadDepth) / 10000;
  
  // Calculate total quantity
  const totalQuantity = quantityType === 'staircases' ? quantity * numberOfStaircases : quantity;
  
  // Calculate total area
  const totalArea = areaPerStep * totalQuantity;
  
  // Calculate total linear length in meters
  const totalLinearLength = (treadWidthInCm / 100) * totalQuantity;
  
  return {
    areaPerStep,
    totalArea,
    totalLinearLength,
    totalQuantity
  };
};

// Calculate metrics for Riser (خیز پله)
const calculateRiserMetrics = (data: {
  treadWidth: number; // طول پله (for calculating riser area)
  treadWidthUnit: 'cm' | 'm';
  riserHeight: number; // ارتفاع قائمه (cm)
  quantity: number; // تعداد قائمه
  quantityType: 'steps' | 'staircases';
  numberOfStaircases?: number;
}) => {
  const { treadWidth, treadWidthUnit, riserHeight, quantity, quantityType, numberOfStaircases = 1 } = data;
  
  // Convert tread width to cm
  const treadWidthInCm = treadWidthUnit === 'm' ? treadWidth * 100 : treadWidth;
  
  // Calculate area per riser (tread width × riser height) in m²
  const areaPerRiser = (treadWidthInCm * riserHeight) / 10000;
  
  // Calculate total quantity
  const totalQuantity = quantityType === 'staircases' ? quantity * numberOfStaircases : quantity;
  
  // Calculate total area
  const totalArea = areaPerRiser * totalQuantity;
  
  return {
    areaPerRiser,
    totalArea,
    totalQuantity
  };
};

// Calculate metrics for Landing (پاگرد)
const calculateLandingMetrics = (data: {
  landingWidth: number; // عرض پاگرد (cm)
  landingDepth: number; // عمق پاگرد (cm)
  numberOfLandings: number; // تعداد پاگرد
  quantityType: 'steps' | 'staircases';
  numberOfStaircases?: number;
}) => {
  const { landingWidth, landingDepth, numberOfLandings, quantityType, numberOfStaircases = 1 } = data;
  
  // Calculate area per landing in m²
  const areaPerLanding = (landingWidth * landingDepth) / 10000;
  
  // Calculate total quantity
  const totalQuantity = quantityType === 'staircases' 
    ? numberOfLandings * numberOfStaircases 
    : numberOfLandings;
  
  // Calculate total area
  const totalArea = areaPerLanding * totalQuantity;
  
  return {
    areaPerLanding,
    totalArea,
    totalQuantity
  };
};
export default function CreateContractWizard() {
  const router = useRouter();
  const [currentStep, setCurrentStep] = useState(1);
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [customerSearchTerm, setCustomerSearchTerm] = useState('');
  const [productSearchTerm, setProductSearchTerm] = useState('');
  
  // Flag to track if state restoration has been attempted
  const [stateRestored, setStateRestored] = useState(false);
  const restorationAttempted = useRef(false);
  
  // Product configuration modal state
  const [showProductModal, setShowProductModal] = useState(false);
  const [showCADDesigner, setShowCADDesigner] = useState(false); // CAD designer visibility (for product modal)
  const [showRemainingStoneCAD, setShowRemainingStoneCAD] = useState(false); // CAD designer visibility (for remaining stone modal)
  // Stair stepper v2 states
  const [useStairFlowV2, setUseStairFlowV2] = useState(true);
  // Delivery step state
  const [selectedProductIndices, setSelectedProductIndices] = useState<Set<number>>(new Set());
  const [selectAllProducts, setSelectAllProducts] = useState(false);
  type StairStepperPart = 'tread' | 'riser' | 'landing';
  const [stairActivePart, setStairActivePartState] = useState<StairStepperPart>('tread');
  type UnitType = 'cm' | 'm';
  interface ToolSelectionV2 {
    toolId: string;
    name: string;
    pricePerMeter: number;
    // edges for tread/riser
    front?: boolean;
    left?: boolean;
    right?: boolean;
    // landing-specific
    back?: boolean;
    perimeter?: boolean;
    computedMeters?: number;
    totalPrice?: number;
  }
  interface StairPartDraftV2 {
    stoneId?: string | null;
    stoneLabel?: string;
    stoneProduct?: Product | null; // Full product object for ContractProduct
    pricePerSquareMeter?: number | null;
    useMandatory?: boolean;
    mandatoryPercentage?: number | null;
    thicknessCm?: number | null;
    lengthValue?: number | null;
    lengthUnit?: UnitType; // cm or m
    widthCm?: number | null;
    quantity?: number | null;
    squareMeters?: number | null;
    tools?: ToolSelectionV2[];
    totalPrice?: number | null;
    // Layer fields (لایه‌ها)
    numberOfLayersPerStair?: number | null; // تعداد لایه برای هر پله (e.g., 2 for double)
    layerWidthCm?: number | null; // عرض لایه (cm) - width of the layer strip
  layerTypeId?: string | null;
  layerTypeName?: string | null;
  layerTypePrice?: number | null;
    // Layer edges - which sides of the stair need layers
    layerEdges?: {
      front?: boolean; // لایه برای لبه جلو
      left?: boolean; // لایه برای لبه چپ
      right?: boolean; // لایه برای لبه راست
      back?: boolean; // لایه برای لبه عقب (only for landing)
      perimeter?: boolean; // لایه برای محیط کامل (only for landing)
    };
  layerUseDifferentStone?: boolean;
  layerStoneProductId?: string | null;
  layerStoneProduct?: Product | null;
  layerStoneLabel?: string | null;
  layerPricePerSquareMeter?: number | null;
  layerUseMandatory?: boolean;
  layerMandatoryPercentage?: number | null;
    standardLengthValue?: number | null;
    standardLengthUnit?: UnitType;
    // Finishing fields
    finishingEnabled?: boolean;
    finishingId?: string | null;
    finishingLabel?: string | null;
    finishingPricePerSquareMeter?: number | null;
  }
  interface StairDraftFieldErrors {
    thickness?: string;
    length?: string;
    width?: string;
    pricePerSquareMeter?: string;
    quantity?: string;
  layerType?: string;
  layerStone?: string;
  layerStonePrice?: string;
  layerMandatoryPercentage?: string;
  mandatoryPercentage?: string;
  }
interface LayerTypeOption {
  id: string;
  name: string;
  description?: string;
  pricePerLayer: number;
  isActive?: boolean;
}
  const [draftTread, setDraftTread] = useState<StairPartDraftV2>({ lengthUnit: 'm', tools: [], finishingEnabled: false, useMandatory: false, mandatoryPercentage: null }); // Default to meters for length
  const [draftRiser, setDraftRiser] = useState<StairPartDraftV2>({ lengthUnit: 'm', tools: [], finishingEnabled: false, useMandatory: true, mandatoryPercentage: 20 }); // Default to meters for length
  const [draftLanding, setDraftLanding] = useState<StairPartDraftV2>({ lengthUnit: 'm', tools: [], finishingEnabled: false, useMandatory: true, mandatoryPercentage: 20 }); // Default to meters for length
  // Stepper v2: search & session states
  const [stoneSearchTerm, setStoneSearchTerm] = useState('');
const [stoneSearchResults, setStoneSearchResults] = useState<Product[]>([]);
  const [isSearchingStones, setIsSearchingStones] = useState(false);
  
  // Digital Signature (Step 8) state
  const [sendingCode, setSendingCode] = useState(false);
  const [verifyingCode, setVerifyingCode] = useState(false);
  const [countdown, setCountdown] = useState<number | null>(null);
  const [resendCooldown, setResendCooldown] = useState(0);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [sandboxVerificationCode, setSandboxVerificationCode] = useState<string | null>(null);
  const countdownIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const resendCooldownIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const [toolsSearchTerm, setToolsSearchTerm] = useState('');
  const [toolsResults, setToolsResults] = useState<any[]>([]);
  const [isSearchingTools, setIsSearchingTools] = useState(false);
  const [toolsDropdownOpen, setToolsDropdownOpen] = useState(false);
const [layerStoneSearchTerm, setLayerStoneSearchTerm] = useState('');
const [layerStoneSearchResults, setLayerStoneSearchResults] = useState<Product[]>([]);
const [isSearchingLayerStones, setIsSearchingLayerStones] = useState(false);
const [layerStoneDropdownOpen, setLayerStoneDropdownOpen] = useState(false);
  const [stairSessionId, setStairSessionId] = useState<string | null>(null);
  const [stairSessionItems, setStairSessionItems] = useState<ContractProduct[]>([]);
  const [lastSelectedStoneLabel, setLastSelectedStoneLabel] = useState('');
  const [lastSelectedStoneProduct, setLastSelectedStoneProduct] = useState<Product | null>(null);
  const [autoFillOptOut, setAutoFillOptOut] = useState<Record<StairStepperPart, boolean>>({
    tread: false,
    riser: false,
    landing: false
  });
  const [stairDraftErrors, setStairDraftErrors] = useState<Record<StairStepperPart, StairDraftFieldErrors>>({
    tread: {},
    riser: {},
    landing: {}
  });
  const [layerTypes, setLayerTypes] = useState<LayerTypeOption[]>([]);
  const [isLoadingLayerTypes, setIsLoadingLayerTypes] = useState(false);
  const [layerTypesError, setLayerTypesError] = useState<string | null>(null);

  const getDraftByPart = useCallback((part: StairStepperPart): StairPartDraftV2 | null => {
    switch (part) {
      case 'tread':
        return draftTread;
      case 'riser':
        return draftRiser;
      case 'landing':
        return draftLanding;
      default:
        return null;
    }
  }, [draftTread, draftRiser, draftLanding]);

  const syncLayerSessionItems = useCallback((items: ContractProduct[]): ContractProduct[] => {
    if (!items.some(item => (item.meta as any)?.isLayer)) {
      return items;
    }

    let changed = false;
    const updated = items.map(item => {
      const isLayer = ((item.meta as any)?.isLayer) || false;
      if (!isLayer) {
        return item;
      }

      const layerInfo = (item.meta as any)?.layerInfo;
      const layerEdges = (item.meta as any)?.layerEdges;
      const parentPartType: StairStepperPart | undefined = layerInfo?.parentPartType;
      if (!layerInfo || !layerEdges || !parentPartType) {
        return item;
      }

      const parentDraft = getDraftByPart(parentPartType);
      if (!parentDraft || !parentDraft.quantity) {
        return item;
      }

      const numberOfLayersPerStair = layerInfo.numberOfLayersPerStair || 0;
      if (numberOfLayersPerStair <= 0) {
        return item;
      }

      const tempDraft: StairPartDraftV2 = {
        ...parentDraft,
        layerEdges,
        layerWidthCm: item.width,
        numberOfLayersPerStair,
        quantity: parentDraft.quantity
      };

      const newLayerSqm = computeLayerSqmV2(parentPartType, tempDraft);
      const totalLayers = (parentDraft.quantity || 0) * numberOfLayersPerStair;
      const layerTypeUnitPrice = item.layerTypePrice || 0;
      
      // 🎯 FIX: Calculate layer type cost based on total length per stair × number of stairs × layer type price per meter
      const totalLayerLengthPerStairM = getTotalLayerLengthPerStairM(parentPartType, tempDraft);
      const totalLayerLengthM = totalLayerLengthPerStairM * (parentDraft.quantity || 0);
      const layerTypeCost = totalLayerLengthM * layerTypeUnitPrice;
      
      // 🎯 FIX: Calculate stone area used for pricing (not layer square meters)
      // Get stone dimensions from item
      const stoneWidthCm = item.originalWidth || 0;
      const stoneWidthM = stoneWidthCm / 100;
      const stoneLengthM = getActualLengthMeters(parentDraft);
      const layerWidthCm = item.width || 0;
      
      // Calculate stone area used
      let stoneAreaUsedSqm = 0;
      if (stoneWidthCm > 0 && layerWidthCm > 0 && stoneLengthM > 0) {
        // Calculate how many layers can fit in one stone width
        const layersPerStoneWidth = Math.floor(stoneWidthCm / layerWidthCm);
        if (layersPerStoneWidth > 0) {
          // Calculate how many stones are needed
          const stonesNeeded = Math.ceil(totalLayers / layersPerStoneWidth);
          // Total stone area used
          stoneAreaUsedSqm = stonesNeeded * stoneLengthM * stoneWidthM;
        }
      }
      
      // Use stone area used for pricing, fallback to layer square meters if calculation fails
      const pricingAreaSqm = stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : newLayerSqm;
      const materialCost = pricingAreaSqm * (item.pricePerSquareMeter || 0);
      const newTotalPrice = materialCost + layerTypeCost + (item.cuttingCost || 0);
      const newLengthMeters = getActualLengthMeters(parentDraft);
      const newLengthUnit = parentDraft.lengthUnit || 'm';
      const newLengthValue = convertMetersToUnit(newLengthMeters, newLengthUnit);

      const currentSqm = item.squareMeters || 0;
      const currentTotal = typeof item.totalPrice === 'number' ? item.totalPrice : parseFloat(String(item.totalPrice || 0));

      if (Math.abs(newLayerSqm - currentSqm) < 0.0001 &&
          Math.abs(newTotalPrice - (currentTotal || 0)) < 0.5 &&
          Math.abs((item.length || 0) - newLengthValue) < 0.0001) {
        return item;
      }

      changed = true;
      return {
        ...item,
        squareMeters: newLayerSqm,
        totalPrice: newTotalPrice,
        originalTotalPrice: materialCost, // Use material cost based on stone area used
        quantity: totalLayers,
        length: newLengthValue,
        lengthUnit: newLengthUnit,
        meta: {
          ...item.meta,
          layerInfo: {
            ...layerInfo,
            lastSyncedAt: Date.now()
          },
          // Update stone area used in meta if calculated
          stoneAreaUsedSqm: stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : undefined
        } as any
      };
    });

    return changed ? updated : items;
  }, [getDraftByPart]);

  useEffect(() => {
    setStairSessionItems(prev => syncLayerSessionItems(prev));
  }, [syncLayerSessionItems]);

  const hasLayerEdgeSelection = (edges?: StairPartDraftV2['layerEdges']) =>
    !!(edges && (edges.front || edges.left || edges.right || edges.back || edges.perimeter));

  const deriveLayerEdgesFromTools = (
    draft: StairPartDraftV2,
    part: StairStepperPart
  ): StairPartDraftV2 => {
    if (!draft.tools || draft.tools.length === 0) return draft;

    const aggregated = draft.tools.reduce(
      (acc, tool) => ({
        front: acc.front || !!tool.front,
        left: acc.left || !!tool.left,
        right: acc.right || !!tool.right,
        back: acc.back || !!tool.back,
        perimeter: acc.perimeter || !!tool.perimeter
      }),
      { front: false, left: false, right: false, back: false, perimeter: false }
    );

    if (part !== 'landing') {
      aggregated.back = false;
      aggregated.perimeter = false;
    }

    const hasEdges =
      aggregated.front || aggregated.left || aggregated.right || aggregated.back || aggregated.perimeter;

    if (!hasEdges) return draft;

    const layerEdges = aggregated.perimeter
      ? { front: false, left: false, right: false, back: false, perimeter: true }
      : {
          front: aggregated.front,
          left: aggregated.left,
          right: aggregated.right,
          back: part === 'landing' ? aggregated.back : false,
          perimeter: false
        };

    return { ...draft, layerEdges };
  };

  useEffect(() => {
    const fetchLayerTypes = async () => {
      try {
        setIsLoadingLayerTypes(true);
        const response = await servicesAPI.getLayerTypes({ isActive: true });
        if (response?.data?.success) {
          const options: LayerTypeOption[] = (response.data.data || [])
            .map((item: any): LayerTypeOption => ({
              id: item.id,
              name: item.name,
              description: item.description,
              pricePerLayer: Number(item.pricePerLayer) || 0,
              isActive: item.isActive !== false
            }))
            .filter((option: LayerTypeOption) => option.isActive !== false);
          setLayerTypes(options);
          setLayerTypesError(null);
        }
      } catch (error) {
        console.error('Error loading layer types:', error);
        setLayerTypesError('خطا در بارگذاری نوع لایه');
      } finally {
        setIsLoadingLayerTypes(false);
      }
    };

    fetchLayerTypes();
  }, []);

  // Ensure stair drafts always use original product thickness (قطر)
  useEffect(() => {
    const productThickness = draftTread.stoneProduct?.thicknessValue ?? null;
    const currentThickness = draftTread.thicknessCm ?? null;
    if (productThickness !== currentThickness) {
      setDraftTread(prev => ({ ...prev, thicknessCm: productThickness }));
    }
  }, [draftTread.stoneProduct?.id, draftTread.stoneProduct?.thicknessValue, draftTread.thicknessCm]);

  useEffect(() => {
    const productThickness = draftRiser.stoneProduct?.thicknessValue ?? null;
    const currentThickness = draftRiser.thicknessCm ?? null;
    if (productThickness !== currentThickness) {
      setDraftRiser(prev => ({ ...prev, thicknessCm: productThickness }));
    }
  }, [draftRiser.stoneProduct?.id, draftRiser.stoneProduct?.thicknessValue, draftRiser.thicknessCm]);

  useEffect(() => {
    const productThickness = draftLanding.stoneProduct?.thicknessValue ?? null;
    const currentThickness = draftLanding.thicknessCm ?? null;
    if (productThickness !== currentThickness) {
      setDraftLanding(prev => ({ ...prev, thicknessCm: productThickness }));
    }
  }, [draftLanding.stoneProduct?.id, draftLanding.stoneProduct?.thicknessValue, draftLanding.thicknessCm]);

  const ensureStairSessionId = () => {
    if (stairSessionId) return stairSessionId;
    const id = `stair_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    setStairSessionId(id);
    return id;
  };

  const getActiveDraft = (): [StairPartDraftV2, (d: StairPartDraftV2) => void] => {
    if (stairActivePart === 'tread') return [draftTread, setDraftTread];
    if (stairActivePart === 'riser') return [draftRiser, setDraftRiser];
    return [draftLanding, setDraftLanding];
  };

  const getPartDisplayLabel = (part: StairStepperPart): string => {
    if (part === 'tread') return 'کف پله';
    if (part === 'riser') return 'خیز پله';
    return 'پاگرد';
  };

  const getProductCuttingCost = (product: ContractProduct): number => {
    if (product.cuttingBreakdown && product.cuttingBreakdown.length > 0) {
      return product.cuttingBreakdown.reduce((sum, entry) => sum + (entry.cost || 0), 0);
    }
    return product.isCut ? product.cuttingCost || 0 : 0;
  };

  const getProductServiceCost = (product: ContractProduct): number => {
    const toolCost = product.totalSubServiceCost || 0;
    const cuttingCost = getProductCuttingCost(product);
    return toolCost + cuttingCost;
  };

  // 🎯 Comprehensive validation function for numeric inputs based on product data
  const validateDraftNumericFields = (part: StairStepperPart, draft: StairPartDraftV2, field: keyof StairDraftFieldErrors, value: number | null): string | null => {
    const partLabel = getPartDisplayLabel(part);
    const product = draft.stoneProduct;
    
    if (!product) {
      return null; // Product selection validation is handled separately
    }

    const originalWidthCm = product.widthValue || 0;
    const originalThicknessCm = product.thicknessValue || 0;

    switch (field) {
      case 'length': {
        const hasStandardLength = getDraftStandardLengthMeters(draft) > 0;
        if (value === null || value === undefined || value <= 0) {
          if (!hasStandardLength) {
            return `لطفاً طول را برای ${partLabel} وارد کنید`;
          }
          return null;
        }
        if (value > 1000) { // Reasonable max: 10 meters or 1000 cm
          const unit = draft.lengthUnit || 'm';
          const maxValue = unit === 'm' ? 10 : 1000;
          return `طول نمی‌تواند بیشتر از ${maxValue} ${unit === 'm' ? 'متر' : 'سانتی‌متر'} باشد`;
        }
        return null;
      }

      case 'width':
        if (value === null || value === undefined) {
          return `لطفاً عرض را برای ${partLabel} وارد کنید`;
        }
        if (value <= 0) {
          return `عرض باید بیشتر از صفر باشد`;
        }
        if (originalWidthCm > 0 && value > originalWidthCm) {
          return `عرض وارد شده (${formatDisplayNumber(value)}cm) نمی‌تواند بیشتر از عرض اصلی سنگ (${formatDisplayNumber(originalWidthCm)}cm) باشد`;
        }
        if (value < 1) {
          return `عرض باید حداقل 1 سانتی‌متر باشد`;
        }
        return null;

      case 'quantity':
        if (value === null || value === undefined) {
          return `لطفاً تعداد را برای ${partLabel} وارد کنید`;
        }
        if (value <= 0) {
          return `تعداد باید بیشتر از صفر باشد`;
        }
        if (!Number.isInteger(value)) {
          return `تعداد باید یک عدد صحیح باشد`;
        }
        if (value > 10000) {
          return `تعداد نمی‌تواند بیشتر از 10,000 عدد باشد`;
        }
        return null;

      case 'pricePerSquareMeter':
        if (value === null || value === undefined) {
          return `لطفاً قیمت هر متر مربع را برای ${partLabel} وارد کنید`;
        }
        if (value <= 0) {
          return `قیمت هر متر مربع باید بیشتر از صفر باشد`;
        }
        if (value > 100000000) { // Reasonable max: 100 million Toman per sqm
          return `قیمت هر متر مربع نمی‌تواند بیشتر از 100,000,000 تومان باشد`;
        }
        return null;

      case 'layerStonePrice':
        if (value === null || value === undefined) {
          return 'لطفاً قیمت هر متر مربع لایه را وارد کنید';
        }
        if (value <= 0) {
          return 'قیمت هر متر مربع لایه باید بیشتر از صفر باشد';
        }
        if (value > 100000000) {
          return 'قیمت هر متر مربع لایه نمی‌تواند بیشتر از 100,000,000 تومان باشد';
        }
        return null;

      case 'layerMandatoryPercentage':
        if (value === null || value === undefined) {
          return 'لطفاً درصد حکمی لایه را وارد کنید';
        }
        if (value < 0) {
          return 'درصد حکمی نمی‌تواند کمتر از 0 باشد';
        }
        if (value > 100) {
          return 'درصد حکمی نمی‌تواند بیشتر از 100 باشد';
        }
        return null;

      case 'mandatoryPercentage':
        if (value === null || value === undefined) {
          return `لطفاً درصد حکمی ${partLabel} را وارد کنید`;
        }
        if (value < 0) {
          return 'درصد حکمی نمی‌تواند کمتر از 0 باشد';
        }
        if (value > 100) {
          return 'درصد حکمی نمی‌تواند بیشتر از 100 باشد';
        }
        return null;

      case 'thickness':
        // Thickness is auto-set from product, but validate it matches
        if (originalThicknessCm > 0) {
          const currentThickness = draft.thicknessCm ?? 0;
          if (Math.abs(currentThickness - originalThicknessCm) > 0.01) {
            return `قطر باید با قطر محصول انتخاب شده (${formatDisplayNumber(originalThicknessCm)}cm) مطابقت داشته باشد`;
          }
        }
        return null;

      default:
        return null;
    }
  };

  const validateDraftRequiredFields = (part: StairStepperPart, draft: StairPartDraftV2): StairDraftFieldErrors => {
    const partLabel = getPartDisplayLabel(part);
    const errors: StairDraftFieldErrors = {};

    if (!draft.stoneId || !draft.stoneProduct) {
      errors.thickness = `لطفاً ابتدا محصول ${partLabel} را انتخاب کنید`;
      return errors; // Can't validate other fields without product
    }

    // Validate each field using the comprehensive validation function
    const lengthError = validateDraftNumericFields(part, draft, 'length', draft.lengthValue ?? null);
    if (lengthError) errors.length = lengthError;

    const widthError = validateDraftNumericFields(part, draft, 'width', draft.widthCm ?? null);
    if (widthError) errors.width = widthError;

    const quantityError = validateDraftNumericFields(part, draft, 'quantity', draft.quantity ?? null);
    if (quantityError) errors.quantity = quantityError;

    const priceError = validateDraftNumericFields(part, draft, 'pricePerSquareMeter', draft.pricePerSquareMeter ?? null);
    if (priceError) errors.pricePerSquareMeter = priceError;

    const thicknessError = validateDraftNumericFields(part, draft, 'thickness', draft.thicknessCm ?? null);
    if (thicknessError) errors.thickness = thicknessError;

    const mandatoryDefault = part === 'riser' || part === 'landing';
    const shouldValidateMandatory = draft.useMandatory ?? mandatoryDefault;
    if (shouldValidateMandatory) {
      const mandatoryError = validateDraftNumericFields(part, draft, 'mandatoryPercentage', draft.mandatoryPercentage ?? 20);
      if (mandatoryError) {
        errors.mandatoryPercentage = mandatoryError;
      }
    }

    if (draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && layerTypes.length > 0 && !draft.layerTypeId) {
      errors.layerType = 'لطفاً نوع لایه را انتخاب کنید';
    }

    if (draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && draft.layerUseDifferentStone) {
      if (!draft.layerStoneProduct || !draft.layerStoneProductId) {
        errors.layerStone = 'لطفاً سنگ مورد استفاده برای لایه‌ها را انتخاب کنید';
      }
      const layerPriceError = validateDraftNumericFields(part, draft, 'layerStonePrice', draft.layerPricePerSquareMeter ?? null);
      if (layerPriceError) {
        errors.layerStonePrice = layerPriceError;
      }
      if (draft.layerUseMandatory !== false) {
        const mandatoryError = validateDraftNumericFields(part, draft, 'layerMandatoryPercentage', draft.layerMandatoryPercentage ?? null);
        if (mandatoryError) {
          errors.layerMandatoryPercentage = mandatoryError;
        }
      }
    }

    return errors;
  };

  const clearDraftFieldError = (part: StairStepperPart, field: keyof StairDraftFieldErrors) => {
    setStairDraftErrors(prev => ({
      ...prev,
      [part]: {
        ...prev[part],
        [field]: undefined
      }
    }));
    setErrors(prev => {
      if (!prev.products) return prev;
      const { products, ...rest } = prev;
      return rest;
    });
  };

  const calculateStairStoneUsage = (draft: StairPartDraftV2) => {
    const originalWidthCm = draft.stoneProduct?.widthValue || 0;
    const userWidthCm = draft.widthCm || 0;
    const quantity = draft.quantity || 0;

    let piecesPerStone = 1;
    let leftoverWidthCm = 0;

    if (originalWidthCm > 0 && userWidthCm > 0) {
      piecesPerStone = Math.max(1, Math.floor(originalWidthCm / userWidthCm));
      leftoverWidthCm = Math.max(0, originalWidthCm - piecesPerStone * userWidthCm);
    }

    const baseStoneQuantity = piecesPerStone > 0 ? Math.ceil(quantity / piecesPerStone) : quantity;

    return {
      originalWidthCm,
      userWidthCm,
      quantity,
      piecesPerStone,
      leftoverWidthCm,
      baseStoneQuantity
    };
  };

  const toMeters = (value: number | null | undefined, unit: UnitType): number => {
    if (!value || value <= 0) return 0;
    return unit === 'm' ? value : value / 100;
  };

  const convertMetersToUnit = (value: number, unit: UnitType): number => {
    if (!value || value <= 0) return 0;
    return unit === 'm' ? value : value * 100;
  };

  const getDraftStandardLengthMeters = (draft: StairPartDraftV2): number => {
    const value = draft.standardLengthValue;
    if (value && value > 0) {
      const unit = draft.standardLengthUnit || draft.lengthUnit || 'm';
      return toMeters(value, unit);
    }
    return 0;
  };

  const getActualLengthMeters = (draft: StairPartDraftV2): number => {
    const manualLength = toMeters(draft.lengthValue || 0, draft.lengthUnit || 'cm');
    if (manualLength > 0) {
      return manualLength;
    }
    const standardLength = getDraftStandardLengthMeters(draft);
    return standardLength > 0 ? standardLength : 0;
  };

  const getPricingLengthMeters = (draft: StairPartDraftV2): number => {
    const standardLength = getDraftStandardLengthMeters(draft);
    const actualLength = getActualLengthMeters(draft);
    if (standardLength > 0) {
      if (actualLength > 0 && Math.abs(standardLength - actualLength) < 0.000001) {
        return actualLength;
      }
      return standardLength;
    }
    return actualLength;
  };

  const hasLengthMeasurement = (draft: StairPartDraftV2): boolean => {
    if (draft.lengthValue && draft.lengthValue > 0) return true;
    return getDraftStandardLengthMeters(draft) > 0;
  };

  const computeSqmV2 = (draft: StairPartDraftV2): number => {
    const lengthM = getActualLengthMeters(draft);
    const widthM = (draft.widthCm || 0) / 100;
    const qty = draft.quantity || 0;
    const sqm = lengthM * widthM * qty;
    return Number.isFinite(sqm) ? sqm : 0;
  };

const getLayerStoneProductForDraft = (draft: StairPartDraftV2, fallback: Product | null): Product | null => {
  if (draft.layerUseDifferentStone && draft.layerStoneProduct) {
    return draft.layerStoneProduct;
  }
  return fallback;
};

const getLayerBasePricePerSquareMeter = (draft: StairPartDraftV2): number => {
  if (draft.layerUseDifferentStone) {
    return draft.layerPricePerSquareMeter || 0;
  }
  return draft.pricePerSquareMeter || 0;
};

const getLayerEffectivePricePerSquareMeter = (draft: StairPartDraftV2): number => {
  const base = getLayerBasePricePerSquareMeter(draft);
  if (draft.layerUseDifferentStone && draft.layerUseMandatory && draft.layerMandatoryPercentage && draft.layerMandatoryPercentage > 0) {
    return base * (1 + draft.layerMandatoryPercentage / 100);
  }
  return base;
};

const normalizeLayerAltStoneSettings = (draft: StairPartDraftV2): StairPartDraftV2 => {
  if (!draft.layerUseDifferentStone) {
    return {
      ...draft,
      layerPricePerSquareMeter: draft.pricePerSquareMeter ?? draft.layerPricePerSquareMeter ?? null,
      layerUseMandatory: undefined,
      layerMandatoryPercentage: null
    };
  }
  const normalized = { ...draft };
  if (!normalized.layerPricePerSquareMeter || normalized.layerPricePerSquareMeter <= 0) {
    normalized.layerPricePerSquareMeter = draft.layerPricePerSquareMeter || draft.pricePerSquareMeter || 0;
  }
  normalized.layerUseMandatory = normalized.layerUseMandatory ?? true;
  normalized.layerMandatoryPercentage = normalized.layerMandatoryPercentage ?? 20;
  return normalized;
};

  const computeToolMetersForTool = (part: StairStepperPart, draft: StairPartDraftV2, tool: ToolSelectionV2): number => {
    const lengthM = getActualLengthMeters(draft);
    const widthM = (draft.widthCm || 0) / 100;
    const qty = draft.quantity || 0;
    let meters = 0;
    const t = tool;
    if (part === 'landing') {
      if (t.perimeter) meters += 2 * (lengthM + widthM);
      else {
        if (t.front) meters += widthM;
        if (t.back) meters += widthM;
        if (t.left) meters += lengthM;
        if (t.right) meters += lengthM;
      }
    } else {
      if (t.front) meters += widthM;
      if (t.left) meters += lengthM;
      if (t.right) meters += lengthM;
    }
    return meters * qty;
  };

  const computeToolsMetersV2 = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.tools || draft.tools.length === 0) return 0;
    return draft.tools.reduce((sum, tool) => sum + computeToolMetersForTool(part, draft, tool), 0);
  };

  // 🎯 Calculate total layer length per stair (sum of all selected edge lengths)
  // This is used for layer type cost calculation: total length per stair × number of stairs × layer type price per meter
  // Example: front (0.26m) + left (1.22m) = 1.48m per stair
  const getTotalLayerLengthPerStairM = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.layerEdges || !draft.layerWidthCm) {
      return 0;
    }
    
    const stairLengthM = getActualLengthMeters(draft);
    const stairWidthM = (draft.widthCm || 0) / 100;
    const layerWidthCm = draft.layerWidthCm || 0;
    const layerWidthM = layerWidthCm / 100;
    const edges = draft.layerEdges;
    
    let totalLengthM = 0;
    
    if (part === 'landing') {
      if (edges.perimeter) {
        // Perimeter: 2 × (length + width)
        totalLengthM = 2 * (stairLengthM + stairWidthM);
      } else {
        // 🎯 Account for overlap when multiple edges are selected
        const hasFrontOrBack = edges.front || edges.back;
        const hasLeftOrRight = edges.left || edges.right;
        
        // Front/back layers: if left/right is also selected, reduce length by layerWidth
        const frontBackLengthM = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
        if (edges.front) totalLengthM += frontBackLengthM;
        if (edges.back) totalLengthM += frontBackLengthM;
        
        // Left/right layers: if front/back is also selected, reduce length by layerWidth
        const leftRightLengthM = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;
        if (edges.left) totalLengthM += leftRightLengthM;
        if (edges.right) totalLengthM += leftRightLengthM;
      }
    } else {
      if (edges.front) {
        totalLengthM += stairLengthM;
      }

      const sideLengthM = edges.front ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
      if (edges.left) totalLengthM += sideLengthM;
      if (edges.right) totalLengthM += sideLengthM;
    }
    
    return totalLengthM;
  };

  // 🎯 Calculate maximum layer length needed based on selected edges
  // This is used for stone usage calculation to ensure we have enough stone for all layer types
  // Returns the maximum length among all selected edge types
  const getMaxLayerLengthM = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.layerEdges || !draft.layerWidthCm) {
      return 0;
    }
    
    const stairLengthM = getActualLengthMeters(draft);
    const stairWidthM = (draft.widthCm || 0) / 100;
    const layerWidthCm = draft.layerWidthCm || 0;
    const layerWidthM = layerWidthCm / 100;
    const edges = draft.layerEdges;
    
    let maxLengthM = 0;
    
    if (part === 'landing') {
      if (edges.perimeter) {
        // Perimeter uses both length and width, so max is the longer dimension
        maxLengthM = Math.max(stairLengthM, stairWidthM);
      } else {
        // Check front/back layers
        if (edges.front || edges.back) {
          const hasLeftOrRight = edges.left || edges.right;
          const frontBackLengthM = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
          maxLengthM = Math.max(maxLengthM, frontBackLengthM);
        }
        // Check left/right layers
        if (edges.left || edges.right) {
          const hasFrontOrBack = edges.front || edges.back;
          const leftRightLengthM = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;
          maxLengthM = Math.max(maxLengthM, leftRightLengthM);
        }
      }
    } else {
      if (edges.front) {
        maxLengthM = Math.max(maxLengthM, stairLengthM);
      }
      
      if (edges.left || edges.right) {
        const sideLengthM = edges.front ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
        maxLengthM = Math.max(maxLengthM, sideLengthM);
      }
    }
    
    return maxLengthM;
  };

  // 🎯 Calculate layer square meters based on selected edges
  // 🎯 FIX: Account for overlap when multiple edges are selected
  // When front and left/right are both selected, front layer length should be reduced by layerWidth
  // Example: stairWidth = 0.31m, layerWidth = 0.05m, stairLength = 1.22m
  // - Front layer: (0.31 - 0.05) × 0.05 = 0.26 × 0.05 (reduced because left layer overlaps)
  // - Left layer: 1.22 × 0.05 (full length)
  const computeLayerSqmV2 = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.layerEdges || !draft.layerWidthCm || !draft.numberOfLayersPerStair || !draft.quantity) {
      return 0;
    }
    
    const stairLengthM = getActualLengthMeters(draft);
    const stairWidthM = (draft.widthCm || 0) / 100;
    const layerWidthCm = draft.layerWidthCm || 0;
    const layerWidthM = layerWidthCm / 100;
    const edges = draft.layerEdges;
    
    // Calculate square meters for each selected edge
    let layerSqmPerStair = 0;
    
    if (part === 'landing') {
      if (edges.perimeter) {
        // Perimeter: 2 × (length + width) × layerWidth
        layerSqmPerStair = 2 * (stairLengthM + stairWidthM) * layerWidthM;
      } else {
        // 🎯 FIX: Account for overlap when front/back and left/right are both selected
        const hasFrontOrBack = edges.front || edges.back;
        const hasLeftOrRight = edges.left || edges.right;
        
        // Front/back layers: if left/right is also selected, reduce length by layerWidth
        const frontBackLengthM = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
        if (edges.front) layerSqmPerStair += frontBackLengthM * layerWidthM;
        if (edges.back) layerSqmPerStair += frontBackLengthM * layerWidthM;
        
        // Left/right layers: if front/back is also selected, reduce length by layerWidth
        const leftRightLengthM = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;
        if (edges.left) layerSqmPerStair += leftRightLengthM * layerWidthM;
        if (edges.right) layerSqmPerStair += leftRightLengthM * layerWidthM;
      }
    } else {
      if (edges.front) {
        layerSqmPerStair += stairLengthM * layerWidthM;
      }

      const sideLengthM = edges.front ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
      if (edges.left) layerSqmPerStair += sideLengthM * layerWidthM;
      if (edges.right) layerSqmPerStair += sideLengthM * layerWidthM;
    }
    
    // Total square meters = per stair × numberOfLayersPerStair × quantity
    return layerSqmPerStair * draft.numberOfLayersPerStair * draft.quantity;
  };

type LayerEdgeDemand = {
  edge: 'front' | 'back' | 'left' | 'right' | 'perimeter';
  layersNeeded: number;
  lengthM: number;
};

const getLayerEdgeDemands = (part: StairStepperPart, draft: StairPartDraftV2): LayerEdgeDemand[] => {
  if (!draft.layerEdges || !draft.numberOfLayersPerStair || !draft.quantity || !draft.layerWidthCm) {
    return [];
  }

  const stairLengthM = getActualLengthMeters(draft);
  const stairWidthM = (draft.widthCm || 0) / 100;
  const layerWidthM = (draft.layerWidthCm || 0) / 100;
  if (stairLengthM <= 0 || stairWidthM <= 0 || layerWidthM <= 0) {
    return [];
  }

  const edges = draft.layerEdges;
  const baseLayersPerEdge = draft.quantity * draft.numberOfLayersPerStair;
  const demands: LayerEdgeDemand[] = [];

  if (part === 'landing') {
    if (edges.perimeter) {
      const perimeterLength = 2 * (stairLengthM + stairWidthM);
      if (perimeterLength > 0) {
        demands.push({
          edge: 'perimeter',
          layersNeeded: baseLayersPerEdge,
          lengthM: perimeterLength
        });
      }
      return demands;
    }

    const hasFrontOrBack = edges.front || edges.back;
    const hasLeftOrRight = edges.left || edges.right;
    const frontBackLength = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
    const leftRightLength = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;

    if (edges.front && frontBackLength > 0) {
      demands.push({ edge: 'front', layersNeeded: baseLayersPerEdge, lengthM: frontBackLength });
    }
    if (edges.back && frontBackLength > 0) {
      demands.push({ edge: 'back', layersNeeded: baseLayersPerEdge, lengthM: frontBackLength });
    }
    if (edges.left && leftRightLength > 0) {
      demands.push({ edge: 'left', layersNeeded: baseLayersPerEdge, lengthM: leftRightLength });
    }
    if (edges.right && leftRightLength > 0) {
      demands.push({ edge: 'right', layersNeeded: baseLayersPerEdge, lengthM: leftRightLength });
    }
    return demands;
  }

  if (edges.front && stairLengthM > 0) {
    demands.push({ edge: 'front', layersNeeded: baseLayersPerEdge, lengthM: stairLengthM });
  }
    const hasFront = edges.front;
    const sideLength = hasFront ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
    if (edges.left && sideLength > 0) {
      demands.push({ edge: 'left', layersNeeded: baseLayersPerEdge, lengthM: sideLength });
    }
    if (edges.right && sideLength > 0) {
      demands.push({ edge: 'right', layersNeeded: baseLayersPerEdge, lengthM: sideLength });
    }

  return demands;
  };

  // ============================================================================
  // 🎯 LAYER PRODUCT HELPER FUNCTIONS - Refactored for clarity and reliability
  // ============================================================================
  
  /**
   * Find an existing layer product with the same configuration
   * Same configuration = same parent part, same edges, same dimensions, same layers per stair
   */
  const findExistingLayerProduct = (
    sessionItems: ContractProduct[],
    draft: StairPartDraftV2,
    parentPartType: StairStepperPart
  ): ContractProduct | null => {
    if (!draft.layerEdges || !draft.layerWidthCm || !draft.numberOfLayersPerStair) {
      return null;
    }
    
    return sessionItems.find(item => {
      const itemIsLayer = ((item.meta as any)?.isLayer) || false;
      if (!itemIsLayer) return false;
      
      const itemLayerInfo = (item.meta as any)?.layerInfo;
      const itemLayerEdges = (item.meta as any)?.layerEdges;
      
      // Check if same parent part
      if (itemLayerInfo?.parentPartType !== parentPartType) return false;
      
      // Check if same edges configuration (exact match)
      const edgesMatch = 
        (itemLayerEdges?.front || false) === (draft.layerEdges?.front || false) &&
        (itemLayerEdges?.left || false) === (draft.layerEdges?.left || false) &&
        (itemLayerEdges?.right || false) === (draft.layerEdges?.right || false) &&
        (itemLayerEdges?.back || false) === (draft.layerEdges?.back || false) &&
        (itemLayerEdges?.perimeter || false) === (draft.layerEdges?.perimeter || false);
      
      if (!edgesMatch) return false;

      const itemLayerTypeId = ((item.meta as any)?.layerType)?.id || item.layerTypeId || null;
      const draftLayerTypeId = draft.layerTypeId || null;
      if ((itemLayerTypeId || null) !== (draftLayerTypeId || null)) return false;

      const itemAltStoneMeta = (item.meta as any)?.layerAltStone;
      const itemAltStoneId = item.layerUseDifferentStone ? (item.layerStoneProductId || itemAltStoneMeta?.id || item.productId) : null;
      const draftAltStoneId = draft.layerUseDifferentStone
        ? (draft.layerStoneProductId || draft.layerStoneProduct?.id || null)
        : null;
      if (!!item.layerUseDifferentStone !== !!draft.layerUseDifferentStone) return false;
      if (item.layerUseDifferentStone && itemAltStoneId !== draftAltStoneId) return false;
      const itemLayerBasePrice = item.layerUseDifferentStone
        ? (item.layerStoneBasePricePerSquareMeter || item.layerStonePricePerSquareMeter || 0)
        : (item.pricePerSquareMeter || 0);
      const draftLayerBasePrice = draft.layerUseDifferentStone
        ? (draft.layerPricePerSquareMeter || 0)
        : (draft.pricePerSquareMeter || 0);
      if (Math.abs(itemLayerBasePrice - draftLayerBasePrice) > 0.0001) return false;
      const itemMandatoryFlag = item.layerUseDifferentStone ? (item.layerUseMandatory ?? true) : false;
      const draftMandatoryFlag = draft.layerUseDifferentStone ? (draft.layerUseMandatory ?? true) : false;
      if (itemMandatoryFlag !== draftMandatoryFlag) return false;
      if (itemMandatoryFlag && draftMandatoryFlag) {
        const itemMandatoryPercent = item.layerMandatoryPercentage ?? 0;
        const draftMandatoryPercent = draft.layerMandatoryPercentage ?? 0;
        if (Math.abs(itemMandatoryPercent - draftMandatoryPercent) > 0.0001) return false;
      }
      
      // Check if same dimensions (with tolerance for floating point)
      const widthTolerance = 0.01; // 0.01cm tolerance
      if (Math.abs(item.width - (draft.layerWidthCm || 0)) > widthTolerance) return false;
      
      // Check length (convert to same unit for comparison)
      const itemLengthInDraftUnit = item.lengthUnit === draft.lengthUnit 
        ? item.length 
        : (item.lengthUnit === 'm' ? item.length * 100 : item.length / 100);
      const lengthTolerance = draft.lengthUnit === 'm' ? 0.001 : 0.1; // 0.001m or 0.1cm
      const draftLengthForComparison = convertMetersToUnit(getActualLengthMeters(draft), draft.lengthUnit || 'm');
      if (Math.abs(itemLengthInDraftUnit - draftLengthForComparison) > lengthTolerance) return false;
      
      // Check if same number of layers per stair
      if (itemLayerInfo?.numberOfLayersPerStair !== draft.numberOfLayersPerStair) return false;
      
      return true;
    }) || null;
  };
  
  /**
   * Collect all available remaining stones from all stair parts in session
   * Excludes already used remaining stones
   */
  const collectAvailableRemainingStones = (
    sessionItems: ContractProduct[],
    currentProductRemainingStones: RemainingStone[]
  ): RemainingStone[] => {
    const allAvailable: RemainingStone[] = [];
    
    // Collect from all non-layer stair parts in session
    sessionItems.forEach(item => {
      const itemIsLayer = ((item.meta as any)?.isLayer) || false;
      if (!itemIsLayer && item.remainingStones && item.remainingStones.length > 0) {
        // Get remaining stones that haven't been used yet
        const usedRemainingStones = item.usedRemainingStones || [];
        const usedRemainingStoneIds = new Set(usedRemainingStones.map(rs => rs.id));
        
        item.remainingStones.forEach(rs => {
          // Only include if not already used
          if (!usedRemainingStoneIds.has(rs.id)) {
            allAvailable.push(rs);
          }
        });
      }
    });
    
    // Also include remaining stones from the current stair part
    currentProductRemainingStones.forEach(rs => {
      allAvailable.push(rs);
    });
    
    return allAvailable;
  };
  
  /**
   * Calculate layer metrics: how many layers from remaining stones vs new stones,
   * cutting costs, and used remaining stones
   */
  const calculateLayerMetrics = (params: {
    totalLayers: number;
    layerWidthCm: number;
    layerLengthM: number;
    availableRemainingStones: RemainingStone[];
    cuttingCostPerMeter: number;
    edgeDemands?: LayerEdgeDemand[];
  }): {
    layersFromRemainingStones: number;
    layersFromNewStones: number;
    totalLayerCuttingCost: number;
    usedRemainingStonesForLayers: RemainingStone[];
    layerCutDetails: StoneCut[];
    layerRemainingPieces?: RemainingStone[];
    squareMetersFromRemaining?: number;
    squareMetersFromNew?: number;
    totalLayerDemand?: number;
    unfulfilledDemands?: Array<{ edge: LayerEdgeDemand['edge']; lengthM: number; quantity: number }>;
  } => {
    const {
      totalLayers,
      layerWidthCm,
      layerLengthM,
      availableRemainingStones,
      edgeDemands
    } = params;
    
    if (layerWidthCm <= 0) {
      return {
        layersFromRemainingStones: 0,
        layersFromNewStones: totalLayers,
        totalLayerCuttingCost: 0,
        usedRemainingStonesForLayers: [],
        layerCutDetails: [],
        layerRemainingPieces: [],
        squareMetersFromRemaining: 0,
        squareMetersFromNew: 0,
        totalLayerDemand: totalLayers
      };
    }

    const widthMeters = layerWidthCm / 100;
    const fallbackLength = layerLengthM > 0
      ? layerLengthM 
      : (availableRemainingStones[0]?.length || 0);

    const demands = (edgeDemands && edgeDemands.length)
      ? edgeDemands.filter(d => d.lengthM > 0 && d.layersNeeded > 0)
      : [{
          edge: 'front' as const,
          layersNeeded: Math.max(totalLayers, 0),
          lengthM: fallbackLength
        }];

    if (!demands.length) {
      return {
        layersFromRemainingStones: 0,
        layersFromNewStones: totalLayers,
        totalLayerCuttingCost: 0,
        usedRemainingStonesForLayers: [],
        layerCutDetails: [],
        layerRemainingPieces: [],
        squareMetersFromRemaining: 0,
        squareMetersFromNew: 0,
        totalLayerDemand: totalLayers
      };
    }

    const edgePriority: Record<LayerEdgeDemand['edge'], number> = {
      front: 0,
      back: 1,
      left: 2,
      right: 3,
      perimeter: 4
    };

    const sortedDemands = [...demands].sort(
      (a, b) => edgePriority[a.edge] - edgePriority[b.edge]
    );

    type LayerColumn = {
      id: string;
      source: RemainingStone;
      lengthRemaining: number;
      originalLength: number;
    };

    const columns: LayerColumn[] = [];
    const residualWidthPieces: RemainingStone[] = [];

    availableRemainingStones.forEach(stone => {
      const quantity = stone.quantity && stone.quantity > 0 ? stone.quantity : 1;
      const columnsPerStone = Math.floor(stone.width / layerWidthCm);
      const stoneLength = stone.length || 0;
      if (columnsPerStone <= 0 || stoneLength <= 0) {
        return;
      }

      for (let q = 0; q < quantity; q++) {
        for (let col = 0; col < columnsPerStone; col++) {
          columns.push({
            id: `${stone.id}_col_${q}_${col}`,
            source: stone,
            lengthRemaining: stoneLength,
            originalLength: stoneLength
          });
        }
      }

      const leftoverWidth = stone.width - (columnsPerStone * layerWidthCm);
      if (leftoverWidth > 0) {
        residualWidthPieces.push({
          id: `layer_width_leftover_${stone.id}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          width: leftoverWidth,
          length: stoneLength,
          squareMeters: (leftoverWidth / 100) * stoneLength,
          isAvailable: true,
          sourceCutId: stone.sourceCutId || stone.id,
          quantity: quantity
        });
      }
    });

    if (columns.length === 0) {
      return {
        layersFromRemainingStones: 0,
        layersFromNewStones: demands.reduce((sum, d) => sum + d.layersNeeded, 0),
        totalLayerCuttingCost: 0,
        usedRemainingStonesForLayers: [],
        layerCutDetails: [],
        layerRemainingPieces: residualWidthPieces,
        squareMetersFromRemaining: 0,
        squareMetersFromNew: demands.reduce((sum, d) => sum + d.layersNeeded * d.lengthM * widthMeters, 0),
        totalLayerDemand: demands.reduce((sum, d) => sum + d.layersNeeded, 0)
      };
    }

    let layersFromRemainingStones = 0;
    let totalLayerDemand = 0;
    let squareMetersFromRemaining = 0;
    let squareMetersFromNew = 0;
    const usageEntries: { source: RemainingStone; lengthM: number; quantity: number }[] = [];
    const unfulfilledDemands: Array<{ edge: LayerEdgeDemand['edge']; lengthM: number; quantity: number }> = [];

    const canUseRemainingForEdge = (edge: LayerEdgeDemand['edge']) =>
      edge === 'front' || edge === 'back' || edge === 'perimeter';

    sortedDemands.forEach(demand => {
      let needed = demand.layersNeeded;
      totalLayerDemand += demand.layersNeeded;

      if (canUseRemainingForEdge(demand.edge)) {
        for (const column of columns) {
          if (needed <= 0) break;
          if (column.lengthRemaining + 1e-6 < demand.lengthM) continue;

          const stripsPossible = Math.floor(column.lengthRemaining / demand.lengthM);
          if (stripsPossible <= 0) continue;

          const used = Math.min(needed, stripsPossible);
          column.lengthRemaining = Math.max(0, column.lengthRemaining - used * demand.lengthM);
          needed -= used;
          layersFromRemainingStones += used;
          squareMetersFromRemaining += used * demand.lengthM * widthMeters;

          usageEntries.push({
            source: column.source,
            lengthM: demand.lengthM,
            quantity: used
          });
        }
      }

      if (needed > 0) {
        squareMetersFromNew += needed * demand.lengthM * widthMeters;
        unfulfilledDemands.push({ edge: demand.edge, lengthM: demand.lengthM, quantity: needed });
      }
    });

    const layersFromNewStones = Math.max(0, totalLayerDemand - layersFromRemainingStones);

    const usedRemainingStonesForLayers: RemainingStone[] = usageEntries.map((entry, index) => ({
      id: `used_layer_${entry.source.id}_${index}`,
      width: layerWidthCm,
      length: entry.lengthM,
      squareMeters: (layerWidthCm * entry.lengthM * entry.quantity) / 100,
      isAvailable: false,
      sourceCutId: entry.source.sourceCutId || entry.source.id,
      quantity: entry.quantity
    }));

    const layerRemainingPieces: RemainingStone[] = [
      ...columns
        .filter(column => column.lengthRemaining > 1e-6)
        .map(column => ({
          id: `layer_remaining_${column.id}`,
          width: layerWidthCm,
          length: column.lengthRemaining,
          squareMeters: (layerWidthCm * column.lengthRemaining) / 100,
          isAvailable: true,
          sourceCutId: column.source.sourceCutId || column.source.id,
          quantity: 1
        })),
      ...residualWidthPieces
    ];
    
    return {
      layersFromRemainingStones,
      layersFromNewStones,
      totalLayerCuttingCost: 0,
      usedRemainingStonesForLayers,
      layerCutDetails: [],
      layerRemainingPieces,
      squareMetersFromRemaining,
      squareMetersFromNew,
      totalLayerDemand,
      unfulfilledDemands
    };
  };
  
  /**
   * Create a new layer product
   */
const createLayerProduct = (params: {
  draft: StairPartDraftV2;
  stoneProduct: Product;
  stairSystemId: string;
  parentPartType: StairStepperPart;
  totalLayers: number;
  totalLayerSqm: number;
  layerMaterialPrice: number;
  layerTotalPrice: number;
  layerTypeCost: number;
  layersFromRemainingStones: number;
  layersFromNewStones: number;
  totalLayerCuttingCost: number;
  layerCutDetails: StoneCut[];
  layerRemainingPieces?: RemainingStone[];
  usedRemainingStonesForLayers: RemainingStone[];
  originalWidthCm: number;
  lengthM: number;
  layerCuttingCostPerMeter: number;
  parentProductIndexInSession: number;
  layerPricePerSquareMeter: number;
  layerStoneLabel?: string | null;
  layerUseDifferentStone?: boolean;
  layerStoneProductId?: string | null;
  layerStoneBasePricePerSquareMeter?: number | null;
  layerUseMandatory?: boolean;
  layerMandatoryPercentage?: number | null;
  stoneAreaUsedSqm?: number; // مساحت سنگ استفاده شده برای برش لایه‌ها
}): ContractProduct => {
    const {
      draft,
      stoneProduct,
      stairSystemId,
      parentPartType,
      totalLayers,
      totalLayerSqm,
      layerMaterialPrice,
      layerTotalPrice,
    layerTypeCost,
      layersFromRemainingStones,
      layersFromNewStones,
      totalLayerCuttingCost,
      layerCutDetails,
    layerRemainingPieces,
      usedRemainingStonesForLayers,
      originalWidthCm,
      lengthM,
      layerCuttingCostPerMeter,
    parentProductIndexInSession,
    layerPricePerSquareMeter,
    layerStoneLabel,
    layerUseDifferentStone,
    layerStoneProductId,
      layerStoneBasePricePerSquareMeter,
      layerUseMandatory,
      layerMandatoryPercentage,
      stoneAreaUsedSqm
    } = params;
    
  const layerStoneName = layerUseDifferentStone
    ? (layerStoneLabel || stoneProduct.namePersian || stoneProduct.name || '')
    : (draft.stoneLabel || stoneProduct.namePersian || stoneProduct.name || '');

    return {
    productId: layerUseDifferentStone ? (layerStoneProductId || stoneProduct.id) : (draft.stoneId || stoneProduct.id),
      product: stoneProduct,
      productType: 'stair',
      stairSystemId,
      stairPartType: parentPartType,
      stoneCode: stoneProduct.code,
    stoneName: `${layerStoneName} - لایه (${draft.numberOfLayersPerStair} لایه برای هر پله)`,
      diameterOrWidth: stoneProduct.thicknessValue ?? draft.thicknessCm ?? 0,
      // For layer products, length and width represent the layer dimensions
      // Length: use stair length as reference (layers go along edges)
      // Width: layer width (the thickness of the layer strip)
      length: convertMetersToUnit(getActualLengthMeters(draft), draft.lengthUnit || 'm'), // Use actual stair length (fallback to استاندارد)
      lengthUnit: draft.lengthUnit || 'm',
      width: draft.layerWidthCm!,
      widthUnit: 'cm',
      quantity: totalLayers,
      squareMeters: totalLayerSqm, // Total square meters (calculated from edges)
    pricePerSquareMeter: layerPricePerSquareMeter,
      // 🎯 FIX: Ensure totalPrice is always a number (not string)
      totalPrice: typeof layerTotalPrice === 'number' ? Number(layerTotalPrice.toFixed(2)) : Number(parseFloat(String(layerTotalPrice || 0)).toFixed(2)),
      description: `لایه برای ${getPartDisplayLabel(parentPartType)} - ${draft.numberOfLayersPerStair} لایه برای هر پله${layersFromRemainingStones > 0 ? ` (${layersFromRemainingStones} از باقی‌مانده، ${layersFromNewStones} از سنگ جدید)` : ''}${draft.layerTypeName ? ` | نوع لایه: ${draft.layerTypeName}` : ''}`,
      currency: 'تومان',
      isMandatory: false,
      mandatoryPercentage: 0,
      originalTotalPrice: layerMaterialPrice, // Only material cost for new stones
      isCut:
        layersFromRemainingStones > 0 ||
        totalLayerCuttingCost > 0 ||
        (layerCutDetails && layerCutDetails.length > 0),
      cutType: totalLayerCuttingCost > 0 ? 'longitudinal' : null,
      // Use the same original dimensions as the main stair part for StoneCanvas consistency
      originalWidth: originalWidthCm,
      originalLength: lengthM,
      cuttingCost: totalLayerCuttingCost,
      cuttingCostPerMeter: layerCuttingCostPerMeter,
      cutDescription: layersFromRemainingStones > 0 
        ? `استفاده از باقی‌مانده: ${layersFromRemainingStones} لایه، سنگ جدید: ${layersFromNewStones} لایه`
        : '',
      // 🎯 FIX: Calculate remaining stones after cutting layers from remaining stones
      // For each cut detail, create a remaining stone piece for the leftover
      remainingStones: (() => {
        if (layerRemainingPieces && layerRemainingPieces.length) {
          return layerRemainingPieces;
        }
        const layerRemainingStones: RemainingStone[] = [];
        
        // 🎯 FIX: Process cutDetails to create remaining stone pieces correctly
        // Similar to slab cutting - can have multiple remaining pieces (width, length, corner)
        layerCutDetails.forEach((cutDetail, index) => {
          // Get stored dimensions from cutDetail (added in calculateLayerMetrics)
          const cutDetailAny = cutDetail as any;
          const originalRemainingWidthCm = cutDetail.originalWidth;
          const originalRemainingLengthCm = cutDetail.length; // Already in cm (stored as original remaining stone length)
          const layerWidthCm = cutDetailAny._layerWidthCm || draft.layerWidthCm || 0;
          const layerLengthCm = cutDetailAny._layerLengthCm || (lengthM * 100);
          
          // Determine what cuts were made
          const needsWidthCut = layerWidthCm > 0 && layerWidthCm < originalRemainingWidthCm;
          const needsLengthCut = layerLengthCm > 0 && layerLengthCm < originalRemainingLengthCm;
          
          // Find the corresponding usedRemainingStone to get quantity
          const correspondingUsedStone = usedRemainingStonesForLayers.find((urs, idx) => {
            // Match by index or by checking if dimensions align
            const layerLengthM = layerLengthCm / 100;
            return idx === index || (Math.abs(urs.length - layerLengthM) < 0.001 && Math.abs(urs.width - layerWidthCm) < 0.01);
          });
          
          const quantity = correspondingUsedStone?.quantity || 1;
          
          // 🎯 FIX: Calculate remaining pieces correctly when multiple layers are cut
          // Get stored values from cutDetail (calculated in calculateLayerMetrics)
          const actualUsedWidthCm = cutDetailAny._actualUsedWidthCm || layerWidthCm;
          const actualUsedLengthCm = cutDetailAny._actualUsedLengthCm || layerLengthCm;
          const actualRemainingWidthCm = cutDetailAny._actualRemainingWidthCm || Math.max(0, originalRemainingWidthCm - layerWidthCm);
          const actualRemainingLengthCm = cutDetailAny._actualRemainingLengthCm || Math.max(0, originalRemainingLengthCm - layerLengthCm);
          
          // 🎯 Calculate remaining pieces (similar to slab cutting logic)
          if (needsWidthCut || needsLengthCut) {
            // 🎯 FIX: Calculate remaining pieces correctly - avoid double-counting corner piece
            // When both width and length cuts are made, we get:
            // 1. Width leftover piece: remainingWidth × FULL original length (includes corner)
            // 2. Length leftover piece: usedWidth × remainingLength (does NOT include corner, it's separate)
            // The corner (remainingWidth × remainingLength) is already included in Piece 1, so we DON'T add it separately
            
            // Piece 1: Remaining width piece (if width cut was made)
            // This is the piece that remains after cutting multiple layers width-wise
            // Example: 20cm original, cut 2 layers of 7cm each (14cm used), remaining = 6cm × full length (1.2m)
            // NOTE: This piece includes the corner (6cm × 0.2m) as part of the full length
            if (needsWidthCut && actualRemainingWidthCm > 0 && originalRemainingLengthCm > 0) {
              const remainingWidthPieceLengthM = originalRemainingLengthCm / 100; // Use FULL original length (1.2m)
              const remainingWidthSqm = (actualRemainingWidthCm * remainingWidthPieceLengthM * quantity) / 100;
              
              layerRemainingStones.push({
                id: `layer_remaining_width_${cutDetail.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                width: actualRemainingWidthCm, // 6cm (after cutting 2 layers of 7cm from 20cm)
                length: remainingWidthPieceLengthM, // Store in meters - FULL original length (1.2m) - includes corner!
                squareMeters: remainingWidthSqm,
                isAvailable: actualRemainingWidthCm > 0 && remainingWidthPieceLengthM > 0,
                sourceCutId: cutDetail.id,
                quantity: quantity,
                // Position: remaining piece is after the used width
                position: {
                  startWidth: actualUsedWidthCm, // Start after all layers width (14cm)
                  startLength: 0 // Same length start as original
                }
              });
            }
            
            // Piece 2: Remaining length piece (if length cut was made)
            // This is the piece that remains after cutting layers length-wise
            // Example: 1.2m original, cut 1 layer of 1m, remaining = used width (14cm) × 0.2m
            // NOTE: This is separate from Piece 1, positioned below the used area
            if (needsLengthCut && actualRemainingLengthCm > 0 && actualUsedWidthCm > 0) {
              const remainingLengthPieceWidthCm = actualUsedWidthCm; // Use FULL width of used area (14cm when 2 layers)
              const remainingLengthPieceLengthM = actualRemainingLengthCm / 100; // Convert cm to meters (0.2m)
              const remainingLengthSqm = (remainingLengthPieceWidthCm * remainingLengthPieceLengthM * quantity) / 100;
              
              layerRemainingStones.push({
                id: `layer_remaining_length_${cutDetail.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                width: remainingLengthPieceWidthCm, // 14cm (full width of used area)
                length: remainingLengthPieceLengthM, // Store in meters (0.2m)
                squareMeters: remainingLengthSqm,
                isAvailable: remainingLengthPieceWidthCm > 0 && remainingLengthPieceLengthM > 0,
                sourceCutId: cutDetail.id,
                quantity: quantity,
                // Position: remaining piece is after the used length
                position: {
                  startWidth: 0, // Same width start as used area
                  startLength: actualUsedLengthCm / 100 // Start after all layers length (1m in meters)
                }
              });
            }
            
            // 🎯 REMOVED: Corner piece is NOT needed separately
            // The corner (remainingWidth × remainingLength) is already included in Piece 1 (width leftover piece)
            // Adding it separately would cause double-counting
            // Example: 6cm × 0.2m corner is already part of 6cm × 1.2m Piece 1
          }
        });
        
        return layerRemainingStones;
      })(),
      cutDetails: layerCutDetails,
      usedRemainingStones: usedRemainingStonesForLayers,
      totalUsedRemainingWidth: usedRemainingStonesForLayers.reduce((sum, rs) => sum + (rs.width || 0), 0),
      totalUsedRemainingLength: usedRemainingStonesForLayers.reduce((sum, rs) => sum + (rs.length || 0), 0),
      appliedSubServices: [],
      totalSubServiceCost: 0,
      usedLengthForSubServices: 0,
      usedSquareMetersForSubServices: 0,
      standardLengthValue: draft.standardLengthValue ?? null,
      standardLengthUnit: draft.standardLengthUnit || draft.lengthUnit || 'm',
      layerTypeId: draft.layerTypeId ?? null,
      layerTypeName: draft.layerTypeName ?? null,
      layerTypePrice: draft.layerTypePrice ?? null,
    layerUseDifferentStone: !!layerUseDifferentStone,
    layerStoneProductId: layerUseDifferentStone ? (layerStoneProductId || stoneProduct.id) : null,
    layerStoneName: layerUseDifferentStone ? layerStoneName : null,
    layerStonePricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : null,
    layerStoneBasePricePerSquareMeter: layerUseDifferentStone ? (layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter) : null,
    layerUseMandatory: layerUseDifferentStone ? (layerUseMandatory ?? true) : undefined,
    layerMandatoryPercentage: layerUseDifferentStone ? (layerMandatoryPercentage ?? null) : undefined,
      actualLengthMeters: getActualLengthMeters(draft) || null,
      // 🎯 Set parentProductIndex to link layer to its parent stair part
      // This will be set correctly when adding to wizardData.products
      parentProductIndex: undefined, // Will be set after adding to wizardData
      meta: {
        stairStepperV2: true,
        isLayer: true,
        layerEdges: draft.layerEdges, // Store selected edges
        layerInfo: {
          numberOfLayersPerStair: draft.numberOfLayersPerStair,
          parentPartType,
          parentQuantity: draft.quantity,
          layersFromRemainingStones,
          layersFromNewStones,
          parentProductIndexInSession // Store for later reference
        },
        standardLength: draft.standardLengthValue ? {
          value: draft.standardLengthValue,
          unit: draft.standardLengthUnit || draft.lengthUnit || 'm',
          meters: getPricingLengthMeters(draft)
        } : undefined,
        layerType: draft.layerTypeId ? {
          id: draft.layerTypeId,
          name: draft.layerTypeName,
          pricePerLayer: draft.layerTypePrice || 0,
          totalCost: layerTypeCost
        } : undefined,
        layerAltStone: layerUseDifferentStone ? {
          id: layerStoneProductId || stoneProduct.id,
          name: layerStoneName,
          pricePerSquareMeter: layerPricePerSquareMeter,
          basePricePerSquareMeter: layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter,
          mandatoryPercentage: layerUseMandatory ? (layerMandatoryPercentage ?? 0) : 0
        } : undefined,
        // 🎯 Store stone area used for layers (مساحت سنگ استفاده شده)
        stoneAreaUsedSqm: stoneAreaUsedSqm && stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : undefined
      } as any
    };
  };
  
  /**
   * Merge an existing layer product with new layer data
   */
  const mergeLayerProduct = (
    existing: ContractProduct,
    newData: {
      draft: StairPartDraftV2;
      parentPartType: StairStepperPart;
      newLayersNeeded: number;
      newLayerSqm: number;
      layerMaterialPrice: number;
      layerTypeCost: number;
      totalLayerCuttingCost: number;
      layerCutDetails: StoneCut[];
      usedRemainingStonesForLayers: RemainingStone[];
      layersFromRemainingStones: number; // Add this parameter
    layersFromNewStones: number; // Add this parameter
    layerPricePerSquareMeter: number;
    layerStoneLabel?: string | null;
    layerUseDifferentStone?: boolean;
    layerStoneProductId?: string | null;
    layerStoneBasePricePerSquareMeter?: number | null;
    layerUseMandatory?: boolean;
    layerMandatoryPercentage?: number | null;
    stoneAreaUsedSqm?: number; // مساحت سنگ استفاده شده
    }
  ): ContractProduct => {
    const {
      draft,
      parentPartType,
      newLayersNeeded,
      newLayerSqm,
      layerMaterialPrice,
      layerTypeCost,
      totalLayerCuttingCost,
      layerCutDetails,
      usedRemainingStonesForLayers,
      layersFromRemainingStones,
    layersFromNewStones,
    layerPricePerSquareMeter,
    layerStoneLabel,
    layerUseDifferentStone,
    layerStoneProductId,
      layerStoneBasePricePerSquareMeter,
      layerUseMandatory,
      layerMandatoryPercentage,
      stoneAreaUsedSqm
    } = newData;
    
    const existingLayerInfo = (existing.meta as any)?.layerInfo;
    const existingLayersFromRemaining = existingLayerInfo?.layersFromRemainingStones || 0;
    const existingLayersFromNew = existingLayerInfo?.layersFromNewStones || 0;
    
    // Merge layer counts
    const updatedLayersFromRemaining = existingLayersFromRemaining + layersFromRemainingStones;
    const updatedLayersFromNew = existingLayersFromNew + layersFromNewStones;
    const updatedTotalLayers = updatedLayersFromRemaining + updatedLayersFromNew;
    
    // Recalculate totals with merged quantities
    const existingLayerSqm = existing.squareMeters || 0;
    const updatedTotalSqm = existingLayerSqm + newLayerSqm;
    
    // 🎯 Merge stone area used
    const existingStoneAreaUsed = (existing.meta as any)?.stoneAreaUsedSqm || 0;
    const updatedStoneAreaUsedSqm = stoneAreaUsedSqm && stoneAreaUsedSqm > 0
      ? (existingStoneAreaUsed + stoneAreaUsedSqm)
      : existingStoneAreaUsed;
    
    // Merge remaining stone usage
    const existingUsedRemainingStones = existing.usedRemainingStones || [];
    const mergedUsedRemainingStones = [...existingUsedRemainingStones, ...usedRemainingStonesForLayers];
    
    // Merge cut details
    const existingCutDetails = existing.cutDetails || [];
    const mergedCutDetails = [...existingCutDetails, ...layerCutDetails];
    
    // Recalculate pricing
    const existingLayerMaterialPrice = existing.originalTotalPrice || 0;
  const updatedLayerMaterialPrice = layerMaterialPrice + existingLayerMaterialPrice;
    // 🎯 FIX: Ensure updatedLayerTotalPrice is always a number (not string) and properly rounded
    const updatedLayerTotalPrice = Number((updatedLayerMaterialPrice + (existing.cuttingCost || 0) + totalLayerCuttingCost).toFixed(2));
    
    const existingLayerTypeMeta = (existing.meta as any)?.layerType || {};
    return {
      ...existing,
      quantity: updatedTotalLayers,
      squareMeters: updatedTotalSqm,
      totalPrice: updatedLayerTotalPrice,
      originalTotalPrice: updatedLayerMaterialPrice,
      cuttingCost: (existing.cuttingCost || 0) + totalLayerCuttingCost,
      cutDetails: mergedCutDetails,
      usedRemainingStones: mergedUsedRemainingStones,
      totalUsedRemainingWidth: mergedUsedRemainingStones.reduce((sum, rs) => sum + (rs.width || 0), 0),
      totalUsedRemainingLength: mergedUsedRemainingStones.reduce((sum, rs) => sum + (rs.length || 0), 0),
    description: `لایه برای ${getPartDisplayLabel(parentPartType)} - ${draft.numberOfLayersPerStair} لایه برای هر پله (${updatedLayersFromRemaining} از باقی‌مانده، ${updatedLayersFromNew} از سنگ جدید)${draft.layerTypeName ? ` | نوع لایه: ${draft.layerTypeName}` : ''}`,
      cutDescription: mergedUsedRemainingStones.length > 0 
        ? `استفاده از باقی‌مانده: ${updatedLayersFromRemaining} لایه، سنگ جدید: ${updatedLayersFromNew} لایه`
        : '',
      layerTypeId: draft.layerTypeId ?? existing.layerTypeId ?? null,
      layerTypeName: draft.layerTypeName ?? existing.layerTypeName ?? null,
      layerTypePrice: draft.layerTypePrice ?? existing.layerTypePrice ?? null,
    pricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : existing.pricePerSquareMeter,
    layerUseDifferentStone: layerUseDifferentStone ?? existing.layerUseDifferentStone ?? false,
    layerStoneProductId: layerUseDifferentStone ? (layerStoneProductId || existing.layerStoneProductId || existing.productId) : existing.layerStoneProductId || null,
    layerStoneName: layerUseDifferentStone ? (layerStoneLabel || existing.layerStoneName || existing.stoneName) : existing.layerStoneName || null,
    layerStonePricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : existing.layerStonePricePerSquareMeter || null,
    layerStoneBasePricePerSquareMeter: layerUseDifferentStone
      ? (layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter)
      : existing.layerStoneBasePricePerSquareMeter || null,
    layerUseMandatory: layerUseDifferentStone
      ? (layerUseMandatory ?? existing.layerUseMandatory ?? true)
      : existing.layerUseMandatory,
    layerMandatoryPercentage: layerUseDifferentStone
      ? (layerMandatoryPercentage ?? existing.layerMandatoryPercentage ?? null)
      : existing.layerMandatoryPercentage,
      meta: {
        ...existing.meta,
        layerEdges: draft.layerEdges, // Update edges if changed
        layerInfo: {
          ...existingLayerInfo,
          layersFromRemainingStones: updatedLayersFromRemaining,
          layersFromNewStones: updatedLayersFromNew,
          parentQuantity: (existingLayerInfo?.parentQuantity || 0) + draft.quantity
        },
        standardLength: draft.standardLengthValue
          ? {
              value: draft.standardLengthValue,
              unit: draft.standardLengthUnit || draft.lengthUnit || 'm',
              meters: getPricingLengthMeters(draft)
            }
          : (existing.meta as any)?.standardLength,
        layerType: draft.layerTypeId
          ? {
              id: draft.layerTypeId,
              name: draft.layerTypeName,
              pricePerLayer: draft.layerTypePrice || existingLayerTypeMeta.pricePerLayer || 0,
              totalCost: (existingLayerTypeMeta.totalCost || 0) + layerTypeCost
            }
          : ((existing.meta as any)?.layerType),
        layerAltStone: (layerUseDifferentStone ?? existing.layerUseDifferentStone)
          ? {
              id: layerUseDifferentStone ? (layerStoneProductId || existing.layerStoneProductId || existing.productId) : (existing.layerStoneProductId || existing.productId),
              name: layerUseDifferentStone ? (layerStoneLabel || existing.layerStoneName || existing.stoneName) : (existing.layerStoneName || existing.stoneName),
              pricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : (existing.layerStonePricePerSquareMeter || layerPricePerSquareMeter || existing.pricePerSquareMeter),
              basePricePerSquareMeter: layerUseDifferentStone
                ? (layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter)
                : (existing.layerStoneBasePricePerSquareMeter || layerStoneBasePricePerSquareMeter || existing.pricePerSquareMeter),
              mandatoryPercentage: layerUseDifferentStone
                ? (layerUseMandatory ? (layerMandatoryPercentage ?? 0) : 0)
                : (existing.layerUseMandatory ? (existing.layerMandatoryPercentage ?? 0) : 0)
            }
          : undefined,
        // 🎯 Merge stone area used
        stoneAreaUsedSqm: updatedStoneAreaUsedSqm > 0 ? updatedStoneAreaUsedSqm : undefined
      } as any
    };
  };
  
  /**
   * Update remaining stone usage tracking in products
   * Returns a map of product index to updated product
   */
  const updateRemainingStoneUsage = (
    sessionItems: ContractProduct[],
    usedRemainingStones: RemainingStone[],
    mainStairPartIndex: number
  ): Map<number, ContractProduct> => {
    const updates = new Map<number, ContractProduct>();
    
    if (usedRemainingStones.length === 0) {
      return updates;
    }
    
    // Create a map of remaining stone IDs to their source product index
    const remainingStoneSourceMap = new Map<string, number>();
    sessionItems.forEach((item, idx) => {
      const itemIsLayer = ((item.meta as any)?.isLayer) || false;
      if (!itemIsLayer && item.remainingStones && item.remainingStones.length > 0) {
        item.remainingStones.forEach(rs => {
          remainingStoneSourceMap.set(rs.id, idx);
        });
      }
    });
    
    // Group used remaining stones by their source product
    const usedBySource = new Map<number, RemainingStone[]>();
    usedRemainingStones.forEach(usedRs => {
      const sourceIdx = remainingStoneSourceMap.get(usedRs.id);
      if (sourceIdx !== undefined) {
        if (!usedBySource.has(sourceIdx)) {
          usedBySource.set(sourceIdx, []);
        }
        usedBySource.get(sourceIdx)!.push(usedRs);
      }
    });
    
    // Also update the main stair part (the one we just added)
    if (mainStairPartIndex >= 0 && mainStairPartIndex < sessionItems.length) {
      const mainProduct = sessionItems[mainStairPartIndex];
      if (mainProduct && mainProduct.productType === 'stair' && !((mainProduct.meta as any)?.isLayer)) {
        const existingUsed = mainProduct.usedRemainingStones || [];
        const mergedUsed = [...existingUsed, ...usedRemainingStones];
        updates.set(mainStairPartIndex, {
          ...mainProduct,
          usedRemainingStones: mergedUsed,
          totalUsedRemainingWidth: mergedUsed.reduce((sum, rs) => sum + (rs.width || 0), 0),
          totalUsedRemainingLength: mergedUsed.reduce((sum, rs) => sum + (rs.length || 0), 0)
        });
      }
    }
    
    // Update each source product with its used remaining stones
    usedBySource.forEach((usedStones, sourceIdx) => {
      if (sourceIdx >= 0 && sourceIdx < sessionItems.length) {
        const sourceProduct = sessionItems[sourceIdx];
        if (sourceProduct && sourceProduct.productType === 'stair' && !((sourceProduct.meta as any)?.isLayer)) {
          const existingUsed = sourceProduct.usedRemainingStones || [];
          const mergedUsed = [...existingUsed, ...usedStones];
          updates.set(sourceIdx, {
            ...sourceProduct,
            usedRemainingStones: mergedUsed,
            totalUsedRemainingWidth: mergedUsed.reduce((sum, rs) => sum + (rs.width || 0), 0),
            totalUsedRemainingLength: mergedUsed.reduce((sum, rs) => sum + (rs.length || 0), 0)
          });
        }
      }
    });
    
    return updates;
  };

  const computeTotalsV2 = (
    part: StairStepperPart,
    draft: StairPartDraftV2
  ): {
    sqm: number;
    toolsTotal: number;
    partTotal: number;
    pricingSquareMeters: number;
    baseStoneQuantity: number;
    piecesPerStone: number;
    leftoverWidthCm: number;
    cuttingCost: number;
    cuttingCostPerMeter: number;
    cuttingCostLongitudinal: number;
    cuttingCostPerMeterLongitudinal: number;
    cuttingCostCross: number;
    cuttingCostPerMeterCross: number;
    baseMaterialPrice: number;
    billableCuttingCost: number;
    billableCuttingCostLongitudinal: number;
    billableCuttingCostCross: number;
    shouldChargeCuttingCost: boolean;
  } => {
    // Calculate display square meters using user-entered width (for display purposes)
    const sqm = computeSqmV2(draft);
    const toolsMeters = computeToolsMetersV2(part, draft);
    const pricePerSqm = draft.pricePerSquareMeter || 0;
    let toolsPrice = 0;
    if (draft.tools && draft.tools.length) {
      for (const t of draft.tools) {
        const meters = computeToolMetersForTool(part, draft, t);
        toolsPrice += meters * (t.pricePerMeter || 0);
      }
    }
    
    // 🎯 CRITICAL: Use original width for pricing (like long stone products)
    // Display sqm uses user-entered width, but pricing uses original width
    const {
      originalWidthCm,
      userWidthCm,
      baseStoneQuantity,
      piecesPerStone,
      leftoverWidthCm
    } = calculateStairStoneUsage(draft);
    const actualLengthM = getActualLengthMeters(draft);
    const pricingLengthM = part === 'riser' ? actualLengthM : getPricingLengthMeters(draft);
    const stoneQuantityForPricing = baseStoneQuantity || 0;

    let pricingSquareMeters = sqm;
    if (originalWidthCm > 0 && userWidthCm > 0 && pricingLengthM > 0 && stoneQuantityForPricing > 0) {
      pricingSquareMeters = pricingLengthM * (originalWidthCm / 100) * stoneQuantityForPricing;
    }

    const baseMaterialPrice = pricingSquareMeters * pricePerSqm;
    const defaultMandatoryForPart = part === 'riser' || part === 'landing';
    const isMandatoryEnabled = draft.useMandatory ?? defaultMandatoryForPart;
    const mandatoryPercentageValue = draft.mandatoryPercentage ?? 20;
    const mandatoryAmount = isMandatoryEnabled && mandatoryPercentageValue > 0
      ? baseMaterialPrice * (mandatoryPercentageValue / 100)
      : 0;
    const materialPriceWithMandatory = baseMaterialPrice + mandatoryAmount;

    let cuttingCostPerMeter = 0;
    let cuttingCost = 0;
    let cuttingCostLongitudinal = 0;
    let cuttingCostPerMeterLongitudinal = 0;
    let cuttingCostCross = 0;
    let cuttingCostPerMeterCross = 0;
    const needsWidthCut =
      originalWidthCm > 0 && userWidthCm > 0 && userWidthCm < originalWidthCm && actualLengthM > 0;
    const needsLengthCut =
      pricingLengthM > 0 && actualLengthM > 0 && pricingLengthM - actualLengthM > 0.0001 && userWidthCm > 0;

    if (needsWidthCut && stoneQuantityForPricing > 0) {
      cuttingCostPerMeterLongitudinal =
        (draft.stoneProduct as any)?.cuttingCostPerMeter ??
        getCuttingTypePricePerMeter('LONG') ??
        0;
      if (cuttingCostPerMeterLongitudinal > 0) {
        cuttingCostLongitudinal = cuttingCostPerMeterLongitudinal * actualLengthM * stoneQuantityForPricing;
      }
    }

    if (needsLengthCut && stoneQuantityForPricing > 0) {
      const crossRateFromConfig =
        (draft.stoneProduct as any)?.crossCuttingCostPerMeter ??
        getCuttingTypePricePerMeter('CROSS') ??
        getCuttingTypePricePerMeter('LONG') ??
        0;
      cuttingCostPerMeterCross = crossRateFromConfig;
      if (cuttingCostPerMeterCross > 0) {
        const widthInMeters = userWidthCm / 100;
        cuttingCostCross = cuttingCostPerMeterCross * widthInMeters * stoneQuantityForPricing;
      }
    }

    cuttingCost = cuttingCostLongitudinal + cuttingCostCross;
    cuttingCostPerMeter = cuttingCostLongitudinal > 0
      ? cuttingCostPerMeterLongitudinal
      : (cuttingCostCross > 0 ? cuttingCostPerMeterCross : 0);

    const shouldChargeCuttingCost = !(isMandatoryEnabled && mandatoryPercentageValue > 0);
    const billableCuttingCostLongitudinal = shouldChargeCuttingCost ? cuttingCostLongitudinal : 0;
    const billableCuttingCostCross = shouldChargeCuttingCost ? cuttingCostCross : 0;
    const billableCuttingCost = billableCuttingCostLongitudinal + billableCuttingCostCross;

    const partTotal = materialPriceWithMandatory + toolsPrice + billableCuttingCost;
    return {
      sqm,
      toolsTotal: toolsPrice,
      partTotal,
      pricingSquareMeters,
      baseStoneQuantity: stoneQuantityForPricing,
      piecesPerStone,
      leftoverWidthCm,
      cuttingCost,
      cuttingCostPerMeter,
      cuttingCostLongitudinal,
      cuttingCostPerMeterLongitudinal,
      cuttingCostCross,
      cuttingCostPerMeterCross,
      baseMaterialPrice,
      billableCuttingCost,
      billableCuttingCostLongitudinal,
      billableCuttingCostCross,
      shouldChargeCuttingCost
    };
  };

  const computeFinishingCost = (
    draft: StairPartDraftV2,
    pricingSquareMeters: number
  ): number => {
    if (!draft.finishingEnabled || !draft.finishingId || !draft.finishingPricePerSquareMeter) {
      return 0;
    }
    if (pricingSquareMeters <= 0) return 0;
    return pricingSquareMeters * draft.finishingPricePerSquareMeter;
  };

  // Debounced stone search using products endpoint (acts as master data + price source)
  useEffect(() => {
    let active = true;
    const term = stoneSearchTerm?.trim();
    if (!useStairFlowV2) return;
    if (!term) {
      setStoneSearchResults([]);
      return;
    }
    setIsSearchingStones(true);
    const timeout = setTimeout(async () => {
      try {
        const res = await salesAPI.getProducts({ search: term, limit: 10, contractType: 'stair' });
        if (!active) return;
        const rawItems: Product[] = (res?.data?.items || res?.data?.data || []) as Product[];
        
        // Deduplicate products by ID first, then by code if IDs are missing/duplicate
        const seenIds = new Set<string>();
        const seenCodes = new Set<string>();
        const uniqueProducts = rawItems.filter((item) => {
          if (item.id) {
            if (seenIds.has(item.id)) {
              return false;
            }
            seenIds.add(item.id);
            return true;
          }
          if (item.code) {
            if (seenCodes.has(item.code)) {
              return false;
            }
            seenCodes.add(item.code);
            return true;
          }
          return true;
        });
        
        const stairEligibleProducts = uniqueProducts.filter(product =>
          productSupportsContractType(product, 'stair')
        );
        setStoneSearchResults(stairEligibleProducts);
      } catch (e) {
        console.error('Stone search failed', e);
        if (active) setStoneSearchResults([]);
      } finally {
        if (active) setIsSearchingStones(false);
      }
    }, 300);
    return () => { active = false; clearTimeout(timeout); };
  }, [stoneSearchTerm, useStairFlowV2]);

  useEffect(() => {
    let active = true;
    const term = layerStoneSearchTerm?.trim();
    if (!useStairFlowV2) return;
    if (!term) {
      setLayerStoneSearchResults([]);
      return;
    }
    setIsSearchingLayerStones(true);
    const timeout = setTimeout(async () => {
      try {
        const res = await salesAPI.getProducts({ search: term, limit: 10, contractType: 'stair' });
        if (!active) return;
        const items: Product[] = (res?.data?.items || res?.data?.data || []) as Product[];
        const stairEligible = items.filter(product => productSupportsContractType(product, 'stair'));
        setLayerStoneSearchResults(stairEligible);
      } catch (e) {
        console.error('Layer stone search failed', e);
        if (active) setLayerStoneSearchResults([]);
      } finally {
        if (active) setIsSearchingLayerStones(false);
      }
    }, 300);
    return () => {
      active = false;
      clearTimeout(timeout);
    };
  }, [layerStoneSearchTerm, useStairFlowV2]);

  // Debounced tools search
  useEffect(() => {
    let active = true;
    const term = toolsSearchTerm?.trim();
    if (!useStairFlowV2) return;
    // If no term, load top tools (initial list) instead of clearing
    setIsSearchingTools(true);
    const timeout = setTimeout(async () => {
      try {
        const params: any = { limit: 20 };
        if (term) params.search = term;
        const res = await servicesAPI.getSubServices(params);
        if (!active) return;
        const items = res?.data?.items || res?.data?.data || [];
        setToolsResults(items);
      } catch (e) {
        console.error('Tools search failed', e);
        if (active) setToolsResults([]);
      } finally {
        if (active) setIsSearchingTools(false);
      }
    }, 300);
    return () => { active = false; clearTimeout(timeout); };
  }, [toolsSearchTerm, useStairFlowV2]);

  // Preload tools list once when modal flow is used
  useEffect(() => {
    if (!useStairFlowV2) return;
    (async () => {
      try {
        const res = await servicesAPI.getSubServices({ limit: 20 });
        const items = res?.data?.items || res?.data?.data || [];
        setToolsResults(items);
      } catch (e) {
        console.error('Initial tools preload failed', e);
      }
    })();
  }, [useStairFlowV2]);
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const getSlabStandardDimensions = () => {
    const fallbackWidthCm = selectedProduct?.widthValue || productConfig.diameterOrWidth || 0;
    let standardWidthCm = productConfig.slabStandardWidthCm ?? productConfig.originalWidth ?? fallbackWidthCm;
    if (!standardWidthCm && fallbackWidthCm) {
      standardWidthCm = fallbackWidthCm;
    }
    
    const fallbackLengthCm = (selectedProduct as any)?.lengthValue || 300;
    let standardLengthCm: number;
    if (productConfig.slabStandardLengthCm != null) {
      standardLengthCm = productConfig.slabStandardLengthCm;
    } else if (productConfig.originalLength != null) {
      const storedUnit = productConfig.lengthUnit || lengthUnit;
      standardLengthCm = storedUnit === 'm'
        ? productConfig.originalLength * 100
        : productConfig.originalLength;
    } else {
      standardLengthCm = fallbackLengthCm;
    }
    
    return {
      standardLengthCm: standardLengthCm || 0,
      standardWidthCm: standardWidthCm || 0
    };
  };
  const [productConfig, setProductConfig] = useState<Partial<ContractProduct>>({});
  const [lengthUnit, setLengthUnit] = useState<'cm' | 'm'>('m');
  const [widthUnit, setWidthUnit] = useState<'cm' | 'm'>('cm');
  
  // Edit mode state
  const [isEditMode, setIsEditMode] = useState(false);
  const [editingProductIndex, setEditingProductIndex] = useState<number | null>(null);
  
  // SubService modal state
  const [showSubServiceModal, setShowSubServiceModal] = useState(false);
  const [subServices, setSubServices] = useState<SubService[]>([]);
  const [stoneFinishings, setStoneFinishings] = useState<StoneFinishing[]>([]);
  const [selectedSubServiceProductIndex, setSelectedSubServiceProductIndex] = useState<number | null>(null);
  const [selectedSubServices, setSelectedSubServices] = useState<SubService[]>([]);
  const [subServiceMeterValues, setSubServiceMeterValues] = useState<Record<string, number>>({}); // subServiceId -> meter value
  const [subServiceCalculationBases, setSubServiceCalculationBases] = useState<Record<string, 'length' | 'squareMeters'>>({}); // subServiceId -> selected calculation base
  
  // Payment entry modal state
  const [showPaymentEntryModal, setShowPaymentEntryModal] = useState(false);
  const [editingPaymentEntryId, setEditingPaymentEntryId] = useState<string | null>(null);
  const [paymentEntryForm, setPaymentEntryForm] = useState<Partial<PaymentEntry>>({
    method: 'CASH',
    status: 'WILL_BE_PAID',
    paymentDate: '',
    amount: 0
  });
  
  // Mandatory pricing state
  const [isMandatory, setIsMandatory] = useState(false);
  const [mandatoryPercentage, setMandatoryPercentage] = useState(20);
  
  // Quantity interaction tracking
  const [hasQuantityBeenInteracted, setHasQuantityBeenInteracted] = useState(false);
  
  // Track which input fields have been focused/touched for auto-clear UX
  const [touchedFields, setTouchedFields] = useState<Set<string>>(new Set());
  
  // Stair stone specific state (old - keeping for backward compatibility during transition)
  const [treadWidthUnit, setTreadWidthUnit] = useState<'cm' | 'm'>('m'); // Default to meters for tread width
  const [quantityType, setQuantityType] = useState<'steps' | 'staircases'>('steps'); // Default to steps
  
  // Stair System state (new implementation)
  const [stairSystemConfig, setStairSystemConfig] = useState<StairSystemConfig | null>(null);
  
  // Collapsible sections state for stair system modal
  const [treadExpanded, setTreadExpanded] = useState(true);
  const [riserExpanded, setRiserExpanded] = useState(true);
  const [landingExpanded, setLandingExpanded] = useState(false);
  
  // Product search state for each stair part (for independent product selection)
  const [treadProductSearchTerm, setTreadProductSearchTerm] = useState('');
  const [riserProductSearchTerm, setRiserProductSearchTerm] = useState('');
  const [landingProductSearchTerm, setLandingProductSearchTerm] = useState('');
  
  // Helper function to initialize stair system config
  const initializeStairSystemConfig = (defaultProduct: Product | null): StairSystemConfig => {
    return {
      numberOfSteps: 0,
      quantityType: 'steps',
      numberOfStaircases: 1,
      defaultProduct: defaultProduct,
      tread: {
        partType: 'tread',
        isSelected: false,
        productId: defaultProduct?.id || null,
        product: defaultProduct,
        treadWidth: 0,
        treadDepth: 30,
        quantity: 0,
        squareMeters: 0,
        pricePerSquareMeter: defaultProduct?.basePrice || 0,
        totalPrice: 0,
        nosingType: 'none',
        nosingOverhang: 30,
        nosingCuttingCost: 0,
        nosingCuttingCostPerMeter: 0,
        isMandatory: false,
        mandatoryPercentage: 20,
        originalTotalPrice: 0,
        description: '',
        currency: 'تومان',
        lengthUnit: 'm'
      },
      riser: {
        partType: 'riser',
        isSelected: false,
        productId: defaultProduct?.id || null,
        product: defaultProduct,
        riserHeight: 17,
        quantity: 0,
        squareMeters: 0,
        pricePerSquareMeter: defaultProduct?.basePrice || 0,
        totalPrice: 0,
        isMandatory: true,
        mandatoryPercentage: 20,
        originalTotalPrice: 0,
        description: '',
        currency: 'تومان'
      },
      landing: {
        partType: 'landing',
        isSelected: false,
        productId: defaultProduct?.id || null,
        product: defaultProduct,
        landingWidth: 0,
        landingDepth: 0,
        numberOfLandings: 0,
        quantity: 0,
        squareMeters: 0,
        pricePerSquareMeter: defaultProduct?.basePrice || 0,
        totalPrice: 0,
        isMandatory: true,
        mandatoryPercentage: 20,
        originalTotalPrice: 0,
        description: '',
        currency: 'تومان'
      }
    };
  };
  
  // Helper function to handle field focus and auto-clear default values
  const handleFieldFocus = (fieldName: string, currentValue: number | string | null | undefined, defaultValue: number | string) => {
    // Check if field has been touched before
    if (!touchedFields.has(fieldName)) {
      // Mark as touched
      setTouchedFields(prev => new Set(prev).add(fieldName));
      
      // If current value is still at default, clear it
      const isAtDefault = (currentValue === defaultValue || 
                          currentValue === null || 
                          currentValue === undefined ||
                          (typeof defaultValue === 'number' && typeof currentValue === 'number' && currentValue === defaultValue));
      
      if (isAtDefault) {
        if (typeof defaultValue === 'number') {
          // For number inputs, set to undefined to make it appear empty
          if (fieldName === 'length') {
            setProductConfig(prev => ({ ...prev, length: undefined }));
          } else if (fieldName === 'width') {
            setProductConfig(prev => ({ ...prev, width: undefined }));
          } else if (fieldName === 'quantity') {
            setProductConfig(prev => ({ ...prev, quantity: undefined }));
            setHasQuantityBeenInteracted(true); // Mark as interacted when cleared
          } else if (fieldName === 'pricePerSquareMeter') {
            setProductConfig(prev => ({ ...prev, pricePerSquareMeter: undefined }));
          } else if (fieldName === 'squareMeters') {
            setProductConfig(prev => ({ ...prev, squareMeters: undefined }));
          } else if (fieldName === 'cuttingCostPerMeter') {
            setProductConfig(prev => ({ ...prev, cuttingCostPerMeter: undefined }));
          }
        } else {
          // For string inputs, set to empty
          if (fieldName === 'stoneName') {
            setProductConfig(prev => ({ ...prev, stoneName: '' }));
          } else if (fieldName === 'description') {
            setProductConfig(prev => ({ ...prev, description: '' }));
          }
        }
      }
    }
  };
  
  // Helper function to get effective quantity for calculations
  const getEffectiveQuantity = () => {
    if (!hasQuantityBeenInteracted) {
      return 1; // Default value when not interacted
    }
    return productConfig.quantity || 1; // User value or fallback to 1
  };
  
  // Helper function to get cutting type price per meter
  const getCuttingTypePricePerMeter = (cutTypeCode: string): number | null => {
    const cuttingType = cuttingTypes.find(ct => ct.code === cutTypeCode && ct.pricePerMeter !== null && ct.pricePerMeter !== undefined);
    return cuttingType?.pricePerMeter || null;
  };
  
  // Helper function to calculate cutting cost automatically
  const calculateAutoCuttingCost = (
    length: number | undefined,
    lengthUnit: 'cm' | 'm',
    cuttingCostPerMeter: number | null | undefined,
    quantity: number
  ): number => {
    if (!cuttingCostPerMeter || cuttingCostPerMeter <= 0 || !length || length <= 0) {
      return 0;
    }
    const lengthInMeters = lengthUnit === 'm' ? length : length / 100;
    const effectiveQuantity = hasQuantityBeenInteracted ? (quantity || 1) : 1;
    return lengthInMeters * cuttingCostPerMeter * effectiveQuantity;
  };
  
  // Helper function to get display value for quantity input
  const getQuantityDisplayValue = () => {
    if (!hasQuantityBeenInteracted) {
      return 0; // Show empty (0) when not interacted
    }
    // If quantity is 0 or empty, show 0 (empty field)
    if (!productConfig.quantity || productConfig.quantity === 0) {
      return 0;
    }
    return productConfig.quantity; // Show user value
  };
  
  
  // Remaining stone utilization state
  const [showRemainingStoneModal, setShowRemainingStoneModal] = useState(false);
  const [selectedRemainingStone, setSelectedRemainingStone] = useState<RemainingStone | null>(null);
  const [selectedRemainingStoneSourceProduct, setSelectedRemainingStoneSourceProduct] = useState<ContractProduct | null>(null); // Store source product for primary-remaining
  const [remainingStoneConfig, setRemainingStoneConfig] = useState<Partial<ContractProduct>>({});
  const [remainingStoneLengthUnit, setRemainingStoneLengthUnit] = useState<'cm' | 'm'>('m');
  const [remainingStoneWidthUnit, setRemainingStoneWidthUnit] = useState<'cm' | 'm'>('cm');
  const [remainingStoneIsMandatory, setRemainingStoneIsMandatory] = useState(false);
  const [remainingStoneMandatoryPercentage, setRemainingStoneMandatoryPercentage] = useState(20);
  
  // Multi-partition state
  const [partitions, setPartitions] = useState<StonePartition[]>([]);
  const [partitionLengthUnit, setPartitionLengthUnit] = useState<'cm' | 'm'>('m');
  const [partitionWidthUnit, setPartitionWidthUnit] = useState<'cm' | 'm'>('cm');
  const [partitionValidationErrors, setPartitionValidationErrors] = useState<Map<string, string>>(new Map());
  
  // Get current Persian date with fallback
  const getCurrentPersianDate = () => {
    try {
      const date = PersianCalendar.now('jYYYY/jMM/jDD');
      // Validate the date format (should be YYYY/MM/DD)
      if (date && date.match(/^\d{4}\/\d{2}\/\d{2}$/)) {
        return date;
      }
    } catch (error) {
      console.error('Error getting Persian date:', error);
    }
    // Fallback to a valid Persian date
    return '1403/01/01';
  };

  // Wizard data
  const [wizardData, setWizardData] = useState<ContractWizardData>({
    contractDate: getCurrentPersianDate(),
    contractNumber: '',
    customerId: '',
    customer: null,
    projectId: '',
    project: null,
    selectedProductTypeForAddition: null, // NEW: Product type selection
    products: [],
    deliveries: [],
    payment: {
      payments: [],
      currency: 'تومان',
      totalContractAmount: 0
    },
    signature: {
      phoneNumber: null,
      verificationCode: '',
      codeSent: false,
      codeVerified: false,
      contractId: null
    }
  });

  const productsSummary = useMemo(() => {
    const summary = wizardData.products.reduce((acc, product) => {
      const totalPriceValue = typeof product.totalPrice === 'number'
        ? product.totalPrice
        : parseFloat(String(product.totalPrice || '0'));
      const squareMetersValue = typeof product.squareMeters === 'number'
        ? product.squareMeters
        : parseFloat(String(product.squareMeters || '0'));
      const quantityValue = typeof product.quantity === 'number'
        ? product.quantity
        : parseFloat(String(product.quantity || '0'));

      acc.totalPrice += isNaN(totalPriceValue) ? 0 : totalPriceValue;
      acc.totalSquareMeters += isNaN(squareMetersValue) ? 0 : squareMetersValue;
      acc.totalQuantity += isNaN(quantityValue) ? 0 : quantityValue;
      return acc;
    }, { totalPrice: 0, totalSquareMeters: 0, totalQuantity: 0 });

    return summary;
  }, [wizardData.products]);

  // Update totalContractAmount when products change
  useEffect(() => {
    if (wizardData.payment.totalContractAmount !== productsSummary.totalPrice) {
      setWizardData(prev => ({
        ...prev,
        payment: {
          ...prev.payment,
          totalContractAmount: productsSummary.totalPrice
        }
      }));
    }
  }, [productsSummary.totalPrice]);

  // Digital Signature (Step 8) - Get available phone numbers
  const availablePhones = useMemo(() => {
    if (!wizardData.customer?.phoneNumbers) return [];
    return wizardData.customer.phoneNumbers.filter(phone => phone.isActive);
  }, [wizardData.customer]);

  // Initialize signature state if needed
  useEffect(() => {
    if (currentStep === 8 && !wizardData.signature) {
      setWizardData(prev => ({
        ...prev,
        signature: {
          phoneNumber: availablePhones.find(p => p.isPrimary)?.number || availablePhones[0]?.number || null,
          verificationCode: '',
          codeSent: false,
          codeVerified: false,
          contractId: null
        }
      }));
    }
    // Also update phone number if signature exists but phoneNumber is null and phones are available
    if (currentStep === 8 && wizardData.signature && !wizardData.signature.phoneNumber && availablePhones.length > 0) {
      setWizardData(prev => ({
        ...prev,
        signature: {
          ...prev.signature!,
          phoneNumber: availablePhones.find(p => p.isPrimary)?.number || availablePhones[0]?.number || null
        }
      }));
    }
  }, [currentStep, availablePhones, wizardData.signature]);

  // Countdown timer effect
  useEffect(() => {
    if (currentStep === 8 && countdown !== null && countdown > 0) {
      countdownIntervalRef.current = setInterval(() => {
        setCountdown(prev => {
          if (prev === null || prev <= 1) {
            if (countdownIntervalRef.current) {
              clearInterval(countdownIntervalRef.current);
            }
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }

    return () => {
      if (countdownIntervalRef.current) {
        clearInterval(countdownIntervalRef.current);
      }
    };
  }, [currentStep, countdown]);

  // Resend cooldown timer
  useEffect(() => {
    if (currentStep === 8 && resendCooldown > 0) {
      resendCooldownIntervalRef.current = setInterval(() => {
        setResendCooldown(prev => {
          if (prev <= 1) {
            if (resendCooldownIntervalRef.current) {
              clearInterval(resendCooldownIntervalRef.current);
            }
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }

    return () => {
      if (resendCooldownIntervalRef.current) {
        clearInterval(resendCooldownIntervalRef.current);
      }
    };
  }, [currentStep, resendCooldown]);

  // Re-fetch customer data in Step 8 if phoneNumbers are missing
  useEffect(() => {
    if (currentStep === 8 && wizardData.customerId) {
      const fetchCustomerData = async () => {
        // Check if phoneNumbers are missing or empty
        if (!wizardData.customer?.phoneNumbers || wizardData.customer.phoneNumbers.length === 0) {
          try {
            const customerResponse = await crmAPI.getCustomer(wizardData.customerId);
            if (customerResponse.data.success && customerResponse.data.data) {
              setWizardData(prev => ({
                ...prev,
                customer: customerResponse.data.data
              }));
            }
          } catch (error) {
            console.error('Error re-fetching customer data in Step 8:', error);
          }
        }
      };
      fetchCustomerData();
    }
  }, [currentStep, wizardData.customerId, wizardData.customer?.phoneNumbers]);

  // Fetch remaining time when code is sent
  useEffect(() => {
    if (currentStep === 8 && wizardData.signature?.codeSent && wizardData.signature?.contractId && wizardData.signature?.phoneNumber) {
      const fetchRemainingTime = async () => {
        try {
          const response = await salesAPI.getVerificationTime(
            wizardData.signature!.contractId!,
            wizardData.signature!.phoneNumber!
          );
          if (response.data.success && response.data.data?.remainingSeconds) {
            setCountdown(response.data.data.remainingSeconds);
          }
        } catch (error) {
          console.error('Error fetching remaining time:', error);
        }
      };
      fetchRemainingTime();
      const interval = setInterval(fetchRemainingTime, 1000);
      return () => clearInterval(interval);
    }
  }, [currentStep, wizardData.signature?.codeSent, wizardData.signature?.contractId, wizardData.signature?.phoneNumber]);

  // Digital Signature handlers
  const handleSendVerificationCode = async () => {
    if (!wizardData.signature?.phoneNumber || !wizardData.signature?.contractId) {
      setErrorMessage('لطفاً شماره تلفن را انتخاب کنید و قرارداد را ایجاد کنید');
      return;
    }

    setSendingCode(true);
    setErrorMessage(null);
    setSuccessMessage(null);
    setSandboxVerificationCode(null); // Clear previous code when resending

    try {
      const response = await salesAPI.sendVerificationCode(
        wizardData.signature.contractId,
        wizardData.signature.phoneNumber
      );

      if (response.data.success) {
        setWizardData(prev => ({
          ...prev,
          signature: {
            ...prev.signature!,
            codeSent: true
          }
        }));
        
        // Store sandbox verification code if provided
        if (response.data.data?.isSandbox && response.data.data?.verificationCode) {
          setSandboxVerificationCode(response.data.data.verificationCode);
        } else {
          setSandboxVerificationCode(null);
        }
        
        setSuccessMessage('کد تایید با موفقیت ارسال شد');
        setResendCooldown(60); // 60 second cooldown
        
        // Fetch remaining time
        if (response.data.data?.expiresAt) {
          const expiresAt = new Date(response.data.data.expiresAt);
          const remaining = Math.floor((expiresAt.getTime() - Date.now()) / 1000);
          setCountdown(Math.max(0, remaining));
        }
      } else {
        setErrorMessage(response.data.error || 'خطا در ارسال کد تایید');
      }
    } catch (error: any) {
      console.error('Send verification code error:', error);
      setErrorMessage(error.response?.data?.error || 'خطا در ارسال کد تایید');
    } finally {
      setSendingCode(false);
    }
  };

  const handleVerifyCode = async () => {
    if (!wizardData.signature?.verificationCode || wizardData.signature.verificationCode.length !== 6) {
      setErrorMessage('لطفاً کد تایید 6 رقمی را وارد کنید');
      return;
    }

    if (!wizardData.signature?.contractId || !wizardData.signature?.phoneNumber) {
      setErrorMessage('اطلاعات ناقص است');
      return;
    }

    setVerifyingCode(true);
    setErrorMessage(null);

    try {
      const response = await salesAPI.verifyCode(
        wizardData.signature.contractId,
        wizardData.signature.verificationCode,
        wizardData.signature.phoneNumber
      );

      if (response.data.success && response.data.verified) {
        setWizardData(prev => ({
          ...prev,
          signature: {
            ...prev.signature!,
            codeVerified: true
          }
        }));
        setSuccessMessage('قرارداد با موفقیت تایید و امضا شد');
        
        // Redirect to contracts list after a short delay
        setTimeout(() => {
          router.push('/dashboard/sales/contracts');
        }, 2000);
      } else {
        setErrorMessage(response.data.error || 'کد تایید اشتباه است');
      }
    } catch (error: any) {
      console.error('Verify code error:', error);
      setErrorMessage(error.response?.data?.error || 'خطا در تایید کد');
    } finally {
      setVerifyingCode(false);
    }
  };

  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getPhoneTypeLabel = (type: string): string => {
    const labels: Record<string, string> = {
      mobile: 'موبایل',
      home: 'منزل',
      work: 'محل کار',
      other: 'سایر'
    };
    return labels[type] || type;
  };

  // Payment entry management functions
  const handleAddPaymentEntry = () => {
    setEditingPaymentEntryId(null);
    // Calculate remaining amount to auto-suggest
    const existingPaymentsSum = wizardData.payment.payments.reduce((sum, p) => sum + p.amount, 0);
    const remainingAmount = wizardData.payment.totalContractAmount - existingPaymentsSum;
    setPaymentEntryForm({
      method: 'CASH',
      status: 'WILL_BE_PAID',
      paymentDate: getCurrentPersianDate(),
      amount: remainingAmount > 0 ? remainingAmount : 0,
      cashType: undefined,
      checkNumber: undefined,
      nationalCode: undefined
    });
    setShowPaymentEntryModal(true);
  };

  const handleEditPaymentEntry = (entryId: string) => {
    const entry = wizardData.payment.payments.find(p => p.id === entryId);
    if (entry) {
      setEditingPaymentEntryId(entryId);
      setPaymentEntryForm({ ...entry });
      setShowPaymentEntryModal(true);
    }
  };

  const handleSavePaymentEntry = () => {
    // Validate required fields
    if (!paymentEntryForm.method || !paymentEntryForm.amount || paymentEntryForm.amount <= 0 || !paymentEntryForm.status || !paymentEntryForm.paymentDate) {
      setErrors({ paymentMethod: 'لطفاً تمام فیلدهای الزامی را پر کنید' });
      return;
    }

    // Validate conditional fields
    if (paymentEntryForm.method === 'CHECK' && !paymentEntryForm.checkNumber) {
      setErrors({ paymentMethod: 'شماره چک برای پرداخت چکی الزامی است' });
      return;
    }

    if (paymentEntryForm.method === 'CHECK' && !paymentEntryForm.nationalCode) {
      setErrors({ paymentMethod: 'کد ملی برای پرداخت چکی الزامی است' });
      return;
    }

    if (paymentEntryForm.method === 'CASH' && !paymentEntryForm.cashType) {
      setErrors({ paymentMethod: 'نوع پرداخت نقدی الزامی است' });
      return;
    }

    const entry: PaymentEntry = {
      id: editingPaymentEntryId || `payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      method: paymentEntryForm.method as 'CASH' | 'CHECK',
      amount: paymentEntryForm.amount,
      status: paymentEntryForm.status as 'PAID' | 'WILL_BE_PAID',
      paymentDate: paymentEntryForm.paymentDate!,
      description: paymentEntryForm.description,
      nationalCode: paymentEntryForm.nationalCode,
      checkNumber: paymentEntryForm.checkNumber,
      cashType: paymentEntryForm.cashType
    };

    const updatedPayments = editingPaymentEntryId
      ? wizardData.payment.payments.map(p => p.id === editingPaymentEntryId ? entry : p)
      : [...wizardData.payment.payments, entry];

    updateWizardData({
      payment: {
        ...wizardData.payment,
        payments: updatedPayments
      }
    });

    const getCurrentPersianDate = () => {
      try {
        const date = PersianCalendar.now('jYYYY/jMM/jDD');
        if (date && date.match(/^\d{4}\/\d{2}\/\d{2}$/)) {
          return date;
        }
      } catch (error) {
        console.error('Error getting Persian date:', error);
      }
      return '1403/01/01';
    };

    setShowPaymentEntryModal(false);
    setEditingPaymentEntryId(null);
    setPaymentEntryForm({
      method: 'CASH',
      status: 'WILL_BE_PAID',
      paymentDate: '',
      amount: 0
    });
    setErrors({});
  };

  const handleDeletePaymentEntry = (entryId: string) => {
    const updatedPayments = wizardData.payment.payments.filter(p => p.id !== entryId);
    updateWizardData({
      payment: {
        ...wizardData.payment,
        payments: updatedPayments
      }
    });
  };

  // Calculate payment sum
  const paymentSum = useMemo(() => {
    return wizardData.payment.payments.reduce((sum, p) => sum + p.amount, 0);
  }, [wizardData.payment.payments]);

  // Calculate remaining amount
  const remainingAmount = useMemo(() => {
    return wizardData.payment.totalContractAmount - paymentSum;
  }, [wizardData.payment.totalContractAmount, paymentSum]);

  // Check if payment sum matches contract total
  const paymentSumMatchesTotal = Math.abs(paymentSum - wizardData.payment.totalContractAmount) < 0.01;

  const serviceEntries = useMemo(() => {
    const entries: ServiceEntry[] = [];
    wizardData.products.forEach((product, productIndex) => {
      const productLabel = product.stoneName || product.product?.namePersian || product.product?.name || `محصول ${productIndex + 1}`;

      if (product.appliedSubServices && product.appliedSubServices.length > 0) {
        product.appliedSubServices.forEach((applied, appliedIndex) => {
          const unitLabel = applied.calculationBase === 'squareMeters' ? 'متر مربع' : 'متر';
          const amountLabel = `${formatDisplayNumber(applied.meter || 0)} ${unitLabel}`;
          entries.push({
            key: `tool-${productIndex}-${appliedIndex}-${applied.id}`,
            type: 'tool',
            productName: productLabel,
            description: applied.subService?.namePersian || applied.subService?.name || 'ابزار',
            amountLabel,
            cost: applied.cost || 0,
            meta: {
              rateLabel: applied.subService?.pricePerMeter
                ? `${formatPrice(applied.subService.pricePerMeter, 'تومان')}/${unitLabel}`
                : undefined
            }
          });
        });
      }

      if (product.finishingId && product.finishingCost) {
        entries.push({
          key: `finishing-${productIndex}`,
          type: 'finishing',
          productName: productLabel,
          description: product.finishingName || 'پرداخت سنگ',
          amountLabel: `${formatSquareMeters(product.finishingSquareMeters || product.squareMeters || 0)}`,
          cost: product.finishingCost || 0,
          meta: product.finishingPricePerSquareMeter
            ? {
                rateLabel: `${formatPrice(product.finishingPricePerSquareMeter, 'تومان')}/متر مربع`
              }
            : undefined
        });
      }

      const isLayerProduct = Boolean((product.meta as any)?.isLayer);
      if (isLayerProduct) {
        const layerMeta = (product.meta as any) || {};
        const descriptionParts: string[] = [];
        if (layerMeta.layer?.numberOfLayersPerStair) {
          const parentPartType = (layerMeta.layer.parentPartType || 'tread') as StairStepperPart;
          descriptionParts.push(`${layerMeta.layer.numberOfLayersPerStair} لایه برای هر ${getPartDisplayLabel(parentPartType)}`);
        }
        if (layerMeta.layer?.layerTypeName) {
          descriptionParts.push(`نوع لایه: ${layerMeta.layer.layerTypeName}`);
        }
        if (product.layerUseDifferentStone && product.layerStoneName) {
          descriptionParts.push(`سنگ: ${product.layerStoneName}`);
        }
        entries.push({
          key: `layer-${productIndex}`,
          type: 'layer',
          productName: productLabel,
          description: descriptionParts.length ? descriptionParts.join(' | ') : 'لایه اضافه',
          amountLabel: `${formatDisplayNumber(product.quantity || 0)} عدد | ${formatSquareMeters(product.squareMeters || 0)}`,
          cost: typeof product.totalPrice === 'number' ? product.totalPrice : parseFloat(String(product.totalPrice || '0')) || 0,
          meta: product.layerUseDifferentStone && product.layerStonePricePerSquareMeter
            ? {
                rateLabel: `${formatPrice(product.layerStonePricePerSquareMeter, 'تومان')}/متر مربع${
                  product.layerUseMandatory && product.layerMandatoryPercentage
                    ? ` (حکمی ${formatDisplayNumber(product.layerMandatoryPercentage)}%)`
                    : ''
                }`
              }
            : undefined
        });
      }

      if (product.isCut && (product.cuttingBreakdown?.length || product.cuttingCost)) {
        const breakdown = product.cuttingBreakdown && product.cuttingBreakdown.length > 0
          ? product.cuttingBreakdown
          : [{
              type: product.cutType || 'longitudinal',
              meters: (product.lengthUnit === 'm' ? product.length : (product.length || 0) / 100) * (product.quantity || 1),
              rate: product.cuttingCostPerMeter || 0,
              cost: product.cuttingCost || 0
            }];
        
        // Count cross cuts to determine if we should use "برش کله بر"
        const crossCuts = breakdown.filter(cut => cut.type === 'cross');
        const hasOnlyOneCrossCut = crossCuts.length === 1 && breakdown.length === 1;
        
        breakdown.forEach((cut, cutIndex) => {
          const metersLabel = `${formatDisplayNumber(cut.meters || 0)} متر`;
          // Use "برش کله بر" if there's only 1 cross cut, otherwise use "برش عرضی"
          const cutDescription = cut.type === 'cross' 
            ? (hasOnlyOneCrossCut ? 'برش کله بر' : 'برش عرضی')
            : 'برش طولی';
          entries.push({
            key: `cut-${productIndex}-${cutIndex}`,
            type: 'cut',
            productName: productLabel,
            description: cutDescription,
            amountLabel: metersLabel,
            cost: cut.cost || 0,
            meta: {
              rateLabel: cut.rate ? `${formatPrice(cut.rate, 'تومان')}/متر` : undefined
            }
          });
        });
      }

      const partitionCuts = (product.usedRemainingStones || []).filter(rs =>
        rs.position && rs.id.startsWith('partition_remaining_') && rs.cuttingCost && rs.cuttingCost > 0
      );
      partitionCuts.forEach((partition, partitionIndex) => {
        entries.push({
          key: `cut-partition-${productIndex}-${partitionIndex}`,
          type: 'cut',
          productName: `${productLabel} (پارتیشن)`,
          description: partition.cutType === 'cross' ? 'برش عرضی باقی‌مانده' : 'برش طولی باقی‌مانده',
          amountLabel: `${formatDisplayNumber(partition.length * (partition.quantity || 1))} متر`,
          cost: partition.cuttingCost || 0,
          meta: {
            rateLabel: partition.cuttingCostPerMeter ? `${formatPrice(partition.cuttingCostPerMeter, 'تومان')}/متر` : undefined
          }
        });
      });
    });
    return entries;
  }, [wizardData.products]);

  const serviceTotals = useMemo(() => {
    return serviceEntries.reduce((acc, entry) => {
      acc.total += entry.cost || 0;
      acc.counts[entry.type] = (acc.counts[entry.type] || 0) + 1;
      acc.amounts[entry.type] = (acc.amounts[entry.type] || 0) + (entry.cost || 0);
      return acc;
    }, {
      total: 0,
      counts: { tool: 0, layer: 0, cut: 0, finishing: 0 } as Record<'tool' | 'layer' | 'cut' | 'finishing', number>,
      amounts: { tool: 0, layer: 0, cut: 0, finishing: 0 } as Record<'tool' | 'layer' | 'cut' | 'finishing', number>
    });
  }, [serviceEntries]);

  const productPriceEntries = useMemo(() => {
    return wizardData.products.map((product, index) => {
      const isLayer = Boolean((product.meta as any)?.isLayer);
      let partLabel =
        product.productType === 'stair'
          ? (isLayer
              ? `لایه ${getPartDisplayLabel(product.stairPartType as StairStepperPart)}`
              : getPartDisplayLabel(product.stairPartType as StairStepperPart))
          : (product.productType === 'longitudinal'
              ? 'طولی'
              : product.productType === 'slab'
                ? 'اسلب'
                : 'محصول');
      
      // Append "/حکمی" if mandatory option is activated
      if (product.isMandatory && product.mandatoryPercentage && product.mandatoryPercentage > 0) {
        partLabel = `${partLabel}/حکمی`;
      }
      const pricePerSqmValue = product.pricePerSquareMeter || null;
      const totalPriceValue = typeof product.totalPrice === 'number'
        ? product.totalPrice
        : parseFloat(String(product.totalPrice || '0')) || 0;
      // 🎯 For layer products, get stone area used from meta
      const layerMeta = isLayer ? (product.meta as any) : null;
      const stoneAreaUsedSqm = layerMeta?.stoneAreaUsedSqm;
      return {
        key: `product-price-${index}-${product.productId}`,
        name: product.stoneName || product.product?.namePersian || product.product?.name || `محصول ${index + 1}`,
        partLabel,
        quantity: product.quantity || 0,
        squareMeters: product.squareMeters || 0, // متر مربع استفاده شده
        stoneAreaUsedSqm: stoneAreaUsedSqm || null, // متر مربع اصلی (for layer products)
        isLayer,
        pricePerSquareMeter: pricePerSqmValue,
        totalPrice: totalPriceValue
      };
    });
  }, [wizardData.products]);

  const serviceTypeMeta: Record<'tool' | 'layer' | 'cut' | 'finishing', { label: string; badgeClass: string; chipClass: string }> = {
    tool: {
      label: 'ابزار',
      badgeClass: 'bg-purple-100 text-purple-800 dark:bg-purple-900/40 dark:text-purple-200',
      chipClass: 'bg-purple-50 dark:bg-purple-900/20 text-purple-700 dark:text-purple-200 border border-purple-200 dark:border-purple-800'
    },
    layer: {
      label: 'لایه',
      badgeClass: 'bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200',
      chipClass: 'bg-amber-50 dark:bg-amber-900/20 text-amber-700 dark:text-amber-200 border border-amber-200 dark:border-amber-800'
    },
    cut: {
      label: 'برش',
      badgeClass: 'bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-200',
      chipClass: 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-200 border border-blue-200 dark:border-blue-800'
    },
    finishing: {
      label: 'پرداخت',
      badgeClass: 'bg-teal-100 text-teal-800 dark:bg-teal-900/40 dark:text-teal-200',
      chipClass: 'bg-teal-50 dark:bg-teal-900/20 text-teal-700 dark:text-teal-200 border border-teal-200 dark:border-teal-700'
    }
  };

  const contractGrandTotal = productsSummary.totalPrice;
  const hasInvoiceData = wizardData.products.length > 0 || serviceEntries.length > 0;


  // Load data
  const [customers, setCustomers] = useState<CrmCustomer[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [departments, setDepartments] = useState<any[]>([]);
  const [userDepartment, setUserDepartment] = useState<string | null>(null);
  const [currentUser, setCurrentUser] = useState<{ firstName: string; lastName: string } | null>(null);
  const [cuttingTypes, setCuttingTypes] = useState<Array<{ code: string; pricePerMeter: number | null }>>([]);

  // Filtered data based on search terms
  const filteredCustomers = useMemo(() => {
    if (!customerSearchTerm.trim()) {
      // Show only last 2 customers as preview when no search term
      return customers.slice(0, 2);
    }
    
    // Show full filtered list when searching
    const searchLower = customerSearchTerm.toLowerCase();
    return customers.filter(customer => 
      customer.firstName.toLowerCase().includes(searchLower) ||
      customer.lastName.toLowerCase().includes(searchLower) ||
      (customer.companyName && customer.companyName.toLowerCase().includes(searchLower)) ||
      (customer.nationalCode && customer.nationalCode.includes(searchLower)) ||
      (customer.homeNumber && customer.homeNumber.includes(searchLower)) ||
      (customer.workNumber && customer.workNumber.includes(searchLower)) ||
      (customer.phoneNumbers && customer.phoneNumbers.some(phone => 
        phone.number.includes(searchLower) || 
        phone.number.replace(/\s+/g, '').includes(searchLower.replace(/\s+/g, ''))
      ))
    );
  }, [customers, customerSearchTerm]);

  const filteredProducts = useMemo(() => {
    // Require search term to show products - no preview of latest products
    if (!productSearchTerm.trim()) {
      return [];
    }
    
    const selectedType = wizardData.selectedProductTypeForAddition as ContractUsageType | null;
    const eligibleProducts = selectedType
      ? products.filter(product => productSupportsContractType(product, selectedType))
      : products;
    
    const searchLower = productSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    
    return eligibleProducts.filter(product => {
      // Create a comprehensive search string that includes all searchable fields
      const searchableFields = [
        product.code,
        product.namePersian,
        product.name,
        product.cuttingDimensionNamePersian,
        product.stoneTypeNamePersian,
        product.widthName,
        product.thicknessName,
        product.mineNamePersian,
        product.finishNamePersian,
        product.colorNamePersian,
        product.qualityNamePersian,
        product.description,
        product.currency,
        // Include numeric values as strings for searching
        product.widthValue?.toString(),
        product.thicknessValue?.toString(),
        product.basePrice?.toString(),
        // Include dimension combinations
        `${product.widthValue}×${product.thicknessValue}`,
        `عرض ${product.widthValue}×ضخامت ${product.thicknessValue}`,
        // Include full product name generation
        `${product.stoneTypeNamePersian} ${product.cuttingDimensionNamePersian} عرض ${product.widthValue}×ضخامت ${product.thicknessValue}cm ${product.mineNamePersian} ${product.finishNamePersian} ${product.colorNamePersian} ${product.qualityNamePersian}`
      ].filter(Boolean);
      
      // Create a single searchable text
      const searchableText = searchableFields.join(' ').toLowerCase();
      
      // If only one search term, use simple includes
      if (searchTerms.length === 1) {
        return searchableText.includes(searchTerms[0]);
      }
      
      // If multiple search terms, all must be found (AND logic)
      return searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, productSearchTerm, wizardData.selectedProductTypeForAddition]);
  
  // Filtered products for each stair part (independent product selection)
  const filteredTreadProducts = useMemo(() => {
    const stairEligibleProducts = products.filter(product => productSupportsContractType(product, 'stair'));
    if (!treadProductSearchTerm.trim()) {
      return stairEligibleProducts.slice(-3);
    }
    const searchLower = treadProductSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    return stairEligibleProducts.filter(product => {
      const searchableFields = [
        product.code, product.namePersian, product.name,
        product.cuttingDimensionNamePersian, product.stoneTypeNamePersian,
        product.widthName, product.thicknessName, product.mineNamePersian,
        product.finishNamePersian, product.colorNamePersian, product.qualityNamePersian,
        product.widthValue?.toString(), product.thicknessValue?.toString(),
        product.basePrice?.toString()
      ].filter(Boolean);
      const searchableText = searchableFields.join(' ').toLowerCase();
      return searchTerms.length === 1 
        ? searchableText.includes(searchTerms[0])
        : searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, treadProductSearchTerm]);
  
  const filteredRiserProducts = useMemo(() => {
    const stairEligibleProducts = products.filter(product => productSupportsContractType(product, 'stair'));
    if (!riserProductSearchTerm.trim()) {
      return stairEligibleProducts.slice(-3);
    }
    const searchLower = riserProductSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    return stairEligibleProducts.filter(product => {
      const searchableFields = [
        product.code, product.namePersian, product.name,
        product.cuttingDimensionNamePersian, product.stoneTypeNamePersian,
        product.widthName, product.thicknessName, product.mineNamePersian,
        product.finishNamePersian, product.colorNamePersian, product.qualityNamePersian,
        product.widthValue?.toString(), product.thicknessValue?.toString(),
        product.basePrice?.toString()
      ].filter(Boolean);
      const searchableText = searchableFields.join(' ').toLowerCase();
      return searchTerms.length === 1 
        ? searchableText.includes(searchTerms[0])
        : searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, riserProductSearchTerm]);
  
  const filteredLandingProducts = useMemo(() => {
    const stairEligibleProducts = products.filter(product => productSupportsContractType(product, 'stair'));
    if (!landingProductSearchTerm.trim()) {
      return stairEligibleProducts.slice(-3);
    }
    const searchLower = landingProductSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    return stairEligibleProducts.filter(product => {
      const searchableFields = [
        product.code, product.namePersian, product.name,
        product.cuttingDimensionNamePersian, product.stoneTypeNamePersian,
        product.widthName, product.thicknessName, product.mineNamePersian,
        product.finishNamePersian, product.colorNamePersian, product.qualityNamePersian,
        product.widthValue?.toString(), product.thicknessValue?.toString(),
        product.basePrice?.toString()
      ].filter(Boolean);
      const searchableText = searchableFields.join(' ').toLowerCase();
      return searchTerms.length === 1 
        ? searchableText.includes(searchTerms[0])
        : searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, landingProductSearchTerm]);

  useEffect(() => {
    loadInitialData();
    
    // Check for return from quick create
    const urlParams = new URLSearchParams(window.location.search);
    const returnTo = urlParams.get('returnTo');
    const step = urlParams.get('step');
    
    console.log('🔍 Contract wizard useEffect triggered:', {
      returnTo,
      step,
      currentStep,
      stateRestored
    });
    
    if (returnTo === 'contract' && step && !restorationAttempted.current) {
      // Restore wizard state from localStorage
      const savedState = localStorage.getItem('contractWizardState');
      console.log('💾 Saved state from localStorage:', savedState);
      
      if (savedState) {
        try {
          const { currentStep: savedStep, wizardData: savedWizardData } = JSON.parse(savedState);
          console.log('🔄 Restoring wizard state:', {
            urlStep: step,
            savedStep,
            savedWizardData,
            currentStepBeforeRestore: currentStep
          });
          
          // Use the saved step instead of URL step parameter
          setCurrentStep(savedStep);
          setWizardData(savedWizardData);
          setStateRestored(true);
          restorationAttempted.current = true;
          
          // Clear the saved state after successful restoration
          localStorage.removeItem('contractWizardState');
          
          // Refresh data to show newly created entities
          console.log('🔄 Refreshing data after successful creation...');
          loadInitialData();
          
          console.log('✅ Wizard state restored successfully to step:', savedStep);
        } catch (error) {
          console.error('❌ Error restoring wizard state:', error);
          // If restoration fails, use URL step as fallback
          setCurrentStep(parseInt(step));
          setStateRestored(true);
          restorationAttempted.current = true;
          
          // Refresh data to show newly created entities
          console.log('🔄 Refreshing data after successful creation (fallback)...');
          loadInitialData();
        }
      } else {
        // If no saved state, use URL step as fallback
        console.log('⚠️ No saved state found, using URL step:', step);
        setCurrentStep(parseInt(step));
        setStateRestored(true);
        restorationAttempted.current = true;
        
        // Refresh data to show newly created entities
        console.log('🔄 Refreshing data after successful creation (no saved state)...');
        loadInitialData();
      }
    }
  }, []);


  // Debug effect to track currentStep changes
  useEffect(() => {
    console.log('📊 currentStep changed to:', currentStep);
  }, [currentStep]);

  const loadInitialData = async () => {
    try {
      setLoading(true);
      
      // Load user profile to get department and user info
      const profileResponse = await dashboardAPI.getProfile();
      if (profileResponse.data.success) {
        const userData = profileResponse.data.data;
        setUserDepartment(userData.departmentId);
        setCurrentUser({
          firstName: userData.firstName || '',
          lastName: userData.lastName || ''
        });
        console.log('User department:', userData.departmentId);
        console.log('Current user:', userData.firstName, userData.lastName);
      }
      
      // Load customers from CRM
      const customersResponse = await crmAPI.getCustomers();
      if (customersResponse.data.success) {
        setCustomers(customersResponse.data.data);
      }
      
      // Load ALL products from Sales (no pagination for contract wizard)
      const productsResponse = await salesAPI.getProducts({ limit: 1000 });
      if (productsResponse.data.success) {
        setProducts(productsResponse.data.data);
        console.log('All products loaded for contract wizard:', productsResponse.data.data.length);
      }
      
      // Load departments
      const departmentsResponse = await salesAPI.getDepartments();
      console.log('Departments response:', departmentsResponse.data);
      if (departmentsResponse.data.success) {
        setDepartments(departmentsResponse.data.data);
        console.log('Departments loaded:', departmentsResponse.data.data);
      }
      
      // Load cutting types (for automatic cutting cost calculation)
      const cuttingTypesResponse = await servicesAPI.getCuttingTypes({ isActive: true });
      if (cuttingTypesResponse.data.success) {
        setCuttingTypes(cuttingTypesResponse.data.data);
        console.log('Cutting types loaded:', cuttingTypesResponse.data.data);
      }
      
  // Load sub-services (ابزارها) - load all active ones with high limit
      const subServicesResponse = await servicesAPI.getSubServices({ isActive: true, limit: 1000 });
      if (subServicesResponse.data.success) {
        setSubServices(subServicesResponse.data.data);
        console.log('Sub-services loaded:', subServicesResponse.data.data.length, 'items');
      } else {
        console.error('Failed to load sub-services:', subServicesResponse.data);
      }

      // Load stone finishings (پرداخت‌ها)
      const finishingsResponse = await servicesAPI.getStoneFinishings({ isActive: true, limit: 1000 });
      if (finishingsResponse.data.success) {
        setStoneFinishings(finishingsResponse.data.data);
        console.log('Stone finishings loaded:', finishingsResponse.data.data.length, 'items');
      } else {
        console.error('Failed to load stone finishings:', finishingsResponse.data);
      }
      
      // Generate next contract number
      await generateContractNumber();
      
    } catch (error) {
      console.error('Error loading initial data:', error);
      setErrors({ general: 'خطا در بارگذاری اطلاعات اولیه' });
    } finally {
      setLoading(false);
    }
  };

  const generateContractNumber = async () => {
    try {
      // Get next contract number from backend
      const response = await salesAPI.getNextContractNumber();
      if (response.data.success) {
        setWizardData(prev => ({
          ...prev,
          contractNumber: response.data.data.contractNumber
        }));
      }
    } catch (error) {
      console.error('Error generating contract number:', error);
      // Fallback to manual generation
      const contractCount = Math.floor(Math.random() * 1000) + 1000;
      setWizardData(prev => ({
        ...prev,
        contractNumber: String(contractCount)
      }));
    }
  };

  const updateWizardData = (updates: Partial<ContractWizardData>) => {
    console.log('=== updateWizardData called with:', updates, '===');
    setWizardData(prev => {
      const newData = { ...prev, ...updates };
      console.log('New wizardData:', newData);
      console.log('=== updateWizardData completed ===');
      return newData;
    });
  };

  // Helper function to update stair system config
  const updateStairSystemConfig = (updates: Partial<StairSystemConfig> | ((prev: StairSystemConfig | null) => StairSystemConfig | null)) => {
    setStairSystemConfig(prev => {
      if (!prev) return prev;
      if (typeof updates === 'function') {
        return updates(prev);
      }
      return { ...prev, ...updates };
    });
  };
  
  // Helper function to update a specific stair part
  const updateStairPart = (partType: 'tread' | 'riser' | 'landing', updates: Partial<StairPart>) => {
    setStairSystemConfig(prev => {
      if (!prev) return prev;
      return {
        ...prev,
        [partType]: { ...prev[partType], ...updates }
      };
    });
  };
  
  const syncDraftWithProduct = (partType: 'tread' | 'riser' | 'landing', product: Product | null) => {
    const updater =
      partType === 'tread' ? setDraftTread :
      partType === 'riser' ? setDraftRiser :
      setDraftLanding;

    // 🎯 Use generateFullProductName to show complete product name
    const productLabel = product ? generateFullProductName(product) : '';
    updater(prev => ({
      ...prev,
      stoneId: product ? product.id : null,
      stoneLabel: productLabel,
      stoneProduct: product,
      pricePerSquareMeter: product ? (product.basePrice || (product as any).pricePerSquareMeter || 0) : null,
      thicknessCm: product ? (product.thicknessValue ?? null) : null
    }));

    if (product) {
      setLastSelectedStoneProduct(product);
      setAutoFillOptOut(prev => ({ ...prev, [partType]: false }));
      setStairDraftErrors(prev => ({
        ...prev,
        [partType]: {
          ...prev[partType],
          thickness: undefined,
          pricePerSquareMeter: undefined
        }
      }));
    } else {
      setAutoFillOptOut(prev => ({ ...prev, [partType]: true }));
    }

    if (productLabel) {
      setLastSelectedStoneLabel(productLabel);
    }

    if (stairActivePart === partType) {
      setStoneSearchTerm(productLabel || lastSelectedStoneLabel);
    }
  };

  const setActivePart = (part: StairStepperPart) => {
    setStairActivePartState(part);
    const currentDraft =
      part === 'tread' ? draftTread :
      part === 'riser' ? draftRiser :
      draftLanding;
    if (!currentDraft.stoneId && lastSelectedStoneProduct && !autoFillOptOut[part]) {
      selectProductForStairPart(part, lastSelectedStoneProduct);
    }
    // Note: Search term will be synced via useEffect below to ensure we read latest state
  };

  // Sync search term when active part changes - ensures we read latest draft state
  // This ensures each part maintains its own product selection independently
  useEffect(() => {
    // Get the draft for the currently active part
    const draft = 
      stairActivePart === 'tread' ? draftTread :
      stairActivePart === 'riser' ? draftRiser :
      draftLanding;
    
    // Extract the product label from the draft
    // Priority: stoneLabel (explicitly set with full name) > generateFullProductName from stoneProduct > fallback
    const label = draft.stoneLabel || 
                  (draft.stoneProduct ? generateFullProductName(draft.stoneProduct) : '') ||
                  draft.stoneProduct?.namePersian || 
                  draft.stoneProduct?.name || '';
    
    // Update search term to reflect the active part's product selection
    // This ensures when switching parts, the search term shows the product for that part
    setStoneSearchTerm(label);
  }, [
    stairActivePart,
    // Track all draft changes - React will optimize, but we need to react to any part's changes
    // when switching to that part, we want the latest state
    draftTread.stoneProduct?.id,
    draftTread.stoneLabel,
    draftRiser.stoneProduct?.id,
    draftRiser.stoneLabel,
    draftLanding.stoneProduct?.id,
    draftLanding.stoneLabel
  ]);

  // Helper function to select a product for a specific stair part
  const selectProductForStairPart = (partType: 'tread' | 'riser' | 'landing', product: Product) => {
    updateStairPart(partType, {
      productId: product.id,
      product: product,
      pricePerSquareMeter: product.basePrice || 0
    });
    syncDraftWithProduct(partType, product);
  };
  
  // Handle product selection and open configuration modal
  const handleProductSelection = (product: Product) => {
    console.log('🎯 Product Selected:', {
      id: product.id,
      name: product.namePersian,
      widthValue: product.widthValue,
      code: product.code,
      basePrice: product.basePrice,
      productType: wizardData.selectedProductTypeForAddition
    });
    
    setSelectedProduct(product);
    
    const selectedProductType = wizardData.selectedProductTypeForAddition;
    
    // Initialize product configuration based on product type
    if (selectedProductType === 'stair') {
      // Check if using new V2 flow
      if (useStairFlowV2) {
        // NEW V2 FLOW: Pre-fill the selected product in the active draft
        const [currentDraft, setCurrentDraft] = getActiveDraft();
        const productLabel = product.namePersian || product.name || '';
        
        // Pre-fill the active draft with selected product
        setCurrentDraft({
          ...currentDraft,
          stoneId: product.id,
          stoneLabel: productLabel,
          stoneProduct: product,
          pricePerSquareMeter: product.basePrice || 0,
          thicknessCm: product.thicknessValue || null // قطر = ضخامت (thickness), not عرض (width)
        });
        
        // Pre-fill search term to show the selected product
        setStoneSearchTerm(productLabel);
        
        // Set product config for modal type detection
        setProductConfig({
          productId: product.id,
          product: product,
          productType: 'stair'
        });
      } else {
        // OLD FLOW: Initialize for stair system (دستگاه پله)
        const stairConfig = initializeStairSystemConfig(product);
        setStairSystemConfig(stairConfig);
        
        // Also set old config for backward compatibility (will be removed later)
        const defaultConfig: Partial<ContractProduct> = {
          productId: product.id,
          product: product,
          productType: 'stair',
          stoneCode: product.code,
          stoneName: product.namePersian,
          diameterOrWidth: product.widthValue,
          length: 0,
          width: 0,
          quantity: 1,
          squareMeters: 0,
          pricePerSquareMeter: product.basePrice || 0,
          totalPrice: 0,
          description: '',
          currency: 'تومان',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: false,
          mandatoryPercentage: 20,
          originalTotalPrice: 0,
          isCut: false,
          cutType: null,
          originalWidth: product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0
        };
        setProductConfig(defaultConfig);
        setTreadWidthUnit('m');
        setQuantityType('steps');
        // Reset collapsible sections
        setTreadExpanded(true);
        setRiserExpanded(true);
        setLandingExpanded(false);
        // Reset product search terms
        setTreadProductSearchTerm('');
        setRiserProductSearchTerm('');
        setLandingProductSearchTerm('');
      }
    } else if (selectedProductType === 'slab') {
      // Initialize for slab stone
      const defaultStandardWidthCm = product.widthValue || 0;
      const defaultStandardLengthCm = (product as any)?.lengthValue || 300;
      const defaultOriginalLength = lengthUnit === 'm'
        ? defaultStandardLengthCm / 100
        : defaultStandardLengthCm;
      const defaultConfig: Partial<ContractProduct> = {
        productId: product.id,
        product: product,
        productType: 'slab',
        stoneCode: product.code,
        stoneName: product.namePersian,
        diameterOrWidth: product.widthValue, // Use product's width as constant
        length: 0,
        width: 0, // No default value - user must input
        quantity: 1,
        squareMeters: 0,
        pricePerSquareMeter: product.basePrice || 0,
        totalPrice: 0,
        description: '',
        currency: 'تومان',
        // Initialize stone cutting fields for 2D cutting
        isCut: false,
        originalWidth: defaultStandardWidthCm,
        originalLength: defaultOriginalLength,
        cuttingCost: 0,
        cuttingCostPerMeter: 0,
        remainingStones: [],
        cutDetails: [],
        // Legacy single standard dimension fields (kept for backward compatibility)
        slabStandardLengthCm: defaultStandardLengthCm,
        slabStandardWidthCm: defaultStandardWidthCm,
        // New multiple standard dimensions support
        slabStandardDimensions: [],
        slabCuttingMode: 'lineBased',
        slabCuttingPricePerSquareMeter: 0,
        slabLineCuttingStrategy: 'length',
        slabLineCuttingLongitudinalMeters: null,
        slabLineCuttingCrossMeters: null,
        // Initialize برش قائم (vertical edge cuts) - all 4 sides active by default
        slabVerticalCutSides: {
          top: true,
          bottom: true,
          left: true,
          right: true
        },
        slabVerticalCutCost: 0,
        slabVerticalCutCostPerMeter: 0,
        // Initialize remaining stone tracking
        usedRemainingStones: [],
        totalUsedRemainingWidth: 0,
        totalUsedRemainingLength: 0,
        // Initialize SubService tracking
        appliedSubServices: [],
        totalSubServiceCost: 0,
        usedLengthForSubServices: 0,
        usedSquareMetersForSubServices: 0
      };
      
      setProductConfig(defaultConfig);
      setLengthUnit('m');
      setWidthUnit('cm');
    } else {
      // Initialize for longitudinal stone (existing logic)
      const defaultConfig: Partial<ContractProduct> = {
        productId: product.id,
        product: product,
        productType: 'longitudinal',
        stoneCode: product.code,
        stoneName: product.namePersian,
        diameterOrWidth: product.widthValue, // Use product's width as constant
        length: 0,
        width: 0, // No default value - user must input
        quantity: 1,
        squareMeters: 0,
        pricePerSquareMeter: product.basePrice || 0,
        totalPrice: 0,
        description: '',
        currency: 'تومان', // Change from Rial to Toman
        // Initialize stone cutting fields
        isCut: false,
        originalWidth: product.widthValue,
        originalLength: 0, // Will be set when user enters length
        cuttingCost: 0,
        cuttingCostPerMeter: 0,
        remainingStones: [],
        cutDetails: [],
        // Initialize remaining stone tracking
        usedRemainingStones: [],
        totalUsedRemainingWidth: 0,
        totalUsedRemainingLength: 0,
        // Initialize SubService tracking
        appliedSubServices: [],
        totalSubServiceCost: 0,
        usedLengthForSubServices: 0,
        usedSquareMetersForSubServices: 0
      };
      
      setProductConfig(defaultConfig);
      setLengthUnit('m');
      setWidthUnit('cm');
    }
    
    setIsEditMode(false);
    setEditingProductIndex(null);
    setHasQuantityBeenInteracted(false); // Reset quantity interaction tracking
    setTouchedFields(new Set()); // Reset touched fields for new product
    setErrors({}); // Clear errors when opening modal
    setShowProductModal(true);
    
    console.log('🎯 Modal State Initialized:', {
      productType: selectedProductType,
      pricePerSquareMeter: productConfig.pricePerSquareMeter
    });
  };

  // Handle unit conversion for length
  const handleLengthUnitChange = (newUnit: 'cm' | 'm') => {
    if (!productConfig.length) return;
    
    const currentLength = productConfig.length;
    let convertedLength = currentLength;
    
    if (lengthUnit === 'cm' && newUnit === 'm') {
      // Convert cm to m
      convertedLength = currentLength / 100;
    } else if (lengthUnit === 'm' && newUnit === 'cm') {
      // Convert m to cm
      convertedLength = currentLength * 100;
    }
    
    console.log('🔄 Length Unit Conversion:', {
      from: lengthUnit,
      to: newUnit,
      original: currentLength,
      converted: convertedLength
    });
    
    setLengthUnit(newUnit);
    setProductConfig(prev => {
      const updatedConfig = { ...prev, length: convertedLength };
      // Trigger smart calculation with new unit
      const smartResult = handleSmartCalculation('length', convertedLength, updatedConfig, newUnit, widthUnit, getEffectiveQuantity());
      console.log('🔄 Length Unit Change Result:', {
        originalLength: currentLength,
        convertedLength,
        newUnit,
        smartResult,
        finalSquareMeters: smartResult.squareMeters
      });
      return {
        ...updatedConfig,
        width: smartResult.width,
        squareMeters: smartResult.squareMeters
      };
    });
  };

  // Handle unit conversion for width
  const handleWidthUnitChange = (newUnit: 'cm' | 'm') => {
    if (!productConfig.width) return;
    
    const currentWidth = productConfig.width;
    let convertedWidth = currentWidth;
    
    if (widthUnit === 'cm' && newUnit === 'm') {
      // Convert cm to m
      convertedWidth = currentWidth / 100;
    } else if (widthUnit === 'm' && newUnit === 'cm') {
      // Convert m to cm
      convertedWidth = currentWidth * 100;
    }
    
    console.log('🔄 Width Unit Conversion:', {
      from: widthUnit,
      to: newUnit,
      original: currentWidth,
      converted: convertedWidth
    });
    
    // Validate width after unit conversion
    const originalWidth = (isEditMode && productConfig.originalWidth) 
      ? productConfig.originalWidth 
      : (selectedProduct?.widthValue || 0);
    
    if (convertedWidth > 0 && originalWidth > 0) {
      const convertedWidthInCm = newUnit === 'm' ? convertedWidth * 100 : convertedWidth;
      if (convertedWidthInCm > originalWidth) {
        // Show error message
        setErrors({ 
          products: `عرض وارد شده (${convertedWidth}${newUnit === 'm' ? 'm' : 'cm'}) بیشتر از عرض اصلی سنگ (${originalWidth}cm) است. لطفاً عرضی کمتر یا مساوی با ${originalWidth}cm وارد کنید.` 
        });
      } else {
        // Clear error if width is valid after unit conversion
        if (errors.products && errors.products.includes('عرض وارد شده')) {
          setErrors({});
        }
      }
    }
    
    setWidthUnit(newUnit);
    setProductConfig(prev => {
      const updatedConfig = { ...prev, width: convertedWidth };
      // Trigger smart calculation with new unit
      const smartResult = handleSmartCalculation('width', convertedWidth, updatedConfig, lengthUnit, newUnit, getEffectiveQuantity());
      console.log('🔄 Width Unit Change Result:', {
        originalWidth: currentWidth,
        convertedWidth,
        newUnit,
        smartResult,
        finalSquareMeters: smartResult.squareMeters
      });
      return {
        ...updatedConfig,
        length: smartResult.length,
        squareMeters: smartResult.squareMeters
      };
    });
    
    // Log stone cutting eligibility after unit change
    console.log('📏 Width Unit Changed:', {
      userWidth: convertedWidth,
      userWidthUnit: newUnit,
      userWidthInCm: newUnit === 'm' ? convertedWidth * 100 : convertedWidth
    });
  };

  // Handle unit conversion for remaining stone length
  const handleRemainingStoneLengthUnitChange = (newUnit: 'cm' | 'm') => {
    if (!remainingStoneConfig.length) return;
    
    const currentLength = remainingStoneConfig.length;
    let convertedLength = currentLength;
    
    if (remainingStoneLengthUnit === 'cm' && newUnit === 'm') {
      // Convert cm to m
      convertedLength = currentLength / 100;
    } else if (remainingStoneLengthUnit === 'm' && newUnit === 'cm') {
      // Convert m to cm
      convertedLength = currentLength * 100;
    }
    
    console.log('🔄 Remaining Stone Length Unit Conversion:', {
      from: remainingStoneLengthUnit,
      to: newUnit,
      original: currentLength,
      converted: convertedLength
    });
    
    setRemainingStoneLengthUnit(newUnit);
    setRemainingStoneConfig(prev => {
      const updatedConfig = { ...prev, length: convertedLength, width: selectedRemainingStone?.width || 0 };
      // Trigger smart calculation with new unit
      const smartResult = handleSmartCalculation('length', convertedLength, updatedConfig, newUnit, 'cm', getEffectiveQuantity());
      return {
        ...updatedConfig,
        squareMeters: smartResult.squareMeters
      };
    });
  };

  // Handle unit conversion for remaining stone width
  const handleRemainingStoneWidthUnitChange = (newUnit: 'cm' | 'm') => {
    if (!remainingStoneConfig.width) return;
    
    const currentWidth = remainingStoneConfig.width;
    let convertedWidth = currentWidth;
    
    if (remainingStoneWidthUnit === 'cm' && newUnit === 'm') {
      // Convert cm to m
      convertedWidth = currentWidth / 100;
    } else if (remainingStoneWidthUnit === 'm' && newUnit === 'cm') {
      // Convert m to cm
      convertedWidth = currentWidth * 100;
    }
    
    console.log('🔄 Remaining Stone Width Unit Conversion:', {
      from: remainingStoneWidthUnit,
      to: newUnit,
      original: currentWidth,
      converted: convertedWidth
    });
    
    setRemainingStoneWidthUnit(newUnit);
    setRemainingStoneConfig(prev => {
      const updatedConfig = { ...prev, width: convertedWidth, length: remainingStoneConfig.length || 0 };
      // Trigger smart calculation with new unit
      const smartResult = handleSmartCalculation('width', convertedWidth, updatedConfig, remainingStoneLengthUnit, newUnit, getEffectiveQuantity());
      return {
        ...updatedConfig,
        length: smartResult.length,
        squareMeters: smartResult.squareMeters
      };
    });
  };
  // Handle editing an existing product
  const handleEditProduct = (index: number) => {
    console.log('🔵 handleEditProduct called:', { index, totalProducts: wizardData.products.length });
    const product = wizardData.products[index];
    if (!product) {
      console.error('❌ Product not found at index:', index);
      return;
    }
    console.log('🔵 Product found:', { productType: product.productType, stairSystemId: product.stairSystemId });
    
    // Check if this is a stair system product
    if (product.productType === 'stair' && product.stairSystemId) {
      // Handle stair system editing
      // Find all products with the same stairSystemId
      const stairSystemProducts = wizardData.products.filter(p => 
        p.productType === 'stair' && 
        p.stairSystemId === product.stairSystemId
      );
      
      // Find tread, riser, and landing products (exclude layer products)
      const treadProduct = stairSystemProducts.find(p => 
        p.stairPartType === 'tread' && !((p.meta as any)?.isLayer)
      );
      const riserProduct = stairSystemProducts.find(p => 
        p.stairPartType === 'riser' && !((p.meta as any)?.isLayer)
      );
      const landingProduct = stairSystemProducts.find(p => 
        p.stairPartType === 'landing' && !((p.meta as any)?.isLayer)
      );
      
      // Check if using new V2 flow
      if (useStairFlowV2) {
        // NEW V2 FLOW: Reconstruct session items and drafts
        // Set session ID to existing stairSystemId
        setStairSessionId(product.stairSystemId);
        
        // Reconstruct session items from existing products
        setStairSessionItems([...stairSystemProducts]);
        
        // Helper function to convert ContractProduct to StairPartDraftV2
        const productToDraft = (p: ContractProduct, partType: StairStepperPart): StairPartDraftV2 => {
          const tools = (p.meta as any)?.tools || [];
          const layerInfo = (p.meta as any)?.layerInfo || null;
          // For layer products, extract layer info from meta
          // For regular products, layer info should be null
          const isLayer = (p.meta as any)?.isLayer || false;
          
          return {
            stoneId: p.productId,
            stoneLabel: p.stoneName,
            stoneProduct: p.product,
            pricePerSquareMeter: p.pricePerSquareMeter,
            useMandatory: typeof p.isMandatory === 'boolean' ? p.isMandatory : undefined,
            mandatoryPercentage: p.isMandatory
              ? (p.mandatoryPercentage || 20)
              : (p.mandatoryPercentage ?? null),
            thicknessCm: p.diameterOrWidth,
            lengthValue: p.length,
            lengthUnit: p.lengthUnit || 'm', // Default to meters for length
            widthCm: p.width,
            quantity: p.quantity,
            squareMeters: p.squareMeters,
            tools: tools.map((t: any) => ({
              toolId: t.toolId,
              name: t.name,
              pricePerMeter: t.pricePerMeter,
              front: t.edges?.front || false,
              left: t.edges?.left || false,
              right: t.edges?.right || false,
              back: t.edges?.back || false,
              perimeter: t.edges?.perimeter || false,
              computedMeters: t.computedMeters,
              totalPrice: t.totalPrice
            })),
            totalPrice: p.totalPrice,
            // Load layer fields if this is a layer product or if layer info exists
            // Note: layerPricePerSquareMeter is not needed - layers use the same price as the main stair part
            numberOfLayersPerStair: isLayer && layerInfo ? layerInfo.numberOfLayersPerStair : null,
            layerWidthCm: isLayer ? p.width : null,
            standardLengthValue: partType === 'riser'
              ? null
              : p.standardLengthValue ?? (p.meta as any)?.stair?.standardLength?.value ?? null,
            standardLengthUnit: partType === 'riser'
              ? (p.lengthUnit || 'm')
              : (p.standardLengthUnit as UnitType) ?? (p.meta as any)?.stair?.standardLength?.unit ?? (p.lengthUnit || 'm'),
            finishingEnabled: !!p.finishingId,
            finishingId: p.finishingId || null,
            finishingLabel: p.finishingName || null,
            finishingPricePerSquareMeter: p.finishingPricePerSquareMeter || null
          };
        };
        
        // Helper function to find and merge layer info into draft
        const mergeLayerInfo = (draft: StairPartDraftV2, partType: 'tread' | 'riser' | 'landing'): StairPartDraftV2 => {
          // Find layer product for this part type
          const layerProduct = stairSystemProducts.find(p => 
            (p.meta as any)?.isLayer && 
            (p.meta as any)?.layerInfo?.parentPartType === partType
          );
          
          if (layerProduct) {
            const layerInfo = (layerProduct.meta as any)?.layerInfo;
            const layerTypeMeta = (layerProduct.meta as any)?.layerType;
            const layerAltStoneMeta = (layerProduct.meta as any)?.layerAltStone;
            return {
              ...draft,
              numberOfLayersPerStair: layerInfo?.numberOfLayersPerStair || null,
              layerWidthCm: layerProduct.width || null,
              layerEdges: ((layerProduct.meta as any)?.layerEdges) || undefined,
              layerTypeId: layerProduct.layerTypeId ?? layerTypeMeta?.id ?? null,
              layerTypeName: layerProduct.layerTypeName ?? layerTypeMeta?.name ?? null,
              layerTypePrice: layerProduct.layerTypePrice ?? layerTypeMeta?.pricePerLayer ?? null,
              layerUseDifferentStone: layerProduct.layerUseDifferentStone || !!layerAltStoneMeta,
              layerStoneProductId: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerStoneProductId || layerAltStoneMeta?.id || layerProduct.productId)
                : null,
              layerStoneProduct: layerProduct.layerUseDifferentStone ? layerProduct.product : null,
              layerStoneLabel: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerStoneName || layerAltStoneMeta?.name || layerProduct.stoneName)
                : null,
              layerPricePerSquareMeter: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerStoneBasePricePerSquareMeter || layerAltStoneMeta?.basePricePerSquareMeter || layerProduct.layerStonePricePerSquareMeter || layerProduct.pricePerSquareMeter)
                : draft.pricePerSquareMeter,
              layerUseMandatory: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerUseMandatory ?? ((layerAltStoneMeta?.mandatoryPercentage ?? 0) > 0))
                : undefined,
              layerMandatoryPercentage: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerMandatoryPercentage ?? layerAltStoneMeta?.mandatoryPercentage ?? 20)
                : null
            };
          }
          return draft;
        };
        
        // Load each part into its respective draft and merge layer info
        if (treadProduct) {
          const baseDraft = productToDraft(treadProduct, 'tread');
          setDraftTread(normalizeLayerAltStoneSettings(mergeLayerInfo(baseDraft, 'tread')));
        }
        if (riserProduct) {
          const baseDraft = productToDraft(riserProduct, 'riser');
          setDraftRiser(normalizeLayerAltStoneSettings(mergeLayerInfo(baseDraft, 'riser')));
        }
        if (landingProduct) {
          const baseDraft = productToDraft(landingProduct, 'landing');
          setDraftLanding(normalizeLayerAltStoneSettings(mergeLayerInfo(baseDraft, 'landing')));
        }
        
        // Set active part to the first available part
        if (treadProduct) {
          setActivePart('tread');
        } else if (riserProduct) {
          setActivePart('riser');
        } else if (landingProduct) {
          setActivePart('landing');
        }
        
        // Set product config for modal type detection
        setProductConfig({
          productId: product.productId,
          product: product.product,
          productType: 'stair'
        });
        
        // Set product type for wizard
        updateWizardData({ selectedProductTypeForAddition: 'stair' });
        
        setIsEditMode(true);
        setEditingProductIndex(index);
        setTouchedFields(new Set());
        setErrors({});
        setShowProductModal(true);
        
        console.log('✅ Stair V2 edit initialized:', {
          stairSystemId: product.stairSystemId,
          sessionItems: stairSystemProducts.length,
          partsFound: {
            tread: !!treadProduct,
            riser: !!riserProduct,
            landing: !!landingProduct
          }
        });
        
        return;
      }
      
      // OLD FLOW: Continue with existing logic
      
      // Get common stair system info from first product
      const firstProduct = stairSystemProducts[0] || product;
      const numberOfSteps = firstProduct.numberOfSteps || 0;
      const quantityType = firstProduct.quantityType || 'steps';
      // numberOfStaircases is stored in the product, but we'll default to 1 if not found
      // This is a common field across all parts of the same stair system
      const numberOfStaircases = quantityType === 'staircases' ? Math.max(1, Math.floor(numberOfSteps / Math.max(1, (treadProduct?.quantity || numberOfSteps)))) : 1;
      
      // Reconstruct stair system config
      const editedStairConfig: StairSystemConfig = {
        numberOfSteps: numberOfSteps,
        quantityType: quantityType as 'steps' | 'staircases',
        numberOfStaircases: numberOfStaircases,
        defaultProduct: null,
        tread: {
          partType: 'tread',
          isSelected: !!treadProduct,
          productId: treadProduct?.productId || null,
          product: treadProduct?.product || null,
          treadWidth: treadProduct?.treadWidth || 0,
          treadDepth: treadProduct?.treadDepth || 30,
          quantity: treadProduct?.quantity || numberOfSteps || 0,
          squareMeters: treadProduct?.squareMeters || 0,
          pricePerSquareMeter: treadProduct?.pricePerSquareMeter || 0,
          totalPrice: treadProduct?.totalPrice || 0,
          nosingType: treadProduct?.nosingType || 'none',
          nosingOverhang: treadProduct?.nosingOverhang || 30,
          nosingCuttingCost: treadProduct?.nosingCuttingCost || 0,
          nosingCuttingCostPerMeter: treadProduct?.nosingCuttingCostPerMeter || 0,
          isMandatory: treadProduct?.isMandatory || false,
          mandatoryPercentage: treadProduct?.mandatoryPercentage || 20,
          originalTotalPrice: treadProduct?.originalTotalPrice || 0,
          description: treadProduct?.description || '',
          currency: treadProduct?.currency || 'تومان',
          lengthUnit: treadProduct?.lengthUnit || 'm'
        },
        riser: {
          partType: 'riser',
          isSelected: !!riserProduct,
          productId: riserProduct?.productId || null,
          product: riserProduct?.product || null,
          riserHeight: riserProduct?.riserHeight || 17,
          quantity: riserProduct?.quantity || numberOfSteps || 0,
          squareMeters: riserProduct?.squareMeters || 0,
          pricePerSquareMeter: riserProduct?.pricePerSquareMeter || 0,
          totalPrice: riserProduct?.totalPrice || 0,
          isMandatory: riserProduct?.isMandatory || false,
          mandatoryPercentage: riserProduct?.mandatoryPercentage || 20,
          originalTotalPrice: riserProduct?.originalTotalPrice || 0,
          description: riserProduct?.description || '',
          currency: riserProduct?.currency || 'تومان'
        },
        landing: {
          partType: 'landing',
          isSelected: !!landingProduct,
          productId: landingProduct?.productId || null,
          product: landingProduct?.product || null,
          landingWidth: landingProduct?.landingWidth || 0,
          landingDepth: landingProduct?.landingDepth || 0,
          numberOfLandings: landingProduct?.numberOfLandings || 0,
          quantity: landingProduct?.quantity || 0,
          squareMeters: landingProduct?.squareMeters || 0,
          pricePerSquareMeter: landingProduct?.pricePerSquareMeter || 0,
          totalPrice: landingProduct?.totalPrice || 0,
          isMandatory: landingProduct?.isMandatory || false,
          mandatoryPercentage: landingProduct?.mandatoryPercentage || 20,
          originalTotalPrice: landingProduct?.originalTotalPrice || 0,
          description: landingProduct?.description || '',
          currency: landingProduct?.currency || 'تومان'
        }
      };
      
      // Set stair system config
      setStairSystemConfig(editedStairConfig);
      
      // Set product config for modal (needed for modal type detection)
      setProductConfig({
        ...product,
        productType: 'stair'
      });
      
      // IMPORTANT: Set selectedProduct to enable modal rendering (modal requires selectedProduct && showProductModal)
      // Use the first available product from the stair system, or the current product as fallback
      const defaultProductForModal = treadProduct?.product || riserProduct?.product || landingProduct?.product || product.product;
      setSelectedProduct(defaultProductForModal);
      
      // Set product type for wizard
      updateWizardData({ selectedProductTypeForAddition: 'stair' });
      
      // Reset product search terms
      setTreadProductSearchTerm('');
      setRiserProductSearchTerm('');
      setLandingProductSearchTerm('');
      
      // Expand all sections
      setTreadExpanded(true);
      setRiserExpanded(true);
      setLandingExpanded(true);
      
      setIsEditMode(true);
      setEditingProductIndex(index); // Store the index of the first product in the stair system
      setTouchedFields(new Set());
      setErrors({}); // Clear errors when opening edit modal
      setShowProductModal(true);
      
      console.log('✅ Stair system edit initialized:', {
        stairSystemId: product.stairSystemId,
        numberOfSteps,
        quantityType,
        partsFound: {
          tread: !!treadProduct,
          riser: !!riserProduct,
          landing: !!landingProduct
        },
        config: editedStairConfig
      });
      
      return;
    }
    
    // Handle longitudinal product editing (existing logic)
    setSelectedProduct(product.product);
    
    // Set unit information for proper display
    setLengthUnit(product.lengthUnit || 'm');
    setWidthUnit(product.widthUnit || 'cm');
    
    // Set mandatory pricing state
    setIsMandatory(product.isMandatory || false);
    setMandatoryPercentage(product.mandatoryPercentage || 20);
    
    // Set quantity interaction tracking - if quantity > 1, it has been interacted with
    setHasQuantityBeenInteracted((product.quantity || 0) > 1);
    
    // Set product config with all fields including remaining stone tracking
    // For slab products, ensure slabStandardDimensions is properly loaded
    let slabStandardDimensions = product.slabStandardDimensions || [];
    
    // Backward compatibility: if slabStandardDimensions is empty but legacy fields exist, create an entry
    if (product.productType === 'slab' && slabStandardDimensions.length === 0) {
      if (product.slabStandardLengthCm && product.slabStandardWidthCm) {
        slabStandardDimensions = [{
          id: `std_legacy_${Date.now()}`,
          standardLengthCm: product.slabStandardLengthCm,
          standardWidthCm: product.slabStandardWidthCm,
          quantity: product.quantity || 1
        }];
      }
    }
    
    setProductConfig({
      ...product,
      // For slab products, ensure slabStandardDimensions is set
      ...(product.productType === 'slab' && { slabStandardDimensions }),
      // For slab products, ensure slabVerticalCutSides is set (default to all 4 sides active if not present)
      ...(product.productType === 'slab' && {
        slabVerticalCutSides: product.slabVerticalCutSides || {
          top: true,
          bottom: true,
          left: true,
          right: true
        }
      }),
      // Preserve remaining stone tracking
      usedRemainingStones: product.usedRemainingStones || [],
      totalUsedRemainingWidth: product.totalUsedRemainingWidth || 0,
      totalUsedRemainingLength: product.totalUsedRemainingLength || 0,
      // Preserve remaining stones and cut details
      remainingStones: product.remainingStones || [],
      cutDetails: product.cutDetails || [],
      // Preserve SubService tracking
      appliedSubServices: product.appliedSubServices || [],
      totalSubServiceCost: product.totalSubServiceCost || 0,
      usedLengthForSubServices: product.usedLengthForSubServices || 0,
      usedSquareMetersForSubServices: product.usedSquareMetersForSubServices || 0,
      // Preserve CAD Design if available
      cadDesign: product.cadDesign || null
    });
    
    // Set product type for wizard
    updateWizardData({ selectedProductTypeForAddition: product.productType || 'longitudinal' });
    
    setIsEditMode(true);
    setEditingProductIndex(index);
    setTouchedFields(new Set()); // Reset touched fields for edit session
    setErrors({}); // Clear errors when opening edit modal
    setShowProductModal(true);
  };

  // Handle creating product from remaining stone
  const handleCreateFromRemainingStone = (remainingStone: RemainingStone, sourceProduct: ContractProduct) => {
    console.log('🎯 handleCreateFromRemainingStone called!');
    console.log('🔍 Source Product Debug:', {
      sourceProduct: sourceProduct,
      pricePerSquareMeter: sourceProduct.pricePerSquareMeter,
      isMandatory: sourceProduct.isMandatory,
      mandatoryPercentage: sourceProduct.mandatoryPercentage
    });
    
    setSelectedRemainingStone(remainingStone);
    setSelectedRemainingStoneSourceProduct(sourceProduct); // Store source product for later use
    
    // Find parent product index in wizardData.products for explicit parent-child relationship
    const parentProductIndex = wizardData.products.findIndex(
      p => p.stoneCode === sourceProduct.stoneCode && p.productId === sourceProduct.productId
    );
    
    // Initialize configuration with remaining stone data
    // Use source product's quantity as default (represents remaining pieces available)
    // IMPORTANT: The child's stoneCode is parent's stoneCode + "-R" + last 4 chars of remainingStone.id
    // This creates a unique code for each child product (for backward compatibility)
    const childStoneCode = `${sourceProduct.stoneCode}-R${remainingStone.id.slice(-4)}`;
    const defaultConfig: Partial<ContractProduct> = {
      productId: sourceProduct.productId,
      product: sourceProduct.product,
      productType: sourceProduct.productType, // NEW: Inherit product type from source
      stoneCode: childStoneCode, // Add remaining stone identifier
      stoneName: `${sourceProduct.stoneName} (از باقی‌مانده)`,
      diameterOrWidth: remainingStone.width,
      length: remainingStone.length, // Initialize with remaining stone length
      width: remainingStone.width, // Initialize with remaining stone width, but allow editing
      quantity: sourceProduct.quantity || 1, // Use source product's remaining quantity
      squareMeters: remainingStone.squareMeters, // Initialize with remaining stone square meters (already includes quantity)
      pricePerSquareMeter: 0, // No pricing for remaining stone
      totalPrice: 0,
      description: `ساخته شده از سنگ باقی‌مانده (${remainingStone.width}cm عرض)`,
      currency: sourceProduct.currency,
      // Unit information for proper display
      lengthUnit: sourceProduct.lengthUnit || 'm',
      widthUnit: sourceProduct.widthUnit || 'cm',
      // Inherit from source product
      isMandatory: sourceProduct.isMandatory,
      mandatoryPercentage: sourceProduct.mandatoryPercentage,
      originalTotalPrice: 0,
      // Stone cutting fields - inherit cutting cost per meter from source product
      isCut: false,
      originalWidth: remainingStone.width,
      originalLength: remainingStone.length, // Store the original remaining length
      cuttingCost: 0,
      cuttingCostPerMeter: sourceProduct.cuttingCostPerMeter || 0, // Inherit from source product
      remainingStones: [],
      cutDetails: [],
      // Initialize SubService tracking
      appliedSubServices: [],
      totalSubServiceCost: 0,
      usedLengthForSubServices: 0,
      usedSquareMetersForSubServices: 0,
      // Set explicit parent reference (if parent found)
      parentProductIndex: parentProductIndex >= 0 ? parentProductIndex : undefined
    };
    
    console.log('🔍 Default Config Created:', {
      defaultConfig: defaultConfig,
      pricePerSquareMeter: defaultConfig.pricePerSquareMeter
    });
    
    setRemainingStoneConfig(defaultConfig);
    // Inherit unit information from source product
    setRemainingStoneLengthUnit(sourceProduct.lengthUnit || 'm');
    setRemainingStoneWidthUnit(sourceProduct.widthUnit || 'cm');
    setRemainingStoneIsMandatory(sourceProduct.isMandatory || false);
    setRemainingStoneMandatoryPercentage(sourceProduct.mandatoryPercentage || 20);
    
    // Initialize partitions array (start with one empty partition)
    setPartitions([{
      id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      width: 0,
      length: 0,
      squareMeters: 0
    }]);
    setPartitionLengthUnit(sourceProduct.lengthUnit || 'm');
    setPartitionWidthUnit(sourceProduct.widthUnit || 'cm');
    
    setShowRemainingStoneModal(true);
  };
  // Handle product configuration and add to contract
  const handleAddProductToContract = () => {
    console.log('🚀 handleAddProductToContract called!');
    console.log('🔍 Main Product Validation Debug:', {
      selectedProduct: selectedProduct,
      productConfig: productConfig,
      productType: wizardData.selectedProductTypeForAddition,
      hasLength: !!productConfig.length,
      hasWidth: !!productConfig.width,
      hasSquareMeters: !!productConfig.squareMeters,
      hasQuantity: !!productConfig.quantity,
      hasPricePerSquareMeter: !!productConfig.pricePerSquareMeter
    });
    
    if (!selectedProduct || !productConfig) {
      console.log('❌ Missing selectedProduct or productConfig');
      return;
    }
    
    // Get product type from wizard data (required)
    const productType = wizardData.selectedProductTypeForAddition;
    if (!productType) {
      console.error('❌ Product type not selected');
      setErrors({ products: 'لطفاً ابتدا نوع محصول را انتخاب کنید' });
      return;
    }
    
    // Handle different product types
    if (productType === 'stair') {
      // STAIR SYSTEM (دستگاه پله) VALIDATION AND CREATION
      if (!stairSystemConfig) {
        setErrors({ products: 'خطا در پیکربندی سیستم پله' });
        return;
      }
      
      // Validate that at least one part is selected
      const hasSelectedPart = stairSystemConfig.tread.isSelected || 
                              stairSystemConfig.riser.isSelected || 
                              stairSystemConfig.landing.isSelected;
      
      if (!hasSelectedPart) {
        setErrors({ products: 'لطفاً حداقل یکی از بخش‌های پله (کف پله، خیز پله، یا پاگرد) را انتخاب کنید' });
        return;
      }
      
      // Validate common configuration
      if (!stairSystemConfig.numberOfSteps || stairSystemConfig.numberOfSteps <= 0) {
        setErrors({ products: 'لطفاً تعداد پله را وارد کنید' });
        return;
      }
      
      if (stairSystemConfig.quantityType === 'staircases' && 
          (!stairSystemConfig.numberOfStaircases || stairSystemConfig.numberOfStaircases <= 0)) {
        setErrors({ products: 'لطفاً تعداد پله‌کان کامل را وارد کنید' });
        return;
      }
      
      // Generate unique stair system ID (only for new systems, preserve for edits)
      let stairSystemId: string;
      if (isEditMode && editingProductIndex !== null) {
        // Preserve existing stairSystemId when editing
        const editingProduct = wizardData.products[editingProductIndex];
        stairSystemId = editingProduct?.stairSystemId || `stair_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      } else {
        stairSystemId = `stair_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
      
      const productsToAdd: ContractProduct[] = [];
      
      // Process Tread (کف پله)
      if (stairSystemConfig.tread.isSelected) {
        const tread = stairSystemConfig.tread;
        
        if (!tread.product || !tread.productId) {
          setErrors({ products: 'لطفاً محصول برای کف پله را انتخاب کنید' });
          return;
        }
        
        if (!tread.treadWidth || tread.treadWidth <= 0) {
          setErrors({ products: 'لطفاً طول پله را برای کف پله وارد کنید' });
          return;
        }
        
        if (!tread.treadDepth || tread.treadDepth <= 0) {
          setErrors({ products: 'لطفاً عرض پله را برای کف پله وارد کنید' });
          return;
        }
        
        if (!tread.quantity || tread.quantity <= 0) {
          setErrors({ products: 'لطفاً تعداد را برای کف پله وارد کنید' });
          return;
        }
        
        if (!tread.pricePerSquareMeter || tread.pricePerSquareMeter <= 0) {
          setErrors({ products: 'لطفاً فی هر متر مربع را برای کف پله وارد کنید' });
          return;
        }
        
        // Calculate tread metrics
        const treadMetrics = calculateTreadMetrics({
          treadWidth: tread.treadWidth,
          treadWidthUnit: tread.lengthUnit || 'm',
          treadDepth: tread.treadDepth,
          quantity: tread.quantity,
          quantityType: stairSystemConfig.quantityType,
          numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
        });
        
        // Calculate nosing cost (only for tread)
        const nosingCost = calculateNosingCuttingCost({
          nosingType: tread.nosingType || 'none',
          treadWidth: tread.treadWidth,
          treadWidthUnit: tread.lengthUnit || 'm',
          numberOfSteps: tread.quantity,
          numberOfStaircases: stairSystemConfig.quantityType === 'staircases' ? (stairSystemConfig.numberOfStaircases || 1) : 1,
          quantityType: stairSystemConfig.quantityType
        });
        
        // Calculate pricing
        const basePrice = treadMetrics.totalArea * tread.pricePerSquareMeter;
        const mandatoryPrice = tread.isMandatory && tread.mandatoryPercentage
          ? basePrice * (tread.mandatoryPercentage / 100)
          : 0;
        const totalPrice = basePrice + mandatoryPrice + nosingCost.cuttingCost;
        
        productsToAdd.push({
          productId: tread.productId,
          product: tread.product,
          productType: 'stair',
          stairSystemId: stairSystemId,
          stairPartType: 'tread',
          stoneCode: tread.product.code,
          stoneName: tread.product.namePersian,
          diameterOrWidth: tread.product.widthValue,
          length: 0,
          width: 0,
          quantity: treadMetrics.totalQuantity,
          squareMeters: treadMetrics.totalArea,
          pricePerSquareMeter: tread.pricePerSquareMeter,
          totalPrice: totalPrice,
          description: tread.description || `کف پله - دستگاه پله`,
          currency: 'تومان',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: tread.isMandatory,
          mandatoryPercentage: tread.mandatoryPercentage,
          originalTotalPrice: basePrice,
          isCut: false,
          cutType: null,
          originalWidth: tread.product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0,
          // Stair-specific fields
          treadWidth: tread.treadWidth,
          treadDepth: tread.treadDepth,
          numberOfSteps: stairSystemConfig.numberOfSteps,
          quantityType: stairSystemConfig.quantityType,
          nosingType: tread.nosingType,
          nosingOverhang: tread.nosingOverhang,
          nosingCuttingCost: nosingCost.cuttingCost,
          nosingCuttingCostPerMeter: nosingCost.cuttingCostPerMeter
        });
      }
      
      // Process Riser (خیز پله)
      if (stairSystemConfig.riser.isSelected) {
        const riser = stairSystemConfig.riser;
        
        if (!riser.product || !riser.productId) {
          setErrors({ products: 'لطفاً محصول برای خیز پله را انتخاب کنید' });
          return;
        }
        
        if (!riser.riserHeight || riser.riserHeight <= 0) {
          setErrors({ products: 'لطفاً ارتفاع قائمه را برای خیز پله وارد کنید' });
          return;
        }
        
        if (!riser.quantity || riser.quantity <= 0) {
          setErrors({ products: 'لطفاً تعداد را برای خیز پله وارد کنید' });
          return;
        }
        
        if (!riser.pricePerSquareMeter || riser.pricePerSquareMeter <= 0) {
          setErrors({ products: 'لطفاً فی هر متر مربع را برای خیز پله وارد کنید' });
          return;
        }
        
        // Get tread width for riser calculation (from tread part if available, otherwise use default)
        // CRITICAL: Riser calculation depends on tread width, so we need to validate it
        const treadWidth = stairSystemConfig.tread.treadWidth;
        const treadWidthUnit = stairSystemConfig.tread.lengthUnit || 'm';
        
        // Validate that tread width is available if riser is selected
        // If tread is not selected, we can't calculate riser area accurately
        if (!treadWidth || treadWidth <= 0) {
          // If tread is not selected, we can't use its width
          if (!stairSystemConfig.tread.isSelected) {
            setErrors({ products: 'برای محاسبه خیز پله، ابتدا باید کف پله را انتخاب کرده و طول پله را وارد کنید' });
            return;
          }
          // If tread is selected but width is not set
          setErrors({ products: 'لطفاً طول پله را برای کف پله وارد کنید تا بتوان خیز پله را محاسبه کرد' });
          return;
        }
        
        // Calculate riser metrics
        const riserMetrics = calculateRiserMetrics({
          treadWidth: treadWidth,
          treadWidthUnit: treadWidthUnit,
          riserHeight: riser.riserHeight,
          quantity: riser.quantity,
          quantityType: stairSystemConfig.quantityType,
          numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
        });
        
        // Calculate pricing
        const basePrice = riserMetrics.totalArea * riser.pricePerSquareMeter;
        const mandatoryPrice = riser.isMandatory && riser.mandatoryPercentage
          ? basePrice * (riser.mandatoryPercentage / 100)
          : 0;
        const totalPrice = basePrice + mandatoryPrice;
        
        productsToAdd.push({
          productId: riser.productId,
          product: riser.product,
          productType: 'stair',
          stairSystemId: stairSystemId,
          stairPartType: 'riser',
          stoneCode: riser.product.code,
          stoneName: riser.product.namePersian,
          diameterOrWidth: riser.product.widthValue,
          length: 0,
          width: 0,
          quantity: riserMetrics.totalQuantity,
          squareMeters: riserMetrics.totalArea,
          pricePerSquareMeter: riser.pricePerSquareMeter,
          totalPrice: totalPrice,
          description: riser.description || `خیز پله - دستگاه پله`,
          currency: 'تومان',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: riser.isMandatory,
          mandatoryPercentage: riser.mandatoryPercentage,
          originalTotalPrice: basePrice,
          isCut: false,
          cutType: null,
          originalWidth: riser.product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0,
          // Stair-specific fields
          riserHeight: riser.riserHeight,
          numberOfSteps: stairSystemConfig.numberOfSteps,
          quantityType: stairSystemConfig.quantityType
        });
      }
      
      // Process Landing (پاگرد)
      if (stairSystemConfig.landing.isSelected) {
        const landing = stairSystemConfig.landing;
        
        if (!landing.product || !landing.productId) {
          setErrors({ products: 'لطفاً محصول برای پاگرد را انتخاب کنید' });
          return;
        }
        
        if (!landing.numberOfLandings || landing.numberOfLandings <= 0) {
          setErrors({ products: 'لطفاً تعداد پاگرد را وارد کنید' });
          return;
        }
        
        if (!landing.landingWidth || landing.landingWidth <= 0) {
          setErrors({ products: 'لطفاً عرض پاگرد را وارد کنید' });
          return;
        }
        
        if (!landing.landingDepth || landing.landingDepth <= 0) {
          setErrors({ products: 'لطفاً عمق پاگرد را وارد کنید' });
          return;
        }
        
        if (!landing.pricePerSquareMeter || landing.pricePerSquareMeter <= 0) {
          setErrors({ products: 'لطفاً فی هر متر مربع را برای پاگرد وارد کنید' });
          return;
        }
        
        // Calculate landing metrics
        const landingMetrics = calculateLandingMetrics({
          landingWidth: landing.landingWidth,
          landingDepth: landing.landingDepth,
          numberOfLandings: landing.numberOfLandings,
          quantityType: stairSystemConfig.quantityType,
          numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
        });
        
        // Calculate pricing
        const basePrice = landingMetrics.totalArea * landing.pricePerSquareMeter;
        const mandatoryPrice = landing.isMandatory && landing.mandatoryPercentage
          ? basePrice * (landing.mandatoryPercentage / 100)
          : 0;
        const totalPrice = basePrice + mandatoryPrice;
        
        productsToAdd.push({
          productId: landing.productId,
          product: landing.product,
          productType: 'stair',
          stairSystemId: stairSystemId,
          stairPartType: 'landing',
          stoneCode: landing.product.code,
          stoneName: landing.product.namePersian,
          diameterOrWidth: landing.product.widthValue,
          length: 0,
          width: 0,
          quantity: landingMetrics.totalQuantity,
          squareMeters: landingMetrics.totalArea,
          pricePerSquareMeter: landing.pricePerSquareMeter,
          totalPrice: totalPrice,
          description: landing.description || `پاگرد - دستگاه پله`,
          currency: 'تومان',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: landing.isMandatory,
          mandatoryPercentage: landing.mandatoryPercentage,
          originalTotalPrice: basePrice,
          isCut: false,
          cutType: null,
          originalWidth: landing.product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0,
          // Stair-specific fields
          landingWidth: landing.landingWidth,
          landingDepth: landing.landingDepth,
          numberOfLandings: landing.numberOfLandings,
          quantityType: stairSystemConfig.quantityType
        });
      }
      
      // Handle editing vs adding
      if (isEditMode && editingProductIndex !== null) {
        // Editing mode: Remove old stair system products and add new ones
        const editingProduct = wizardData.products[editingProductIndex];
        const oldStairSystemId = editingProduct?.stairSystemId;
        
        // Remove all products with the same stairSystemId
        const updatedProducts = wizardData.products.filter(p => 
          !(p.productType === 'stair' && p.stairSystemId === oldStairSystemId)
        );
        
        // Add updated products with the same stairSystemId (preserve ID for grouping)
        productsToAdd.forEach(p => {
          p.stairSystemId = oldStairSystemId; // Preserve the original stairSystemId
        });
        
        updateWizardData({
          products: [...updatedProducts, ...productsToAdd]
        });
        
        console.log('✅ Successfully updated stair system in contract!', {
          stairSystemId: oldStairSystemId,
          partsUpdated: productsToAdd.length,
          parts: productsToAdd.map(p => p.stairPartType)
        });
      } else {
        // Adding new stair system
        updateWizardData({
          products: [...wizardData.products, ...productsToAdd]
        });
        
        console.log('✅ Successfully added stair system to contract!', {
          stairSystemId,
          partsAdded: productsToAdd.length,
          parts: productsToAdd.map(p => p.stairPartType)
        });
      }
      
      // Close modal and reset state
      setShowProductModal(false);
      setSelectedProduct(null);
      setProductConfig({});
      setStairSystemConfig(null);
      setTreadWidthUnit('m');
      setQuantityType('steps');
      setIsMandatory(false);
      setMandatoryPercentage(20);
      setIsEditMode(false);
      setEditingProductIndex(null);
      setTouchedFields(new Set());
      setErrors({});
      
      return;
    }
    
    // SLAB STONE VALIDATION AND CALCULATION
    if (productConfig.productType === 'slab') {
      // Validate required fields - at least one of length/width or squareMeters must be provided
      const hasDimensions = (productConfig.length && productConfig.width) || productConfig.squareMeters;
      const hasRequiredFields = productConfig.quantity && productConfig.pricePerSquareMeter;
      
      if (!hasDimensions) {
        setErrors({ products: 'لطفاً طول و عرض یا متر مربع را وارد کنید' });
        return;
      }
      
      if (!hasRequiredFields) {
        if (!productConfig.quantity) {
          setErrors({ products: 'لطفاً تعداد را وارد کنید' });
        } else if (!productConfig.pricePerSquareMeter) {
          setErrors({ products: 'لطفاً فی هر متر مربع را وارد کنید' });
        } else {
          setErrors({ products: 'لطفاً تعداد و فی هر متر مربع را وارد کنید' });
        }
        return;
      }
      
      // Validate standard dimensions
      const standardDimensions = productConfig.slabStandardDimensions || [];
      const wantedQuantity = productConfig.quantity || 0;
      const totalStandardQuantity = standardDimensions.reduce((sum, entry) => sum + (entry.quantity || 0), 0);
      
      if (standardDimensions.length === 0) {
        setErrors({ products: 'لطفاً حداقل یک ابعاد استاندارد را اضافه کنید' });
          return;
      }
      
      if (totalStandardQuantity !== wantedQuantity) {
          setErrors({ 
          products: `مجموع تعداد ابعاد استاندارد (${totalStandardQuantity}) باید برابر با تعداد درخواستی (${wantedQuantity}) باشد` 
          });
          return;
      }
      
      // Validate that standard dimensions are >= wanted dimensions
      const userWidthInCm = productConfig.width 
        ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width)
        : 0;
      const userLengthInCm = productConfig.length 
        ? (lengthUnit === 'm' ? productConfig.length * 100 : productConfig.length)
        : 0;
      
      for (const entry of standardDimensions) {
        if (userLengthInCm > 0 && entry.standardLengthCm < userLengthInCm) {
          setErrors({ 
            products: `طول استاندارد (${entry.standardLengthCm}cm) نمی‌تواند کمتر از طول درخواستی (${userLengthInCm}cm) باشد` 
          });
          return;
        }
        if (userWidthInCm > 0 && entry.standardWidthCm < userWidthInCm) {
          setErrors({ 
            products: `عرض استاندارد (${entry.standardWidthCm}cm) نمی‌تواند کمتر از عرض درخواستی (${userWidthInCm}cm) باشد` 
          });
          return;
        }
        if (entry.quantity <= 0) {
          setErrors({ products: 'تعداد هر ابعاد استاندارد باید بیشتر از صفر باشد' });
          return;
        }
      }
      
      // For backward compatibility, use first entry as default if needed
      const { standardLengthCm, standardWidthCm } = getSlabStandardDimensions();
      const originalWidthCm = standardWidthCm || selectedProduct.widthValue || 0;
      const originalLengthCm = standardLengthCm || (selectedProduct as any)?.lengthValue || 300;
      const originalWidthInCurrentUnit = widthUnit === 'm' ? originalWidthCm / 100 : originalWidthCm;
      const originalLengthInCurrentUnit = lengthUnit === 'm' ? originalLengthCm / 100 : originalLengthCm;
      
      // Determine if cuts are needed (2D: longitudinal + cross)
      
      const needsLongitudinalCut = userWidthInCm > 0 && userWidthInCm < originalWidthCm && originalWidthCm > 0;
      const needsCrossCut = userLengthInCm > 0 && userLengthInCm < originalLengthCm && originalLengthCm > 0;
      
      // Automatically fetch cutting costs if cuts should be applied
      let cuttingCostPerMeterLongitudinal = 0;
      let cuttingCostPerMeterCross = 0;
      
      if (needsLongitudinalCut) {
        cuttingCostPerMeterLongitudinal = getCuttingTypePricePerMeter('LONG') || 0;
      }
      if (needsCrossCut) {
        cuttingCostPerMeterCross = getCuttingTypePricePerMeter('CROSS') || getCuttingTypePricePerMeter('LONG') || 0;
      }
      
      const slabCuttingMode = productConfig.slabCuttingMode || 'lineBased';
      const slabCuttingPricePerSquareMeter = productConfig.slabCuttingPricePerSquareMeter || 0;
      
      // Calculate metrics - use effective quantity
      const effectiveQuantity = getEffectiveQuantity();
      
      // For line-based cutting, we need to calculate line plan for each standard dimension entry
      // For now, use the first entry for line plan calculation (can be enhanced later)
      const firstStandardEntry = standardDimensions[0];
      const linePlanStandardLengthCm = firstStandardEntry?.standardLengthCm || originalLengthCm;
      const linePlanStandardWidthCm = firstStandardEntry?.standardWidthCm || originalWidthCm;
      const linePlan = determineSlabLineCutPlan({
        requestedLengthCm: userLengthInCm,
        requestedWidthCm: userWidthInCm,
        standardLengthCm: linePlanStandardLengthCm,
        standardWidthCm: linePlanStandardWidthCm
      });
      
      const calculated = calculateSlabMetrics({
        length: productConfig.length,
        width: productConfig.width,
        quantity: effectiveQuantity,
        squareMeters: productConfig.squareMeters,
        pricePerSquareMeter: productConfig.pricePerSquareMeter,
        lengthUnit: lengthUnit,
        widthUnit: widthUnit,
        isMandatory: false, // Slab stones don't use mandatory pricing
        mandatoryPercentage: 0, // Slab stones don't use mandatory pricing
        originalLength: originalLengthInCurrentUnit,
        originalWidth: originalWidthInCurrentUnit,
        standardDimensions: standardDimensions,
        cuttingCostPerMeterLongitudinal: cuttingCostPerMeterLongitudinal,
        cuttingCostPerMeterCross: cuttingCostPerMeterCross,
        slabCuttingMode,
        slabCuttingPricePerSquareMeter,
        lineCutLongitudinalMeters: linePlan.longitudinalMeters,
        lineCutCrossMeters: linePlan.crossMeters
      });
      
      // Calculate برش قائم (vertical edge cuts) cost
      // IMPORTANT: برش قائم is calculated for each standard dimension entry using its own dimensions and quantity
      // This is because برش قائم happens on the standard stones BEFORE they are cut to desired dimensions
      const verticalCutSides = productConfig.slabVerticalCutSides || {
        top: true,
        bottom: true,
        left: true,
        right: true
      };
      const verticalCutCostPerMeter = getCuttingTypePricePerMeter('VERTICAL') || getCuttingTypePricePerMeter('LONG') || 0;
      
      // Calculate vertical cut cost for each standard dimension entry
      let totalVerticalCutCost = 0;
      if (verticalCutCostPerMeter > 0 && standardDimensions.length > 0) {
        for (const entry of standardDimensions) {
          // Calculate برش قائم for this entry using its standard dimensions
          const entryVerticalCutCost = calculateSlabVerticalCutCost({
            requestedLengthCm: entry.standardLengthCm, // Use standard length, not requested
            requestedWidthCm: entry.standardWidthCm, // Use standard width, not requested
            quantity: entry.quantity, // Use entry's quantity
            verticalCutSides: verticalCutSides,
            verticalCutCostPerMeter: verticalCutCostPerMeter
          });
          totalVerticalCutCost += entryVerticalCutCost;
        }
      }
      
      // Calculate slab cutting details for all standard dimension entries
      // This will generate remaining stones for each entry
      const allRemainingPieces: RemainingStone[] = [];
      const allCutDetails: StoneCut[] = [];
      let totalCuttingCost = 0;
      let hasAnyCut = false;
      
      for (const entry of standardDimensions) {
        const entryOriginalLengthInCurrentUnit = lengthUnit === 'm' ? entry.standardLengthCm / 100 : entry.standardLengthCm;
        const entryOriginalWidthInCurrentUnit = widthUnit === 'm' ? entry.standardWidthCm / 100 : entry.standardWidthCm;
        
        const entryLinePlan = determineSlabLineCutPlan({
          requestedLengthCm: userLengthInCm,
          requestedWidthCm: userWidthInCm,
          standardLengthCm: entry.standardLengthCm,
          standardWidthCm: entry.standardWidthCm
        });
        
        const entrySlabCutting = calculateSlabCutting({
          originalLength: entryOriginalLengthInCurrentUnit,
          originalWidth: entryOriginalWidthInCurrentUnit,
        desiredLength: productConfig.length || 0,
        desiredWidth: productConfig.width || 0,
        lengthUnit: lengthUnit,
        widthUnit: widthUnit,
          cuttingCostPerMeterLongitudinal: slabCuttingMode === 'lineBased' ? cuttingCostPerMeterLongitudinal : 0,
          cuttingCostPerMeterCross: slabCuttingMode === 'lineBased' ? cuttingCostPerMeterCross : 0,
          quantity: entry.quantity,
          longitudinalCutLengthMeters: entryLinePlan.longitudinalMeters,
          crossCutLengthMeters: entryLinePlan.crossMeters
        });
        
        if (entrySlabCutting.needsLongitudinalCut || entrySlabCutting.needsCrossCut) {
          hasAnyCut = true;
        }
        
        totalCuttingCost += entrySlabCutting.totalCuttingCost || 0;
        allRemainingPieces.push(...(entrySlabCutting.remainingPieces || []));
        allCutDetails.push(...(entrySlabCutting.cutDetails || []));
      }
      
      // Add برش قائم cost to total cutting cost
      const finalTotalCuttingCost = totalCuttingCost + totalVerticalCutCost;
      
      // Create a combined slab cutting result
      const slabCutting = {
        needsLongitudinalCut: hasAnyCut && userWidthInCm > 0 && standardDimensions.some(e => userWidthInCm < e.standardWidthCm),
        needsCrossCut: hasAnyCut && userLengthInCm > 0 && standardDimensions.some(e => userLengthInCm < e.standardLengthCm),
        remainingPieces: allRemainingPieces,
        cutDetails: allCutDetails,
        cuttingCost: finalTotalCuttingCost // Include vertical cut cost
      };
      
      const lineBasedDescription = slabCutting.needsLongitudinalCut && slabCutting.needsCrossCut
        ? `برش دو بعدی خودکار (طول: ${originalLengthCm}cm → ${userLengthInCm}cm، عرض: ${originalWidthCm}cm → ${userWidthInCm}cm)`
        : (slabCutting.needsLongitudinalCut 
          ? `برش طولی خودکار (${originalWidthCm}cm → ${userWidthInCm}cm)`
          : (slabCutting.needsCrossCut 
            ? `برش کله بر خودکار (${originalLengthCm}cm → ${userLengthInCm}cm)`
            : ''));
      const perSquareMeterDescription = slabCuttingMode === 'perSquareMeter' && slabCuttingPricePerSquareMeter > 0
        ? `بر اساس متر مربع (${formatSquareMeters(calculated.squareMeters || 0)} × ${formatPrice(slabCuttingPricePerSquareMeter, 'تومان')})`
        : 'بر اساس متر مربع';
      
      // Create final product configuration for slab stone
      const finalProduct: ContractProduct = {
        productId: selectedProduct.id,
        product: selectedProduct,
        productType: 'slab',
        stoneCode: productConfig.stoneCode || selectedProduct.code,
        stoneName: productConfig.stoneName || selectedProduct.namePersian,
        diameterOrWidth: productConfig.diameterOrWidth || selectedProduct.widthValue,
        length: calculated.length,
        width: calculated.width,
        quantity: effectiveQuantity,
        squareMeters: calculated.squareMeters,
        pricePerSquareMeter: productConfig.pricePerSquareMeter || 0,
        totalPrice: calculated.totalPrice,
        description: productConfig.description || '',
        currency: 'تومان',
        lengthUnit: lengthUnit,
        widthUnit: widthUnit,
        isMandatory: false, // Slab stones don't use mandatory pricing
        mandatoryPercentage: 0, // Slab stones don't use mandatory pricing
        originalTotalPrice: calculated.originalTotalPrice,
        // Slab cutting fields (2D)
        isCut: hasAnyCut,
        cutType: slabCutting.needsLongitudinalCut && slabCutting.needsCrossCut ? 'cross' : (slabCutting.needsLongitudinalCut ? 'longitudinal' : null),
        originalWidth: originalWidthCm,
        originalLength: originalLengthInCurrentUnit,
        cuttingCost: slabCutting.cuttingCost || calculated.cuttingCost, // Use calculated cutting cost from all entries (includes برش قائم)
        cuttingCostPerMeter: slabCuttingMode === 'lineBased'
          ? (cuttingCostPerMeterLongitudinal || cuttingCostPerMeterCross || 0)
          : 0,
        cutDescription: slabCuttingMode === 'lineBased' ? lineBasedDescription : perSquareMeterDescription,
        // برش قائم fields
        slabVerticalCutSides: verticalCutSides,
        slabVerticalCutCost: totalVerticalCutCost,
        slabVerticalCutCostPerMeter: verticalCutCostPerMeter,
        remainingStones: (isEditMode && productConfig.remainingStones) ? productConfig.remainingStones : slabCutting.remainingPieces,
        cutDetails: (isEditMode && productConfig.cutDetails) ? productConfig.cutDetails : slabCutting.cutDetails,
        usedRemainingStones: (isEditMode && productConfig.usedRemainingStones) ? productConfig.usedRemainingStones : [],
        totalUsedRemainingWidth: (isEditMode && productConfig.totalUsedRemainingWidth) ? productConfig.totalUsedRemainingWidth : 0,
        totalUsedRemainingLength: (isEditMode && productConfig.totalUsedRemainingLength) ? productConfig.totalUsedRemainingLength : 0,
        appliedSubServices: (isEditMode && productConfig.appliedSubServices) ? productConfig.appliedSubServices : [],
        totalSubServiceCost: (isEditMode && productConfig.totalSubServiceCost !== undefined) ? productConfig.totalSubServiceCost : 0,
        usedLengthForSubServices: (isEditMode && productConfig.usedLengthForSubServices !== undefined) ? productConfig.usedLengthForSubServices : 0,
        usedSquareMetersForSubServices: (isEditMode && productConfig.usedSquareMetersForSubServices !== undefined) ? productConfig.usedSquareMetersForSubServices : 0,
        // Legacy single standard dimension fields (for backward compatibility)
        slabStandardLengthCm: originalLengthCm,
        slabStandardWidthCm: originalWidthCm,
        // New multiple standard dimensions support
        slabStandardDimensions: standardDimensions,
        slabCuttingMode,
        slabCuttingPricePerSquareMeter: slabCuttingMode === 'perSquareMeter' ? slabCuttingPricePerSquareMeter : null,
        slabLineCuttingStrategy: linePlan.axisUsingStandard,
        slabLineCuttingLongitudinalMeters: linePlan.longitudinalMeters,
        slabLineCuttingCrossMeters: linePlan.crossMeters,
        // CAD Design (if available)
        cadDesign: productConfig.cadDesign || null
      };
      
      // Add SubService costs to totalPrice if they exist
      const existingSubServiceCost = (isEditMode && productConfig.totalSubServiceCost) ? productConfig.totalSubServiceCost : 0;
      finalProduct.totalPrice = calculated.totalPrice + existingSubServiceCost;
      
      // Add to contract or update existing product
      if (isEditMode && editingProductIndex !== null) {
        const updatedProducts = [...wizardData.products];
        updatedProducts[editingProductIndex] = finalProduct;
        updateWizardData({ products: updatedProducts });
      } else {
        updateWizardData({ products: [...wizardData.products, finalProduct] });
      }
      
      console.log('✅ Successfully added slab product to contract!', { finalProduct });
      
      // Close modal and reset state
      setShowProductModal(false);
      setSelectedProduct(null);
      setProductConfig({});
      setLengthUnit('m');
      setWidthUnit('cm');
      setIsMandatory(false);
      setMandatoryPercentage(20);
      setIsEditMode(false);
      setEditingProductIndex(null);
      setTouchedFields(new Set());
      setErrors({});
      
      return;
    }
    
    // LONGITUDINAL STONE VALIDATION AND CALCULATION (existing logic)
    // Validate required fields - at least one of length/width or squareMeters must be provided
    const hasDimensions = (productConfig.length && productConfig.width) || productConfig.squareMeters;
    const hasRequiredFields = productConfig.quantity && productConfig.pricePerSquareMeter;
    
    console.log('🔍 Main Product Validation Results:', {
      hasDimensions,
      hasRequiredFields,
      length: productConfig.length,
      width: productConfig.width,
      squareMeters: productConfig.squareMeters,
      quantity: productConfig.quantity,
      pricePerSquareMeter: productConfig.pricePerSquareMeter
    });
    
    if (!hasDimensions) {
      console.log('❌ Missing dimensions');
      setErrors({ products: 'لطفاً طول و عرض یا متر مربع را وارد کنید' });
      return;
    }
    
    if (!hasRequiredFields) {
      console.log('❌ Missing required fields - quantity:', productConfig.quantity, 'pricePerSquareMeter:', productConfig.pricePerSquareMeter);
      
      // Provide more specific error messages
      if (!productConfig.quantity) {
        setErrors({ products: 'لطفاً تعداد را وارد کنید' });
      } else if (!productConfig.pricePerSquareMeter) {
        setErrors({ products: 'لطفاً فی هر متر مربع را وارد کنید' });
      } else {
        setErrors({ products: 'لطفاً تعداد و فی هر متر مربع را وارد کنید' });
      }
      return;
    }
    
    // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
    const originalWidthForCalculation = (isEditMode && productConfig.originalWidth) 
      ? productConfig.originalWidth 
      : selectedProduct.widthValue;
    
    // Validate width: cannot exceed original width
    if (productConfig.width && originalWidthForCalculation > 0) {
      const userWidthInCm = widthUnit === 'm' ? productConfig.width * 100 : productConfig.width;
      if (userWidthInCm > originalWidthForCalculation) {
        setErrors({ 
          products: `عرض وارد شده (${productConfig.width}${widthUnit === 'm' ? 'm' : 'cm'}) بیشتر از عرض اصلی سنگ (${originalWidthForCalculation}cm) است. لطفاً عرضی کمتر یا مساوی با ${originalWidthForCalculation}cm وارد کنید.` 
        });
        return;
      }
    }
    
    // Determine if longitudinal cut should be automatically selected (before calculating metrics)
    // Convert width to cm for comparison
    const userWidthForComparison = productConfig.width 
      ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width)
      : 0;
    const shouldAutoSelectLongitudinalCut = userWidthForComparison > 0 && userWidthForComparison < originalWidthForCalculation && originalWidthForCalculation > 0;
    
    // Automatically fetch cutting cost per meter if cut should be applied
    let cuttingCostPerMeterForCalc = productConfig.cuttingCostPerMeter || 0;
    if (shouldAutoSelectLongitudinalCut && !cuttingCostPerMeterForCalc) {
      // Fetch price from cutting types for "LONG" (برش طولی)
      cuttingCostPerMeterForCalc = getCuttingTypePricePerMeter('LONG') || 0;
      console.log('🔧 Auto-fetched cutting cost per meter before calculation:', cuttingCostPerMeterForCalc);
    }
    
    // Calculate metrics - use effective quantity (default to 1 if not interacted)
    const effectiveQuantity = getEffectiveQuantity();
    const calculated = calculateStoneMetrics({
      length: productConfig.length,
      width: productConfig.width,
      quantity: effectiveQuantity,
      squareMeters: productConfig.squareMeters,
      pricePerSquareMeter: productConfig.pricePerSquareMeter,
      lengthUnit: lengthUnit,
      widthUnit: widthUnit,
      isMandatory: isMandatory,
      mandatoryPercentage: mandatoryPercentage,
      isCut: productConfig.isCut || shouldAutoSelectLongitudinalCut, // Use auto-selection result
      originalWidth: originalWidthForCalculation,
      cuttingCostPerMeter: cuttingCostPerMeterForCalc // Use fetched value if available
    });
    
    // Get final width for display/logging
    const userEnteredWidth = calculated.width;
    const originalWidth = originalWidthForCalculation;
    const userEnteredWidthInCm = widthUnit === 'm' ? userEnteredWidth * 100 : userEnteredWidth;
    
    console.log('🔍 Auto Cut Selection Logic:', {
      userEnteredWidth,
      originalWidth,
      userEnteredWidthInCm,
      shouldAutoSelectLongitudinalCut,
      comparison: `${userEnteredWidthInCm} < ${originalWidth} = ${userEnteredWidthInCm < originalWidth}`,
      cuttingCostPerMeterForCalc,
      calculatedCuttingCost: calculated.cuttingCost
    });
    
    // Use cutting cost from calculated result (which already includes the auto-fetched price if applicable)
    const finalCuttingCost = calculated.cuttingCost || 0;
    const finalCuttingCostPerMeter = cuttingCostPerMeterForCalc;
    
    // Create final product configuration for longitudinal stone
    const finalProduct: ContractProduct = {
      productId: selectedProduct.id,
      product: selectedProduct,
      productType: 'longitudinal',
      stoneCode: productConfig.stoneCode || selectedProduct.code,
      stoneName: productConfig.stoneName || selectedProduct.namePersian,
      diameterOrWidth: productConfig.diameterOrWidth || selectedProduct.widthValue,
      length: calculated.length,
      width: calculated.width,
      quantity: effectiveQuantity,
      squareMeters: calculated.squareMeters,
      pricePerSquareMeter: productConfig.pricePerSquareMeter || 0,
      totalPrice: calculated.totalPrice,
      description: productConfig.description || '',
      currency: 'تومان', // Use Toman currency
      // Unit information for proper display
      lengthUnit: lengthUnit,
      widthUnit: widthUnit,
      // Mandatory pricing fields
      isMandatory: isMandatory,
      mandatoryPercentage: mandatoryPercentage,
      originalTotalPrice: calculated.originalTotalPrice,
      // Stone cutting fields - Use data from productConfig if available, or auto-select if width < original
      // Only mark as cut if we have a valid cutting cost per meter, otherwise the summary won't show
      isCut: (productConfig.isCut || shouldAutoSelectLongitudinalCut) && finalCuttingCostPerMeter > 0,
      cutType: productConfig.cutType || (shouldAutoSelectLongitudinalCut && finalCuttingCostPerMeter > 0 ? 'longitudinal' : null),
      // Preserve originalWidth if editing, otherwise use selectedProduct.widthValue
      originalWidth: (isEditMode && productConfig.originalWidth) ? productConfig.originalWidth : selectedProduct.widthValue,
      // Store originalLength when product is first created (when not from remaining stone)
      // For products created from remaining stone, originalLength is set in handleCreateFromRemainingStone
      originalLength: (isEditMode && productConfig.originalLength !== undefined) 
        ? productConfig.originalLength 
        : (lengthUnit === 'm' ? calculated.length : (calculated.length / 100)),
      cuttingCost: finalCuttingCost,
      cuttingCostPerMeter: finalCuttingCostPerMeter,
      cutDescription: productConfig.cutDescription || (shouldAutoSelectLongitudinalCut ? `برش طولی خودکار (${originalWidth}cm → ${userEnteredWidthInCm.toFixed(2)}cm)` : ''),
      // Preserve remaining stones and cut details when editing, otherwise initialize empty
      remainingStones: (isEditMode && productConfig.remainingStones) ? productConfig.remainingStones : [],
      cutDetails: (isEditMode && productConfig.cutDetails) ? productConfig.cutDetails : [],
      // Preserve remaining stone usage tracking when editing
      usedRemainingStones: (isEditMode && productConfig.usedRemainingStones) ? productConfig.usedRemainingStones : [],
      totalUsedRemainingWidth: (isEditMode && productConfig.totalUsedRemainingWidth) ? productConfig.totalUsedRemainingWidth : 0,
      totalUsedRemainingLength: (isEditMode && productConfig.totalUsedRemainingLength) ? productConfig.totalUsedRemainingLength : 0,
      // SubService tracking - preserve when editing
      appliedSubServices: (isEditMode && productConfig.appliedSubServices) ? productConfig.appliedSubServices : [],
      totalSubServiceCost: (isEditMode && productConfig.totalSubServiceCost !== undefined) ? productConfig.totalSubServiceCost : 0,
      usedLengthForSubServices: (isEditMode && productConfig.usedLengthForSubServices !== undefined) ? productConfig.usedLengthForSubServices : 0,
      usedSquareMetersForSubServices: (isEditMode && productConfig.usedSquareMetersForSubServices !== undefined) ? productConfig.usedSquareMetersForSubServices : 0
    };
    
    // Add SubService costs to totalPrice if they exist
    const existingSubServiceCost = (isEditMode && productConfig.totalSubServiceCost) ? productConfig.totalSubServiceCost : 0;
    finalProduct.totalPrice = calculated.totalPrice + existingSubServiceCost;
    
    // Add to contract or update existing product
    if (isEditMode && editingProductIndex !== null) {
      // Update existing product
      const updatedProducts = [...wizardData.products];
      updatedProducts[editingProductIndex] = finalProduct;
      updateWizardData({
        products: updatedProducts
      });
    } else {
      // Add new product
      updateWizardData({
        products: [...wizardData.products, finalProduct]
      });
    }
    
    console.log('✅ Successfully added main product to contract!', {
      finalProduct: finalProduct,
      isEditMode: isEditMode,
      editingProductIndex: editingProductIndex,
      totalProducts: isEditMode ? wizardData.products.length : wizardData.products.length + 1
    });
    
    // Close modal and reset state
    setShowProductModal(false);
    setSelectedProduct(null);
    setProductConfig({});
    setLengthUnit('m');
    setWidthUnit('cm');
    setIsMandatory(false);
    setMandatoryPercentage(20);
    setIsEditMode(false);
    setEditingProductIndex(null);
    setTouchedFields(new Set()); // Reset touched fields
    setErrors({});
  };

  // Partition management handlers
  const handleAddPartition = () => {
    setPartitions(prev => [...prev, {
      id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      width: 0,
      length: 0,
      squareMeters: 0
    }]);
  };

  const handleRemovePartition = (partitionId: string) => {
    setPartitions(prev => prev.filter(p => p.id !== partitionId));
  };
  const handleUpdatePartition = (partitionId: string, field: 'width' | 'length', value: number) => {
    setPartitions(prev => {
      const updated = prev.map(p => {
        if (p.id === partitionId) {
          const updatedPartition = { ...p, [field]: value, validationError: undefined }; // Clear error on update
          // Auto-calculate square meters
          if (updatedPartition.width > 0 && updatedPartition.length > 0) {
            const widthInCm = partitionWidthUnit === 'm' ? updatedPartition.width * 100 : updatedPartition.width;
            const lengthInMeters = partitionLengthUnit === 'm' ? updatedPartition.length : (updatedPartition.length / 100);
            updatedPartition.squareMeters = (widthInCm * lengthInMeters * 100) / 10000;
          } else {
            updatedPartition.squareMeters = 0;
          }
          return updatedPartition;
        }
        return p;
      });
      
      // Real-time validation when selectedRemainingStone is available
      if (selectedRemainingStone) {
        const validPartitions = updated
          .filter(p => p.width > 0 && p.length > 0)
          .map(p => ({
            ...p,
            width: partitionWidthUnit === 'm' ? p.width * 100 : p.width, // Convert to cm
            length: partitionLengthUnit === 'm' ? p.length : p.length / 100, // Convert to meters
            squareMeters: (partitionWidthUnit === 'm' ? p.width * 100 : p.width) * 
                          (partitionLengthUnit === 'm' ? p.length : p.length / 100) * 100 / 10000
          }));
        
        if (validPartitions.length > 0) {
          const validation = validatePartitions(
            validPartitions,
            selectedRemainingStone.width, // in cm
            selectedRemainingStone.length, // in meters
            selectedRemainingStone.squareMeters
          );
          
          // Map validation errors back to original partition IDs
          const updatedWithErrors = updated.map(p => {
            const convertedP = {
              ...p,
              width: partitionWidthUnit === 'm' ? p.width * 100 : p.width,
              length: partitionLengthUnit === 'm' ? p.length : p.length / 100
            };
            const error = validation.partitionErrors.get(convertedP.id);
            return error ? { ...p, validationError: error } : { ...p, validationError: undefined };
          });
          
          setPartitionValidationErrors(validation.partitionErrors);
          return updatedWithErrors;
        } else {
          setPartitionValidationErrors(new Map());
        }
      }
      
      return updated;
    });
  };

  // Handle adding remaining stone product to contract (now with partitions)
  const handleAddRemainingStoneToContract = () => {
    console.log('🚀 handleAddRemainingStoneToContract called with partitions!');
    
    if (!selectedRemainingStone) {
      console.log('❌ Missing selectedRemainingStone');
      setErrors({ products: 'سنگ باقی‌مانده انتخاب نشده است' });
      return;
    }
    
    // Convert partition units to consistent units (cm for width, meters for length)
    const validPartitions = partitions
      .filter(p => p.width > 0 && p.length > 0)
      .map(p => ({
        ...p,
        width: partitionWidthUnit === 'm' ? p.width * 100 : p.width, // Convert to cm
        length: partitionLengthUnit === 'm' ? p.length : p.length / 100, // Convert to meters
        squareMeters: (partitionWidthUnit === 'm' ? p.width * 100 : p.width) * 
                      (partitionLengthUnit === 'm' ? p.length : p.length / 100) * 100 / 10000
      }));
    
    // Validate partitions
    const validation = validatePartitions(
      validPartitions,
      selectedRemainingStone.width, // in cm
      selectedRemainingStone.length, // in meters
      selectedRemainingStone.squareMeters
    );
    
    if (!validation.isValid) {
      // Update partition errors state for UI display
      setPartitionValidationErrors(validation.partitionErrors);
      // Update partitions with validation errors
      setPartitions(validation.validatedPartitions);
      setErrors({ products: validation.error || 'خطا در اعتبارسنجی پارتیشن‌ها' });
      return;
    }
    
    // Clear validation errors if validation passes
    setPartitionValidationErrors(new Map());
    
    // Calculate positions for partitions
    const positionedPartitions = calculatePartitionPositions(
      validPartitions,
      selectedRemainingStone.width,
      selectedRemainingStone.length
    );
    
    // Get cutting cost per meter from source product (if available) or from cutting types service
    const sourceProduct = selectedRemainingStoneSourceProduct || 
      wizardData.products.find(p => 
        (p.remainingStones || []).some(rs => rs.id === selectedRemainingStone.id) ||
        (p.usedRemainingStones || []).some(rs => rs.id === selectedRemainingStone.id)
      );
    
    const cuttingCostPerMeter = sourceProduct?.cuttingCostPerMeter || 
      getCuttingTypePricePerMeter('LONG') || 0;
    
    // Convert each partition to a RemainingStone entry (preserve position for canvas visualization)
    // Calculate cutting cost for each partition if it requires a cut
    const partitionRemainingStones: RemainingStone[] = positionedPartitions
      .filter(p => p.position && p.width > 0 && p.length > 0)
      .map((partition, index) => {
        // Determine if this partition needs a cut (if partition width < remaining stone width)
        const needsCut = partition.width < selectedRemainingStone.width;
        const cutType: 'longitudinal' | 'cross' | null = needsCut ? 'longitudinal' : null;
        
        // Calculate cutting cost: length (in meters) * cost per meter * quantity
        // For partitions, quantity is typically 1, but we'll use 1 as default
        const partitionQuantity = 1; // Partitions are typically single pieces
        const cuttingCost = needsCut && cuttingCostPerMeter > 0 
          ? partition.length * cuttingCostPerMeter * partitionQuantity 
          : 0;
        
        return {
          id: `partition_remaining_${Date.now()}_${index}`,
          width: partition.width, // Already in cm
          length: partition.length, // Already in meters
          squareMeters: partition.squareMeters,
          isAvailable: true,
          sourceCutId: selectedRemainingStone.sourceCutId,
          position: partition.position, // Preserve position for canvas visualization
          // Add cutting cost information for this partition
          cuttingCost: cuttingCost,
          cuttingCostPerMeter: cuttingCostPerMeter,
          cutType: cutType,
          quantity: partitionQuantity
        };
      });
    
    // Calculate remaining areas after partitions
    const remainingAreas = calculateRemainingAreasAfterPartitions(
      positionedPartitions,
      selectedRemainingStone.width,
      selectedRemainingStone.length
    );
    
    // CRITICAL: Partitions are "used" pieces, not remaining pieces!
    // Only actual gaps (remainingAreas) should be added to remainingStones
    // Partitions should be added to usedRemainingStones
    
    // Find source product and update it
    // CRITICAL: For 'primary-remaining', use the stored sourceProduct reference
    // For other remaining stones, find the product that contains the selectedRemainingStone
    let sourceProductFound = false;
    let targetProduct: ContractProduct | null = null;
    
    // Special handling for 'primary-remaining' - it's a synthetic ID, not stored in remainingStones array
    if (selectedRemainingStone.id === 'primary-remaining' && selectedRemainingStoneSourceProduct) {
      // Find the product that matches the stored sourceProduct
      targetProduct = wizardData.products.find(
        p => p.stoneCode === selectedRemainingStoneSourceProduct.stoneCode && p.isCut
      ) || null;
      
      if (targetProduct) {
        sourceProductFound = true;
      }
    } else {
      // For regular remaining stones, find by ID in remainingStones array
      targetProduct = wizardData.products.find(product => {
        return (product.remainingStones || []).some(
          rs => rs.id === selectedRemainingStone.id
        );
      }) || null;
      
      if (targetProduct) {
        sourceProductFound = true;
      }
    }
    
    const updatedProducts = wizardData.products.map(product => {
      // Check if this is the target product
      const isTargetProduct = targetProduct && (
        product.stoneCode === targetProduct.stoneCode ||
        (selectedRemainingStone.id === 'primary-remaining' 
          ? product.stoneCode === selectedRemainingStoneSourceProduct?.stoneCode && product.isCut
          : (product.remainingStones || []).some(rs => rs.id === selectedRemainingStone.id))
      );
      
      if (isTargetProduct) {
        sourceProductFound = true;
        
        // Calculate total used width and length from all partitions
        const totalUsedWidth = validPartitions.reduce((sum, p) => sum + p.width, 0);
        const totalUsedLength = Math.max(...validPartitions.map(p => p.length), 0);
        
        console.log('🔍 Updating source product with partitions:', {
          productStoneCode: product.stoneCode,
          selectedRemainingStoneId: selectedRemainingStone.id,
          selectedRemainingStone: selectedRemainingStone,
          currentRemainingStonesCount: (product.remainingStones || []).length,
          partitions: validPartitions.length,
          partitionRemainingStones: partitionRemainingStones.length,
          remainingAreas: remainingAreas.length,
          totalUsedWidth,
          totalUsedLength
        });
        
        // CRITICAL: For 'primary-remaining', we don't need to remove it from remainingStones
        // because it's not stored there - it's calculated on-the-fly by the canvas
        // For other remaining stones, remove the original from remainingStones array
        let remainingStonesWithoutUsed: RemainingStone[] = [];
        
        if (selectedRemainingStone.id === 'primary-remaining') {
          // Primary remaining is synthetic - keep existing remainingStones as-is
          remainingStonesWithoutUsed = product.remainingStones || [];
        } else {
          // Remove the used remaining stone from array
          remainingStonesWithoutUsed = (product.remainingStones || []).filter(
            rs => rs.id !== selectedRemainingStone.id
          );
        }
        
        console.log('🔍 Remaining stones update:', {
          isPrimaryRemaining: selectedRemainingStone.id === 'primary-remaining',
          before: (product.remainingStones || []).length,
          removed: selectedRemainingStone.id === 'primary-remaining' ? 'none (synthetic)' : selectedRemainingStone.id,
          newCount: remainingStonesWithoutUsed.length,
          addingPartitions: partitionRemainingStones.length,
          addingRemainingAreas: remainingAreas.length,
          after: remainingStonesWithoutUsed.length + remainingAreas.length
        });
        
        // Update product:
        // 1. Add the original selectedRemainingStone to usedRemainingStones (what was used to create partitions)
        // 2. Add partitionRemainingStones to usedRemainingStones (the partitions themselves are "used" pieces)
        // 3. Add only remainingAreas to remainingStones (actual gaps left after partitions)
        return {
          ...product,
          usedRemainingStones: [
            ...(product.usedRemainingStones || []),
            // Add the original remaining stone that was used (if not primary-remaining)
            ...(selectedRemainingStone.id !== 'primary-remaining' ? [selectedRemainingStone] : []),
            // Add all partitions as "used" pieces
            ...partitionRemainingStones
          ],
          remainingStones: [
            ...remainingStonesWithoutUsed,
            // Add only actual remaining areas (gaps), NOT partitions
            ...remainingAreas.map(area => ({
              ...area,
              sourceCutId: selectedRemainingStone.sourceCutId
            }))
          ],
          // Recalculate from usedRemainingStones array for consistency
          ...(() => {
            const updatedUsedStones = [
              ...(product.usedRemainingStones || []),
              ...(selectedRemainingStone.id !== 'primary-remaining' ? [selectedRemainingStone] : []),
              ...partitionRemainingStones
            ];
            const recalculated = recalculateUsedRemainingDimensions(updatedUsedStones);
            return {
              totalUsedRemainingWidth: recalculated.totalUsedWidth,
              totalUsedRemainingLength: recalculated.totalUsedLength
            };
          })()
        };
      }
      return product;
    });
    
    if (!sourceProductFound) {
      console.error('❌ Source product not found for remaining stone:', selectedRemainingStone);
      setErrors({ products: 'خطا در پیدا کردن محصول منبع' });
      return;
    }
    
    // Update wizard data
    updateWizardData({
      products: updatedProducts
    });
    
    console.log('✅ Successfully added partitions!', {
      partitions: validPartitions.length,
      partitionRemainingStones: partitionRemainingStones.length,
      remainingAreas: remainingAreas.length,
      updatedProducts: updatedProducts.map(p => ({
        stoneCode: p.stoneCode,
        remainingStonesCount: (p.remainingStones || []).length,
        usedRemainingStonesCount: (p.usedRemainingStones || []).length,
        remainingStones: (p.remainingStones || []).map(rs => ({
          id: rs.id,
          width: rs.width,
          length: rs.length,
          hasPosition: !!rs.position
        })),
        usedRemainingStones: (p.usedRemainingStones || []).map(rs => ({
          id: rs.id,
          width: rs.width,
          length: rs.length,
          hasPosition: !!rs.position
        }))
      }))
    });
    
    // Close modal and reset state
    setShowRemainingStoneModal(false);
    setSelectedRemainingStone(null);
    setSelectedRemainingStoneSourceProduct(null); // Clear source product reference
    setRemainingStoneConfig({});
    setPartitions([{
      id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      width: 0,
      length: 0,
      squareMeters: 0
    }]);
    setRemainingStoneLengthUnit('cm');
    setRemainingStoneWidthUnit('cm');
    setPartitionLengthUnit('m');
    setPartitionWidthUnit('cm');
    setRemainingStoneIsMandatory(false);
    setRemainingStoneMandatoryPercentage(20);
    setErrors({});
  };

  const validateCurrentStep = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    switch (currentStep) {
      case 1:
        if (!wizardData.contractDate) {
          newErrors.contractDate = 'تاریخ قرارداد الزامی است';
        }
        break;
      case 2:
        if (!wizardData.customerId) {
          newErrors.customerId = 'انتخاب مشتری الزامی است';
        }
        break;
      case 3:
        if (!wizardData.projectId) {
          newErrors.projectId = 'انتخاب پروژه الزامی است';
        }
        break;
      case 4: // NEW: Product Type Selection
        if (!wizardData.selectedProductTypeForAddition) {
          newErrors.productType = 'انتخاب نوع محصول الزامی است';
        }
        break;
      case 5: // Updated: Product Selection (was 4)
        if (wizardData.products.length === 0) {
          newErrors.products = 'انتخاب حداقل یک محصول الزامی است';
        }
        break;
      case 6: // Updated: Delivery Schedule (was 5)
        if (wizardData.deliveries.length === 0) {
          newErrors.deliveries = 'تعیین حداقل یک تحویل الزامی است';
        } else {
          // Validate each delivery
          wizardData.deliveries.forEach((delivery, index) => {
            if (!delivery.deliveryDate) {
              newErrors[`delivery_${index}_date`] = 'تاریخ تحویل الزامی است';
            }
            if (!delivery.projectManagerName || delivery.projectManagerName.trim() === '') {
              newErrors[`delivery_${index}_projectManager`] = 'نام مدیر پروژه الزامی است';
            }
            if (!delivery.receiverName || delivery.receiverName.trim() === '') {
              newErrors[`delivery_${index}_receiver`] = 'نام تحویل‌گیرنده الزامی است';
            }
            if (delivery.products.length === 0) {
              newErrors[`delivery_${index}_products`] = 'حداقل یک محصول باید در تحویل وجود داشته باشد';
            }
          });
          
          // Validate that all products are distributed across deliveries
          const totalProductQuantities = new Map<number, number>();
          wizardData.products.forEach((product, index) => {
            totalProductQuantities.set(index, product.quantity);
          });
          
          wizardData.deliveries.forEach(delivery => {
            delivery.products.forEach(dp => {
              const current = totalProductQuantities.get(dp.productIndex) || 0;
              totalProductQuantities.set(dp.productIndex, current - dp.quantity);
            });
          });
          
          // Check for over-delivery
          totalProductQuantities.forEach((remaining, productIndex) => {
            if (remaining < 0) {
              const product = wizardData.products[productIndex];
              newErrors.deliveries = `تعداد تحویل شده برای "${product.stoneName || product.product?.namePersian || 'محصول'}" بیشتر از تعداد کل است`;
            }
          });
          
          // Check that all products are fully distributed
          const undistributedProducts: string[] = [];
          totalProductQuantities.forEach((remaining, productIndex) => {
            if (remaining > 0) {
              const product = wizardData.products[productIndex];
              undistributedProducts.push(
                `"${product.stoneName || product.product?.namePersian || 'محصول'}" (${formatDisplayNumber(remaining)} عدد باقیمانده)`
              );
            }
          });
          
          if (undistributedProducts.length > 0) {
            newErrors.deliveries = `تمام محصولات باید در تحویل‌ها توزیع شوند. محصولات زیر هنوز به طور کامل توزیع نشده‌اند: ${undistributedProducts.join('، ')}`;
          }
        }
        break;
      case 7: // Payment Method
        // At least one payment entry is required
        if (wizardData.payment.payments.length === 0) {
          newErrors.paymentMethod = 'حداقل یک پرداخت باید اضافه شود';
        } else {
          // Validate each payment entry
          wizardData.payment.payments.forEach((payment, index) => {
            if (!payment.method) {
              newErrors.paymentMethod = `نوع پرداخت برای پرداخت #${index + 1} الزامی است`;
              return;
            }
            if (!payment.amount || payment.amount <= 0) {
              newErrors.paymentMethod = `مبلغ برای پرداخت #${index + 1} باید بیشتر از صفر باشد`;
              return;
            }
            if (!payment.status) {
              newErrors.paymentMethod = `وضعیت برای پرداخت #${index + 1} الزامی است`;
              return;
        }
            if (!payment.paymentDate) {
              newErrors.paymentMethod = `تاریخ برای پرداخت #${index + 1} الزامی است`;
              return;
            }
            // Validate conditional fields
            if (payment.method === 'CHECK' && !payment.checkNumber) {
              newErrors.paymentMethod = `شماره چک برای پرداخت #${index + 1} (چک) الزامی است`;
              return;
            }
            if (payment.method === 'CHECK' && !payment.nationalCode) {
              newErrors.paymentMethod = `کد ملی برای پرداخت #${index + 1} (چک) الزامی است`;
              return;
            }
            if (payment.method === 'CASH' && !payment.cashType) {
              newErrors.paymentMethod = `نوع پرداخت نقدی برای پرداخت #${index + 1} (نقدی) الزامی است`;
              return;
            }
          });
        }
        break;
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Reset delivery step selection when leaving the step
  useEffect(() => {
    if (currentStep !== 6) {
      setSelectedProductIndices(new Set());
      setSelectAllProducts(false);
    }
  }, [currentStep]);

  const goToNextStep = () => {
    if (validateCurrentStep()) {
      setCurrentStep(prev => Math.min(prev + 1, WIZARD_STEPS.length));
      setErrors({});
    }
  };

  const goToPreviousStep = () => {
    setCurrentStep(prev => Math.max(prev - 1, 1));
    setErrors({});
  };

  const handleCreateContract = async () => {
    if (!validateCurrentStep()) return;
    
    setLoading(true);
    try {
      // Calculate total amount
      const totalAmount = wizardData.products.reduce((sum, product) => sum + product.totalPrice, 0);
      
      // Create contract
      const contractData = {
        title: 'قرارداد فروش سبلان استون',
        titlePersian: 'قرارداد فروش سبلان استون',
        customerId: wizardData.customerId,
        departmentId: userDepartment || departments[0]?.id || 'default-department-id', // Use user's department or fallback
        content: generateContractHTML({
          contractNumber: wizardData.contractNumber,
          contractDate: wizardData.contractDate,
          customer: wizardData.customer,
          project: wizardData.project,
          products: wizardData.products,
          deliveries: wizardData.deliveries,
          payment: wizardData.payment
        }),
        contractData: {
          contractNumber: wizardData.contractNumber,
          contractDate: wizardData.contractDate,
          customer: wizardData.customer,
          project: wizardData.project,
          products: wizardData.products,
          deliveries: wizardData.deliveries,
          payment: wizardData.payment
        },
        totalAmount,
        currency: 'تومان'
      };
      
      console.log('Sending contract data:', contractData);
      const response = await salesAPI.createContract(contractData);
      console.log('Contract creation response:', response.data);
      
      if (response.data.success) {
        const contractId = response.data.data.id;
        
        // Store contract ID in signature state for Step 8
        setWizardData(prev => ({
          ...prev,
          signature: {
            ...prev.signature || {
              phoneNumber: null,
              verificationCode: '',
              codeSent: false,
              codeVerified: false,
              contractId: null
            },
            contractId: contractId
          }
        }));
        
        // Create contract items
        for (const product of wizardData.products) {
          await salesAPI.createContractItem(contractId, {
            productId: product.productId,
            productType: product.productType,
            quantity: product.quantity,
            unitPrice: product.pricePerSquareMeter,
            totalPrice: product.totalPrice,
            description: product.description || null,
            isMandatory: product.isMandatory || false,
            mandatoryPercentage: product.mandatoryPercentage || null,
            originalTotalPrice: product.originalTotalPrice || null,
            // Stair system linking fields
            stairSystemId: product.stairSystemId || null,
            stairPartType: product.stairPartType || null
          });
        }
        
        // Create deliveries
        for (const delivery of wizardData.deliveries) {
          await salesAPI.createDelivery(contractId, {
            deliveryDate: delivery.deliveryDate,
            deliveryAddress: wizardData.project?.address || '', // Use project address
            driver: delivery.projectManagerName || undefined, // Map projectManagerName to driver field (for backward compatibility)
            vehicle: delivery.receiverName || undefined, // Map receiverName to vehicle field (for backward compatibility)
            notes: delivery.notes,
            products: delivery.products.map(dp => {
              const product = wizardData.products[dp.productIndex];
              return {
                productId: dp.productId,
                quantity: dp.quantity,
                notes: product?.description || ''
              };
            })
          });
        }
        
        // Create payments (compound payments - one per entry)
        for (const paymentEntry of wizardData.payment.payments) {
          // Convert Persian date to JavaScript Date
          let paymentDate: Date | undefined;
          if (paymentEntry.paymentDate) {
            try {
              paymentDate = PersianCalendar.toGregorian(paymentEntry.paymentDate, 'jYYYY/jMM/jDD');
            } catch (error) {
              console.error('Error converting Persian date:', error);
            }
          }

          // Map status: PAID -> COMPLETED, WILL_BE_PAID -> PENDING
          const paymentStatus = paymentEntry.status === 'PAID' ? 'COMPLETED' : 'PENDING';

        await salesAPI.createPayment(contractId, {
            paymentMethod: paymentEntry.method,
            totalAmount: paymentEntry.amount,
          currency: wizardData.payment.currency,
            status: paymentStatus,
            paymentDate: paymentDate?.toISOString(),
            checkNumber: paymentEntry.checkNumber,
            cashType: paymentEntry.cashType,
            nationalCode: paymentEntry.nationalCode,
            notes: paymentEntry.description
        });
        }
        
        // Move to Step 8 (Digital Signature) instead of redirecting
        setCurrentStep(8);
      } else {
        setErrors({ general: response.data.error || 'خطا در ایجاد قرارداد' });
      }
    } catch (error: any) {
      console.error('Error creating contract:', error);
      console.error('Error response:', error.response?.data);
      
      if (error.response?.data?.details) {
        // Show validation errors
        const validationErrors = error.response.data.details.map((err: any) => err.msg).join(', ');
        setErrors({ general: `خطاهای اعتبارسنجی: ${validationErrors}` });
      } else {
        setErrors({ general: error.response?.data?.error || 'خطا در ارتباط با سرور' });
      }
    } finally {
      setLoading(false);
    }
  };
  const renderStepContent = () => {
    switch (currentStep) {
      case 1:
        return (
          <Step1ContractDate
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            currentUser={currentUser || undefined}
          />
        );
        
      case 2:
        return (
          <Step2CustomerSelection
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            customerSearchTerm={customerSearchTerm}
            setCustomerSearchTerm={setCustomerSearchTerm}
            customers={customers}
            filteredCustomers={filteredCustomers}
            currentStep={currentStep}
          />
        );
        
      case 3:
        return (
          <Step3ProjectManagement
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            currentStep={currentStep}
          />
        );
        
      case 4: // NEW: Product Type Selection
        return (
          <Step4ProductTypeSelection
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
          />
        );
      case 5: // Updated: Product Selection (was case 4)
        // Conditional rendering based on product type
        const selectedProductType = wizardData.selectedProductTypeForAddition;
        
        if (!selectedProductType) {
          return (
            <div className="space-y-6">
              <div className="text-center">
                <p className="text-red-500">لطفاً ابتدا نوع محصول را انتخاب کنید</p>
              </div>
            </div>
          );
        }
        
        return (
          <Step5ProductSelection
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            productSearchTerm={productSearchTerm}
            setProductSearchTerm={setProductSearchTerm}
            products={products}
            filteredProducts={filteredProducts}
            handleProductSelection={handleProductSelection}
            setShowProductModal={setShowProductModal}
            setSelectedProductForConfiguration={setSelectedProduct}
            setSelectedProductIndexForEdit={setEditingProductIndex}
            handleRemoveProduct={(index) => {
              const newProducts = wizardData.products.filter((_, i) => i !== index);
              updateWizardData({ products: newProducts });
            }}
            currentStep={currentStep}
            productsSummary={productsSummary}
          />
        );
        
      case 6: // Delivery Schedule
        return (
          <Step6DeliverySchedule
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
          />
        );
        
      case 7: // Payment Method
        return (
          <Step7PaymentMethod
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            showPaymentEntryModal={showPaymentEntryModal}
            setShowPaymentEntryModal={setShowPaymentEntryModal}
          />
        );
        
      case 8: // Digital Signature
        return (
          <Step8DigitalSignature
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            sendingCode={sendingCode}
            verifyingCode={verifyingCode}
            countdown={countdown || 0}
            handleSendVerificationCode={handleSendVerificationCode}
            handleVerifyCode={handleVerifyCode}
            handlePhoneNumberChange={(phoneNumber: string) => {
              updateWizardData({
                signature: {
                  ...wizardData.signature!,
                  phoneNumber
                }
              });
            }}
            handleVerificationCodeChange={(code: string) => {
              updateWizardData({
                signature: {
                  ...wizardData.signature!,
                  verificationCode: code
                }
              });
            }}
          />
        );
        
      default:
        return null;
    }
  };
  
  // Legacy code removed - component is used above
  // The unreachable code block has been removed to fix linter errors
  
  if (loading && currentStep === 1) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-500"></div>
      </div>
    );
  }

  // Removed orphaned generateContractHTML function - using the correct one below

  const generateContractHTML = (data: any) => {
    const productsTable = data.products && data.products.length > 0 ? `
      <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
        <thead>
          <tr style="background-color: #f5f5f5;">
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">نام محصول</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">ابعاد</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">تعداد</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">متر مربع</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">فی</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">قیمت کل</th>
          </tr>
        </thead>
        <tbody>
          ${data.products.map((product: any) => `
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.product?.namePersian || product.product?.name || product.namePersian || product.name || 'نامشخص'}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.product?.widthValue && product.product?.thicknessValue ? `${product.product.widthValue} × ${product.product.thicknessValue}` : product.length && product.width ? `${product.length} × ${product.width}` : 'نامشخص'}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${formatQuantity(product.quantity || 0)}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${formatSquareMeters(product.product?.squareMeter || product.squareMeter || 0)}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.unitPrice ? formatPrice(product.unitPrice, product.currency || 'تومان') : 'نامشخص'}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.totalPrice ? formatPrice(product.totalPrice, product.currency || 'تومان') : 'نامشخص'}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    ` : '';

    const deliveriesSection = data.deliveries && data.deliveries.length > 0 ? `
      <h3>برنامه تحویل:</h3>
      <ul>
        ${data.deliveries.map((delivery: any) => `
          <li>تاریخ: ${delivery.deliveryDate} - ${delivery.notes || 'بدون توضیحات'}</li>
        `).join('')}
      </ul>
    ` : '';

    return `
      <div style="font-family: 'Tahoma', sans-serif; direction: rtl; text-align: right;">
        <h1 style="text-align: center; color: #333;">قرارداد فروش سبلان استون</h1>
        
        <div style="margin: 20px 0;">
          <p><strong>شماره قرارداد:</strong> ${data.contractNumber}</p>
          <p><strong>تاریخ قرارداد:</strong> ${data.contractDate}</p>
        </div>

        <div style="margin: 20px 0;">
          <h3>اطلاعات مشتری:</h3>
          <p><strong>نام:</strong> ${data.customer?.firstName} ${data.customer?.lastName}</p>
          ${data.customer?.companyName ? `<p><strong>نام شرکت:</strong> ${data.customer.companyName}</p>` : ''}
          ${data.customer?.phoneNumbers && data.customer.phoneNumbers.length > 0 ? `<p><strong>شماره تماس:</strong> ${data.customer.phoneNumbers[0].number}</p>` : ''}
        </div>

        ${data.project ? `
          <div style="margin: 20px 0;">
            <h3>اطلاعات پروژه:</h3>
            <p><strong>آدرس پروژه:</strong> ${data.project.address || 'نامشخص'}</p>
            <p><strong>نام پروژه:</strong> ${data.project.name || 'نامشخص'}</p>
          </div>
        ` : ''}

        <div style="margin: 20px 0;">
          <h3>اقلام قرارداد:</h3>
          ${productsTable}
        </div>

        ${data.payment ? `
          <div style="margin: 20px 0;">
            <h3>اطلاعات پرداخت:</h3>
            <p><strong>نحوه پرداخت:</strong> ${data.payment.method}</p>
            <p><strong>مبلغ کل:</strong> ${data.payment.totalAmount ? formatPrice(data.payment.totalAmount, data.payment.currency || 'تومان') : 'نامشخص'}</p>
          </div>
        ` : ''}

        ${deliveriesSection}

        <div style="margin-top: 40px; text-align: center;">
          <p>این قرارداد در تاریخ ${data.contractDate} منعقد شده است.</p>
        </div>
      </div>
    `;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 py-8 relative z-0">
      <div className="max-w-6xl mx-auto px-4 relative z-0">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-800 dark:text-white mb-2">
            ایجاد قرارداد جدید
          </h1>
          <p className="text-gray-600 dark:text-gray-300">
            مراحل ایجاد قرارداد را تکمیل کنید
          </p>
        </div>

        {/* Progress Bar */}
        <WizardProgressBar currentStep={currentStep} steps={WIZARD_STEPS as WizardStep[]} />

        {/* Step Content */}
        <div className="glass-liquid-card p-8 mb-8 relative z-0">
          {renderStepContent()}
        </div>

        {/* Navigation */}
        <WizardNavigation
          currentStep={currentStep}
          totalSteps={WIZARD_STEPS.length}
          onPrevious={goToPreviousStep}
          onNext={goToNextStep}
          onSubmit={handleCreateContract}
          loading={loading}
          canGoNext={true}
          canGoPrevious={currentStep > 1}
        />

        {/* Error Display */}
        {errors.general && (
          <div className="mt-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
            <p className="text-red-600 dark:text-red-400">{errors.general}</p>
          </div>
        )}

        {/* Product Configuration Modal */}
        {showProductModal && useStairFlowV2 && productConfig.productType === 'stair' && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999] p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] flex flex-col z-[10000]">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 flex items-center justify-between flex-shrink-0">
                <div className="flex items-center gap-3">
                  <div className="w-1 h-8 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                  <h3 className="text-xl font-bold text-purple-900 dark:text-purple-200">{isEditMode ? 'ویرایش محصول پله' : 'انتخاب محصول پله'}</h3>
                  {isEditMode && (
                    <span className="px-2.5 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-full text-xs font-semibold">
                      حالت ویرایش
                    </span>
                  )}
                </div>
                <button 
                  className="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg p-2 transition-colors" 
                  onClick={() => setShowProductModal(false)}
                  title="بستن"
                >
                  <FaTimes className="w-5 h-5" />
                </button>
              </div>
              
              {/* Step Indicators */}
              {(() => {
                const [currentDraft] = getActiveDraft();
                const hasStone = !!currentDraft.stoneId;
                const hasThickness = !!currentDraft.thicknessCm;
                const hasLength = hasLengthMeasurement(currentDraft);
                const hasWidth = !!currentDraft.widthCm;
                const hasQuantity = !!currentDraft.quantity;
                const hasSqm = !!currentDraft.squareMeters;
                const hasPrice = !!currentDraft.pricePerSquareMeter;
                const hasTools = (currentDraft.tools || []).length > 0;
                const hasTotal = !!currentDraft.totalPrice;
                
                return (
                  <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-900/50 dark:to-gray-800/50 flex-shrink-0">
                    <div className="flex items-center gap-2 overflow-x-auto">
                      <div className="flex items-center gap-1.5 text-xs whitespace-nowrap">
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${true ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>0. بخش</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasStone ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>1. نوع سنگ</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasThickness ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>2. قطر</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasLength ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>3. طول</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasWidth ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>4. عرض</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasQuantity ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>5. تعداد</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasSqm ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>6. متر مربع</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasPrice ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>7. قیمت</span>
                        <span className="text-gray-400 dark:text-gray-500">→</span>
                            <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasTools ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>8. ابزارها</span>
                            <span className="text-gray-400 dark:text-gray-500">→</span>
                        {stairActivePart !== 'riser' && (
                          <>
                            <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${
                              (currentDraft.numberOfLayersPerStair &&
                                currentDraft.numberOfLayersPerStair > 0 &&
                                currentDraft.layerWidthCm &&
                                currentDraft.pricePerSquareMeter &&
                                (layerTypes.length === 0 || currentDraft.layerTypeId))
                                ? 'bg-gradient-to-r from-orange-500 to-orange-600 text-white shadow-md'
                                : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'
                            }`}>9. لایه‌ها</span>
                            <span className="text-gray-400 dark:text-gray-500">→</span>
                          </>
                        )}
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasTotal ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>{stairActivePart !== 'riser' ? '10. جمع کل' : '9. جمع کل'}</span>
                      </div>
                    </div>
                  </div>
                );
              })()}
              
              <div className="flex-1 overflow-y-auto">
                <div className="p-6 space-y-6">
                  {/* Part Selector - Enhanced */}
                  <div className="bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 rounded-lg border border-purple-200 dark:border-purple-700 p-4">
                    <div className="flex items-center gap-3">
                      <div className="w-1 h-6 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                      <label className="text-sm font-semibold text-purple-900 dark:text-purple-200">بخش:</label>
                      <select 
                        className="flex-1 rounded-lg bg-white dark:bg-gray-800 px-4 py-2 border border-purple-300 dark:border-purple-600 text-gray-800 dark:text-white font-medium focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all" 
                        value={stairActivePart} 
                        onChange={(e) => setActivePart(e.target.value as StairStepperPart)}
                      >
                        <option value="tread">کف پله</option>
                        <option value="riser">خیز</option>
                        <option value="landing">پاگرد</option>
                      </select>
                    </div>
                  </div>
                {(() => {
                  const [draft, setDraft] = getActiveDraft();
                  const totals = computeTotalsV2(stairActivePart, draft);
                  const chargeableCuttingCost = totals.billableCuttingCost;
                  const chargeableCuttingCostLongitudinal = totals.billableCuttingCostLongitudinal;
                  const chargeableCuttingCostCross = totals.billableCuttingCostCross;
                  const draftErrors = stairDraftErrors[stairActivePart] || {};
                  const lengthMInfo = getActualLengthMeters(draft);
                  const selectedFinishing = stoneFinishings.find(option => option.id === draft.finishingId);
                  const finishingPricePerSquareMeter =
                    draft.finishingPricePerSquareMeter ??
                    selectedFinishing?.pricePerSquareMeter ??
                    null;
                  const finishingPreviewCost =
                    draft.finishingEnabled && finishingPricePerSquareMeter
                      ? totals.pricingSquareMeters * finishingPricePerSquareMeter
                      : 0;
                  const defaultMandatoryEnabled = stairActivePart === 'riser' || stairActivePart === 'landing';
                  const mandatoryEnabled = draft.useMandatory ?? defaultMandatoryEnabled;
                  const supportsMandatory = stairActivePart === 'tread' || stairActivePart === 'riser' || stairActivePart === 'landing';
                  const mandatoryPercentageValue = draft.mandatoryPercentage ?? 20;
                  return (
                    <div className="space-y-6">
                      {/* Input Fields Section - Enhanced */}
                      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                        <div className="flex items-center gap-2 mb-4">
                          <div className="w-1 h-5 bg-gradient-to-b from-teal-500 to-teal-600 rounded-full"></div>
                          <h5 className="text-sm font-semibold text-gray-800 dark:text-white">اطلاعات محصول</h5>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div className="md:col-span-2">
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                نوع سنگ
                              </span>
                            </label>
                            <div className="relative">
                              <input 
                                className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all" 
                                placeholder="جستجو در نوع برش، جنس سنگ، معدن، نوع پرداخت، رنگ/خصوصیات" 
                                value={stoneSearchTerm} 
                                onChange={(e) => setStoneSearchTerm(e.target.value)} 
                              />
                              {draft.stoneProduct && (
                                <div className="mt-2 p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg">
                                  <div className="text-sm font-medium text-teal-800 dark:text-teal-200">{draft.stoneLabel}</div>
                                  {draft.stoneProduct.basePrice && (
                                    <div className="text-xs text-teal-600 dark:text-teal-400 mt-1">
                                      قیمت: {formatPrice(draft.stoneProduct.basePrice)}
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                            {stoneSearchTerm && (
                              <div className="mt-2 max-h-48 overflow-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg">
                                {isSearchingStones && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">
                                    <span className="animate-pulse">در حال جستجو...</span>
                                  </div>
                                )}
                                {!isSearchingStones && stoneSearchResults.length === 0 && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">نتیجه‌ای یافت نشد</div>
                                )}
                                {stoneSearchResults.map((p: Product) => (
                                  <button 
                                    key={p.id} 
                                    type="button" 
                                    className="w-full text-right px-4 py-2.5 hover:bg-teal-50 dark:hover:bg-teal-900/20 text-sm border-b border-gray-100 dark:border-gray-700 last:border-0 transition-colors" 
                                    onClick={() => {
                                      selectProductForStairPart(stairActivePart, p);
                                    }}
                                  >
                                    {/* 🎯 Show complete product name using generateFullProductName */}
                                    <div className="font-medium text-gray-800 dark:text-white">
                                      {p.fullName || generateFullProductName(p) || p.namePersian || p.name}
                                    </div>
                                    {p.basePrice && (
                                      <div className="text-xs text-teal-600 dark:text-teal-400 mt-0.5">{formatPrice(p.basePrice)}</div>
                                    )}
                                  </button>
                                ))}
                              </div>
                            )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                قطر (سانتی‌متر)
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.stoneProduct?.thicknessValue ?? draft.thicknessCm ?? null}
                              onChange={(_value) => {}}
                              min={1}
                              step={1}
                              disabled
                              className="w-full rounded-lg bg-gray-100 dark:bg-gray-700/60 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-600 dark:text-gray-300 cursor-not-allowed"
                              placeholder="ابتدا محصول را انتخاب کنید"
                            />
                            <p className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                              قطر به صورت خودکار از مشخصات محصول انتخاب شده تنظیم می‌شود و قابل تغییر نیست.
                            </p>
                          {draftErrors.thickness && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.thickness}</p>
                          )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                طول
                              </span>
                            </label>
                            <div className="flex gap-2">
                              <FormattedNumberInput
                                value={draft.lengthValue ?? null}
                            onChange={(value) => {
                              const normalizedValue = value && value > 0 ? value : null;
                              const updatedDraft: StairPartDraftV2 = { ...draft, lengthValue: normalizedValue };
                              const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'length', value);
                              if (error) {
                                setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairActivePart]: { ...prev[stairActivePart], length: error }
                                }));
                              } else {
                                clearDraftFieldError(stairActivePart, 'length');
                              }
                              setDraft(updatedDraft);
                            }}
                                min={0}
                                step={0.01}
                                className="flex-1 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                                placeholder="مثال: 1.2"
                              />
                              <select 
                                className="rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all font-medium" 
                                value={draft.lengthUnit || 'm'} 
                                onChange={(e) => setDraft({ ...draft, lengthUnit: (e.target.value as UnitType) })}
                              >
                                <option value="cm">cm</option>
                                <option value="m">m</option>
                              </select>
                            </div>
                            {stairActivePart !== 'riser' && (
                            <div className="mt-3">
                              <label className="block text-xs font-medium text-gray-600 dark:text-gray-300 mb-1">
                                طول استاندارد (برای قیمت‌گذاری)
                              </label>
                              <div className="flex gap-2">
                                <FormattedNumberInput
                                  value={draft.standardLengthValue ?? null}
                                  onChange={(value) => {
                                    const normalized = value && value > 0 ? value : null;
                                    const updatedDraft: StairPartDraftV2 = { ...draft, standardLengthValue: normalized };
                                    if (normalized && normalized > 0) {
                                      clearDraftFieldError(stairActivePart, 'length');
                                    }
                                    setDraft(updatedDraft);
                                  }}
                                  min={0}
                                  step={0.01}
                                  className="flex-1 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                                  placeholder="مثال: 1.2"
                                />
                                <select 
                                  className="rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all font-medium" 
                                  value={draft.standardLengthUnit || draft.lengthUnit || 'm'} 
                                  onChange={(e) => setDraft({ ...draft, standardLengthUnit: (e.target.value as UnitType) })}
                                >
                                  <option value="m">m</option>
                                  <option value="cm">cm</option>
                                </select>
                              </div>
                              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                                اگر طول واقعی وارد نشود، از همین طول استاندارد برای محاسبه قیمت استفاده می‌شود.
                              </p>
                            </div>
                            )}
                          {draftErrors.length && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.length}</p>
                          )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                عرض (سانتی‌متر)
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.widthCm ?? null}
                            onChange={(value) => {
                              const updatedDraft = { ...draft, widthCm: value && value > 0 ? value : null };
                              // 🎯 Validate using comprehensive validation function
                              const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'width', value);
                              if (error) {
                                setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairActivePart]: { ...prev[stairActivePart], width: error }
                                }));
                              } else {
                                clearDraftFieldError(stairActivePart, 'width');
                              }
                              setDraft(updatedDraft);
                            }}
                              min={0}
                              step={0.1}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                              placeholder="مثال: 40"
                            />
                          {draftErrors.width && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.width}</p>
                          )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                تعداد
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.quantity ?? null}
                            onChange={(value) => {
                              // 🎯 Ensure integer value for quantity
                              const intValue = value ? Math.floor(value) : null;
                              const updatedDraft = { ...draft, quantity: intValue && intValue > 0 ? intValue : null };
                              // 🎯 Validate using comprehensive validation function
                              const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'quantity', intValue);
                              if (error) {
                                setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairActivePart]: { ...prev[stairActivePart], quantity: error }
                                }));
                              } else {
                                clearDraftFieldError(stairActivePart, 'quantity');
                              }
                              setDraft(updatedDraft);
                            }}
                              min={1}
                              step={1}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                              placeholder="مثال: 100"
                            />
                          {draftErrors.quantity && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.quantity}</p>
                          )}
                          </div>
                          {draft.stoneProduct && totals.piecesPerStone > 0 && totals.baseStoneQuantity > 0 && (
                            <div className="md:col-span-2">
                              <div className="mt-2 rounded-lg border border-teal-200 dark:border-teal-800 bg-teal-50 dark:bg-teal-900/20 px-4 py-3 text-xs leading-5 text-teal-700 dark:text-teal-200">
                                <div>
                                  از هر سنگ {formatDisplayNumber(totals.piecesPerStone)} قطعه با عرض {formatDisplayNumber(draft.widthCm ?? 0)} سانتی‌متر به دست می‌آید.
                                </div>
                                <div>
                                  تعداد سنگ پایه مورد نیاز: {formatDisplayNumber(totals.baseStoneQuantity)} عدد
                                  {totals.leftoverWidthCm > 0 ? ` • باقیمانده هر سنگ: ${formatDisplayNumber(totals.leftoverWidthCm)}cm` : ''}
                                </div>
                              </div>
                            </div>
                          )}
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-blue-500"></span>
                                متر مربع (خودکار)
                              </span>
                            </label>
                            <input 
                              className="w-full rounded-lg bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 px-4 py-2.5 text-blue-700 dark:text-blue-300 font-semibold cursor-not-allowed" 
                              value={formatDisplayNumber(totals.sqm)} 
                              readOnly 
                            />
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                قیمت هر متر مربع
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.pricePerSquareMeter ?? null}
                            onChange={(value) => {
                              const updatedDraft = { ...draft, pricePerSquareMeter: value && value > 0 ? value : null };
                              // 🎯 Validate using comprehensive validation function
                              const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'pricePerSquareMeter', value);
                              if (error) {
                                setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairActivePart]: { ...prev[stairActivePart], pricePerSquareMeter: error }
                                }));
                              } else {
                                clearDraftFieldError(stairActivePart, 'pricePerSquareMeter');
                              }
                              setDraft(updatedDraft);
                            }}
                              min={0}
                              step={1000}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                              placeholder="مثال: 1,500,000"
                            />
                          {draftErrors.pricePerSquareMeter && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.pricePerSquareMeter}</p>
                          )}
                          </div>
                          {supportsMandatory && (
                            <div className="md:col-span-2 rounded-lg border border-yellow-100 dark:border-yellow-800 bg-white dark:bg-gray-900/30 p-4">
                              <div className="flex items-center gap-2">
                                <input
                                  type="checkbox"
                                  className="rounded border-gray-300 text-yellow-600 focus:ring-yellow-500"
                                  checked={mandatoryEnabled}
                                  onChange={(e) => {
                                    const nextValue = e.target.checked;
                                    const updatedDraft = {
                                      ...draft,
                                      useMandatory: nextValue,
                                      mandatoryPercentage: nextValue ? (draft.mandatoryPercentage ?? 20) : null
                                    };
                                    if (!nextValue) {
                                      clearDraftFieldError(stairActivePart, 'mandatoryPercentage');
                                    }
                                    setDraft(updatedDraft);
                                  }}
                                />
                                <div>
                                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                    حکمی (افزایش قیمت)
                                  </label>
                                  <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                    در صورت فعال بودن، قیمت سنگ این بخش به صورت درصدی افزایش داده می‌شود.
                                  </p>
                                </div>
                              </div>
                              {mandatoryEnabled && (
                                <div className="mt-3 flex items-center gap-2">
                                  <FormattedNumberInput
                                    value={mandatoryPercentageValue}
                                    onChange={(value) => {
                                      const updatedDraft = { ...draft, mandatoryPercentage: value ?? 0 };
                                      const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'mandatoryPercentage', value);
                                      if (error) {
                                        setStairDraftErrors(prev => ({
                                          ...prev,
                                          [stairActivePart]: { ...prev[stairActivePart], mandatoryPercentage: error }
                                        }));
                                      } else {
                                        clearDraftFieldError(stairActivePart, 'mandatoryPercentage');
                                      }
                                      setDraft(updatedDraft);
                                    }}
                                    min={0}
                                    max={100}
                                    step={1}
                                    className="w-24 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent text-sm"
                                  />
                                  <span className="text-xs text-gray-600 dark:text-gray-300">%</span>
                                  <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                    قیمت پایه با {formatDisplayNumber(mandatoryPercentageValue)}% افزایش محاسبه می‌شود.
                                  </p>
                                </div>
                              )}
                              {draftErrors.mandatoryPercentage && (
                                <p className="mt-1 text-xs text-red-500">
                                  {draftErrors.mandatoryPercentage}
                                </p>
                              )}
                            </div>
                          )}
                          {totals.billableCuttingCost > 0 && (
                            <div className="md:col-span-2">
                              <div className="mt-2 rounded-lg border border-amber-200 dark:border-amber-700 bg-amber-50 dark:bg-amber-900/20 px-4 py-3 text-xs leading-5 text-amber-700 dark:text-amber-200">
                                {totals.billableCuttingCostLongitudinal > 0 && (
                                  <div>
                                    هزینه برش طولی: {formatPrice(totals.billableCuttingCostLongitudinal)} ({formatDisplayNumber(lengthMInfo)} m × {formatDisplayNumber(totals.baseStoneQuantity)} سنگ × {formatPrice(totals.shouldChargeCuttingCost ? (totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter) : 0)})
                                  </div>
                                )}
                                {totals.billableCuttingCostCross > 0 && (
                                  <div className="mt-1">
                                    هزینه برش عرضی: {formatPrice(totals.billableCuttingCostCross)} ({formatDisplayNumber((draft.widthCm || 0) / 100)} m × {formatDisplayNumber(totals.baseStoneQuantity)} سنگ × {formatPrice(totals.shouldChargeCuttingCost ? (totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter) : 0)})
                                  </div>
                                )}
                              </div>
                            </div>
                          )}
                        </div>
                      </div>

                      {/* Tools Section - Enhanced */}
                      {stairActivePart !== 'riser' && (
                      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                        <div className="flex items-center justify-between mb-4">
                          <div className="flex items-center gap-2">
                            <div className="w-1 h-5 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                            <h5 className="text-sm font-semibold text-gray-800 dark:text-white">ابزارها (بر متر)</h5>
                          </div>
                          {stairActivePart === 'landing' && (
                            <span className="text-xs text-purple-600 dark:text-purple-400 bg-purple-50 dark:bg-purple-900/20 px-2 py-1 rounded">مدل لبه پاگرد: محیط/جهت‌ها</span>
                          )}
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div>
                            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">افزودن ابزار</label>
                            <input 
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all" 
                              placeholder="جستجو در ابزارها" 
                              value={toolsSearchTerm} 
                              onChange={(e) => setToolsSearchTerm(e.target.value)} 
                              onFocus={() => setToolsDropdownOpen(true)} 
                              onBlur={() => setTimeout(() => setToolsDropdownOpen(false), 150)} 
                            />
                            {(toolsDropdownOpen || toolsSearchTerm) && (
                              <div className="mt-2 max-h-48 overflow-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg">
                                {isSearchingTools && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">
                                    <span className="animate-pulse">در حال جستجو...</span>
                                  </div>
                                )}
                                {!isSearchingTools && toolsResults.length === 0 && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">نتیجه‌ای یافت نشد</div>
                                )}
                                {toolsResults.map((t: any) => (
                                  <button 
                                    key={t.id} 
                                    type="button" 
                                    className="w-full text-right px-4 py-2.5 hover:bg-purple-50 dark:hover:bg-purple-900/20 text-sm border-b border-gray-100 dark:border-gray-700 last:border-0 transition-colors" 
                                    onClick={() => {
                                      const exists = (draft.tools || []).some(x => x.toolId === t.id);
                                      if (exists) return;
                                      setDraft({ ...draft, tools: [ ...(draft.tools || []), { toolId: t.id, name: t.namePersian || t.name, pricePerMeter: t.pricePerMeter || t.price || t.costPerMeter || 0, front: false, left: false, right: false, back: false, perimeter: false } ] });
                                      setToolsSearchTerm('');
                                      setToolsDropdownOpen(false);
                                    }}
                                  >
                                    <div className="font-medium text-gray-800 dark:text-white">{t.namePersian || t.name}</div>
                                    {(t.pricePerMeter || t.price || t.costPerMeter) && (
                                      <div className="text-xs text-purple-600 dark:text-purple-400 mt-0.5">
                                        {formatPrice(t.pricePerMeter || t.price || t.costPerMeter)}/m
                                      </div>
                                    )}
                                  </button>
                                ))}
                              </div>
                            )}
                          </div>

                          <div>
                            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">ابزارهای انتخاب شده و لبه‌ها</label>
                            {(draft.tools || []).length === 0 ? (
                              <div className="text-center py-8 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-dashed border-gray-300 dark:border-gray-600">
                                <p className="text-xs text-gray-400 dark:text-gray-500">ابزاری انتخاب نشده است.</p>
                              </div>
                            ) : (
                              <div className="space-y-2 max-h-64 overflow-y-auto">
                                {(draft.tools || []).map((tool, idx) => {
                                  const meters = computeToolMetersForTool(stairActivePart, draft, tool);
                                  const tp = meters * (tool.pricePerMeter || 0);
                                  return (
                                    <div key={tool.toolId} className="p-3 rounded-lg border border-purple-200 dark:border-purple-800 bg-purple-50 dark:bg-purple-900/20 shadow-sm">
                                      <div className="flex items-center justify-between mb-3">
                                        <div className="font-medium text-purple-800 dark:text-purple-200 text-sm">{tool.name}</div>
                                        <div className="flex items-center gap-2 text-xs">
                                          <span className="px-2 py-1 bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded font-medium">
                                            {formatDisplayNumber(meters)} m
                                          </span>
                                          <span className="font-semibold text-purple-600 dark:text-purple-400">{formatPrice(tp)}</span>
                                          <button 
                                            type="button" 
                                            className="text-red-500 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/20 px-2 py-1 rounded transition-colors" 
                                            onClick={() => {
                                              const tools = (draft.tools || []).filter((_, i) => i !== idx);
                                              setDraft({ ...draft, tools });
                                            }}
                                            title="حذف ابزار"
                                          >
                                            <FaTrash className="w-3 h-3" />
                                          </button>
                                        </div>
                                      </div>
                                      <div className="flex flex-wrap gap-2 text-xs">
                                        {stairActivePart === 'landing' && (
                                          <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                            <input 
                                              type="checkbox" 
                                              checked={!!tool.perimeter} 
                                              onChange={(e) => {
                                                const tools = [...(draft.tools || [])];
                                                tools[idx] = { ...tool, perimeter: e.target.checked };
                                                setDraft({ ...draft, tools });
                                              }} 
                                              className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                            /> 
                                            <span className="text-gray-700 dark:text-gray-300">محیط کامل</span>
                                          </label>
                                        )}
                                        <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                          <input 
                                            type="checkbox" 
                                            checked={!!tool.front} 
                                            onChange={(e) => {
                                              const tools = [...(draft.tools || [])]; 
                                              tools[idx] = { ...tool, front: e.target.checked }; 
                                              setDraft({ ...draft, tools });
                                            }} 
                                            className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                          /> 
                                          <span className="text-gray-700 dark:text-gray-300">جلو</span>
                                        </label>
                                        {stairActivePart === 'landing' && (
                                          <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                            <input 
                                              type="checkbox" 
                                              checked={!!tool.back} 
                                              onChange={(e) => {
                                                const tools = [...(draft.tools || [])]; 
                                                tools[idx] = { ...tool, back: e.target.checked }; 
                                                setDraft({ ...draft, tools });
                                              }} 
                                              className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                            /> 
                                            <span className="text-gray-700 dark:text-gray-300">عقب</span>
                                          </label>
                                        )}
                                        <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                          <input 
                                            type="checkbox" 
                                            checked={!!tool.left} 
                                            onChange={(e) => {
                                              const tools = [...(draft.tools || [])]; 
                                              tools[idx] = { ...tool, left: e.target.checked }; 
                                              setDraft({ ...draft, tools });
                                            }} 
                                            className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                          /> 
                                          <span className="text-gray-700 dark:text-gray-300">چپ</span>
                                        </label>
                                        <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                          <input 
                                            type="checkbox" 
                                            checked={!!tool.right} 
                                            onChange={(e) => {
                                              const tools = [...(draft.tools || [])]; 
                                              tools[idx] = { ...tool, right: e.target.checked }; 
                                              setDraft({ ...draft, tools });
                                            }} 
                                            className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                          /> 
                                          <span className="text-gray-700 dark:text-gray-300">راست</span>
                                        </label>
                                      </div>
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                      )}

                      {/* Layers Section (لایه‌ها) - Enhanced */}
                      {/* 🎯 Hide layers section for riser */}
                      {stairActivePart !== 'riser' && (
                      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                        <div className="flex items-center justify-between mb-4">
                          <div className="flex items-center gap-2">
                            <div className="w-1 h-5 bg-gradient-to-b from-orange-500 to-orange-600 rounded-full"></div>
                            <h5 className="text-sm font-semibold text-gray-800 dark:text-white">لایه‌ها</h5>
                          </div>
                          <span className="text-xs text-orange-600 dark:text-orange-400 bg-orange-50 dark:bg-orange-900/20 px-2 py-1 rounded">لایه‌های اضافی برای هر پله</span>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div>
                            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                تعداد لایه برای هر پله
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.numberOfLayersPerStair ?? null}
                              onChange={(value) => {
                                // 🎯 Ensure integer value and validate
                                const intValue = value ? Math.floor(value) : null;
                                const requiresLayerType = layerTypes.length > 0;
                                if (intValue && intValue > 0 && intValue <= 10) { // Reasonable max: 10 layers per stair
                                  let updatedDraft: StairPartDraftV2 = { ...draft, numberOfLayersPerStair: intValue };
                                  if (!hasLayerEdgeSelection(updatedDraft.layerEdges)) {
                                    updatedDraft = deriveLayerEdgesFromTools(updatedDraft, stairActivePart);
                                  }
                                  setDraft(updatedDraft);
                                  if (requiresLayerType && !draft.layerTypeId) {
                                    setStairDraftErrors(prev => ({
                                      ...prev,
                                      [stairActivePart]: { 
                                        ...prev[stairActivePart], 
                                        layerType: 'لطفاً نوع لایه را انتخاب کنید'
                                      }
                                    }));
                                  } else {
                                    clearDraftFieldError(stairActivePart, 'layerType');
                                  }
                                } else if (intValue === null || intValue === 0) {
                                  setDraft({
                                    ...draft,
                                    numberOfLayersPerStair: null,
                                    layerUseDifferentStone: false,
                                    layerStoneProductId: null,
                                    layerStoneProduct: null,
                                    layerStoneLabel: null,
                                    layerPricePerSquareMeter: null,
                                    layerUseMandatory: undefined,
                                    layerMandatoryPercentage: null
                                  });
                                  clearDraftFieldError(stairActivePart, 'layerType');
                                  clearDraftFieldError(stairActivePart, 'layerStone');
                                  clearDraftFieldError(stairActivePart, 'layerStonePrice');
                                  clearDraftFieldError(stairActivePart, 'layerMandatoryPercentage');
                                } else if (intValue > 10) {
                                  // Show error for too many layers
                                  setStairDraftErrors(prev => ({
                                    ...prev,
                                    [stairActivePart]: { 
                                      ...prev[stairActivePart], 
                                      quantity: 'تعداد لایه برای هر پله نمی‌تواند بیشتر از 10 باشد'
                                    }
                                  }));
                                }
                              }}
                              min={1}
                              step={1}
                              max={10}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                              placeholder="مثال: 2 (برای دوبل)"
                            />
                            <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                              تعداد لایه‌هایی که برای هر پله نیاز است (مثال: 2 برای دوبل)
                            </p>
                          </div>
                          
                          {draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && (
                            <>
                              <div>
                                <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  <span className="flex items-center gap-1">
                                    <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                    عرض لایه (سانتی‌متر)
                                  </span>
                                </label>
                                <FormattedNumberInput
                                  value={draft.layerWidthCm ?? null}
                                  onChange={(value) => {
                                    const updatedDraft = { ...draft, layerWidthCm: value && value > 0 ? value : null };
                                    // 🎯 Validate layer width against available remaining width
                                    if (value && value > 0) {
                                      const originalWidthCm = draft.stoneProduct?.widthValue || 0;
                                      const mainWidthCm = draft.widthCm || 0;
                                      const availableWidthCm = originalWidthCm - mainWidthCm;
                                      
                                      if (originalWidthCm > 0 && value > availableWidthCm && availableWidthCm > 0) {
                                        setStairDraftErrors(prev => ({
                                          ...prev,
                                          [stairActivePart]: { 
                                            ...prev[stairActivePart], 
                                            width: `عرض لایه (${formatDisplayNumber(value)}cm) نمی‌تواند بیشتر از عرض باقی‌مانده (${formatDisplayNumber(availableWidthCm)}cm) باشد`
                                          }
                                        }));
                                      } else if (value < 0.5) {
                                        setStairDraftErrors(prev => ({
                                          ...prev,
                                          [stairActivePart]: { 
                                            ...prev[stairActivePart], 
                                            width: 'عرض لایه باید حداقل 0.5 سانتی‌متر باشد'
                                          }
                                        }));
                                      } else {
                                        clearDraftFieldError(stairActivePart, 'width');
                                      }
                                    }
                                    setDraft(updatedDraft);
                                  }}
                                  min={0.5}
                                  step={0.1}
                                  className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                                  placeholder="مثال: 15"
                                />
                              </div>
                              
                              
                              {layerTypes.length > 0 && (
                                <div>
                                  <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    <span className="flex items-center gap-1">
                                      <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                      نوع لایه
                                    </span>
                                  </label>
                                  <select
                                    className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all font-medium"
                                    value={draft.layerTypeId || ''}
                                    disabled={isLoadingLayerTypes}
                                    onChange={(e) => {
                                      const selectedId = e.target.value;
                                      if (!selectedId) {
                                        setDraft({
                                          ...draft,
                                          layerTypeId: null,
                                          layerTypeName: null,
                                          layerTypePrice: null
                                        });
                                        if ((draft.numberOfLayersPerStair || 0) > 0) {
                                          setStairDraftErrors(prev => ({
                                            ...prev,
                                            [stairActivePart]: { 
                                              ...prev[stairActivePart], 
                                              layerType: 'لطفاً نوع لایه را انتخاب کنید'
                                            }
                                          }));
                                        }
                                        return;
                                      }
                                      const selected = layerTypes.find(option => option.id === selectedId);
                                      if (selected) {
                                        clearDraftFieldError(stairActivePart, 'layerType');
                                        setDraft({
                                          ...draft,
                                          layerTypeId: selected.id,
                                          layerTypeName: selected.name,
                                          layerTypePrice: selected.pricePerLayer
                                        });
                                      }
                                    }}
                                  >
                                    <option value="">انتخاب نوع لایه...</option>
                                    {layerTypes.map((option: LayerTypeOption) => (
                                      <option key={option.id} value={option.id}>
                                        {option.name} - {option.pricePerLayer.toLocaleString('fa-IR')} تومان
                                      </option>
                                    ))}
                                  </select>
                                  {layerTypesError && (
                                    <p className="mt-1 text-xs text-red-500 dark:text-red-400">
                                      {layerTypesError}
                                    </p>
                                  )}
                                  {stairDraftErrors[stairActivePart]?.layerType && (
                                    <p className="mt-1 text-xs text-red-500">
                                      {stairDraftErrors[stairActivePart]?.layerType}
                                    </p>
                                  )}
                                </div>
                              )}

                              <div className="md:col-span-2">
                                <div className="border border-dashed border-orange-200 dark:border-orange-800 rounded-lg p-4 bg-orange-50/30 dark:bg-orange-900/10">
                                  <div className="flex items-center justify-between">
                                    <div>
                                      <h6 className="text-xs font-semibold text-orange-700 dark:text-orange-300">
                                        استفاده از سنگ متفاوت برای لایه‌ها
                                      </h6>
                                      <p className="text-[11px] text-gray-500 dark:text-gray-400 mt-1">
                                        می‌توانید سنگ دیگری را برای لایه‌ها انتخاب کرده و قیمت مستقل آن را ثبت کنید.
                                      </p>
                                    </div>
                                    <button
                                      type="button"
                                      onClick={() => {
                                        if (draft.layerUseDifferentStone) {
                                          setDraft({
                                            ...draft,
                                            layerUseDifferentStone: false,
                                            layerStoneProductId: null,
                                            layerStoneProduct: null,
                                            layerStoneLabel: null,
                                            layerPricePerSquareMeter: null,
                                            layerUseMandatory: undefined,
                                            layerMandatoryPercentage: null
                                          });
                                          clearDraftFieldError(stairActivePart, 'layerStone');
                                          clearDraftFieldError(stairActivePart, 'layerStonePrice');
                                          clearDraftFieldError(stairActivePart, 'layerMandatoryPercentage');
                                        } else {
                                          setDraft({
                                            ...draft,
                                            layerUseDifferentStone: true,
                                            layerStoneProductId: null,
                                            layerStoneProduct: null,
                                            layerStoneLabel: null,
                                            layerPricePerSquareMeter: draft.pricePerSquareMeter || null,
                                            layerUseMandatory: true,
                                            layerMandatoryPercentage: draft.layerMandatoryPercentage ?? 20
                                          });
                                        }
                                      }}
                                      className={`px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                                        draft.layerUseDifferentStone
                                          ? 'bg-orange-500 text-white hover:bg-orange-600'
                                          : 'bg-white dark:bg-gray-900/40 text-orange-600 border border-orange-200 dark:border-orange-800 hover:bg-orange-100 dark:hover:bg-orange-900/40'
                                      }`}
                                    >
                                      {draft.layerUseDifferentStone ? 'لغو استفاده' : 'فعال‌سازی'}
                                    </button>
                                  </div>

                                  {draft.layerUseDifferentStone && (
                                    <div className="mt-4 space-y-4">
                                      <div>
                                        <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                          انتخاب سنگ برای لایه‌ها
                                        </label>
                                        {!draft.layerStoneProduct ? (
                                          <>
                                            <input
                                              className="w-full rounded-lg bg-white dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                                              placeholder="نام سنگ مورد نظر را جستجو کنید"
                                              value={layerStoneSearchTerm}
                                              onChange={(e) => setLayerStoneSearchTerm(e.target.value)}
                                              onFocus={() => setLayerStoneDropdownOpen(true)}
                                              onBlur={() => setTimeout(() => setLayerStoneDropdownOpen(false), 150)}
                                            />
                                            {layerStoneDropdownOpen && (
                                              <div className="mt-2 max-h-48 overflow-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg">
                                                {isSearchingLayerStones && (
                                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">
                                                    <span className="animate-pulse">در حال جستجو...</span>
                                                  </div>
                                                )}
                                                {!isSearchingLayerStones && layerStoneSearchResults.length === 0 && (
                                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">نتیجه‌ای یافت نشد</div>
                                                )}
                                                {layerStoneSearchResults.map((p) => (
                                                  <button
                                                    key={p.id}
                                                    type="button"
                                                    className="w-full text-right px-4 py-2.5 hover:bg-orange-50 dark:hover:bg-orange-900/20 text-sm border-b border-gray-100 dark:border-gray-700 last:border-0 transition-colors"
                                                    onClick={() => {
                                                      const altLabel = (p as any).fullName || generateFullProductName(p as Product) || p.namePersian || p.name;
                                                      setDraft({
                                                        ...draft,
                                                        layerUseDifferentStone: true,
                                                        layerStoneProductId: p.id,
                                                        layerStoneProduct: p,
                                                        layerStoneLabel: altLabel,
                                                        layerPricePerSquareMeter: p.basePrice || draft.layerPricePerSquareMeter || draft.pricePerSquareMeter || null,
                                                        layerUseMandatory: draft.layerUseMandatory ?? true,
                                                        layerMandatoryPercentage: draft.layerMandatoryPercentage ?? 20
                                                      });
                                                      setLayerStoneSearchTerm('');
                                                      setLayerStoneDropdownOpen(false);
                                                      clearDraftFieldError(stairActivePart, 'layerStone');
                                                    }}
                                                  >
                                                    <div className="font-medium text-gray-800 dark:text-white">
                                                      {(p as any).fullName || generateFullProductName(p as Product) || p.namePersian || p.name}
                                                    </div>
                                                    {p.basePrice && (
                                                      <div className="text-xs text-orange-600 dark:text-orange-400 mt-0.5">{formatPrice(p.basePrice)}</div>
                                                    )}
                                                  </button>
                                                ))}
                                              </div>
                                            )}
                                          </>
                                        ) : (
                                          <div className="flex items-center justify-between p-3 bg-white dark:bg-gray-900/40 border border-orange-200 dark:border-orange-700 rounded-lg">
                                            <div>
                                              <div className="text-sm font-semibold text-gray-800 dark:text-white">
                                                {draft.layerStoneLabel || draft.layerStoneProduct.namePersian || draft.layerStoneProduct.name}
                                              </div>
                                              <div className="text-[11px] text-gray-500 dark:text-gray-400">
                                                کد: {draft.layerStoneProduct.code || '-'}
                                              </div>
                                            </div>
                                            <div className="flex gap-2">
                                              <button
                                                type="button"
                                                className="px-2 py-1 text-xs text-orange-600 hover:text-orange-800 hover:bg-orange-100 dark:hover:bg-orange-900/30 rounded"
                                                onClick={() => {
                                                  setDraft({
                                                    ...draft,
                                                    layerStoneProductId: null,
                                                    layerStoneProduct: null,
                                                    layerStoneLabel: null
                                                  });
                                                  setLayerStoneSearchTerm('');
                                                  clearDraftFieldError(stairActivePart, 'layerStone');
                                                }}
                                              >
                                                تغییر
                                              </button>
                                              <button
                                                type="button"
                                                className="px-2 py-1 text-xs text-red-600 hover:text-red-800 hover:bg-red-50 dark:hover:bg-red-900/30 rounded"
                                                onClick={() => {
                                                  setDraft({
                                                    ...draft,
                                                    layerUseDifferentStone: false,
                                                    layerStoneProductId: null,
                                                    layerStoneProduct: null,
                                                    layerStoneLabel: null,
                                                    layerPricePerSquareMeter: null
                                                  });
                                                  setLayerStoneSearchTerm('');
                                                  clearDraftFieldError(stairActivePart, 'layerStone');
                                                  clearDraftFieldError(stairActivePart, 'layerStonePrice');
                                                }}
                                              >
                                                حذف
                                              </button>
                                            </div>
                                          </div>
                                        )}
                                        {stairDraftErrors[stairActivePart]?.layerStone && (
                                          <p className="mt-1 text-xs text-red-500">
                                            {stairDraftErrors[stairActivePart]?.layerStone}
                                          </p>
                                        )}
                                      </div>

                                      <div>
                                        <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                          قیمت هر متر مربع سنگ لایه (تومان)
                                        </label>
                                        <FormattedNumberInput
                                          value={draft.layerPricePerSquareMeter ?? null}
                                          onChange={(value) => {
                                            const updatedDraft = { ...draft, layerPricePerSquareMeter: value && value > 0 ? value : null };
                                            const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'layerStonePrice', value);
                                            if (error) {
                                              setStairDraftErrors(prev => ({
                                                ...prev,
                                                [stairActivePart]: { ...prev[stairActivePart], layerStonePrice: error }
                                              }));
                                            } else {
                                              clearDraftFieldError(stairActivePart, 'layerStonePrice');
                                            }
                                            setDraft(updatedDraft);
                                          }}
                                          min={0}
                                          step={1000}
                                          className="w-full rounded-lg bg-white dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                                          placeholder="مثال: 1,800,000"
                                        />
                                        {stairDraftErrors[stairActivePart]?.layerStonePrice && (
                                          <p className="mt-1 text-xs text-red-500">
                                            {stairDraftErrors[stairActivePart]?.layerStonePrice}
                                          </p>
                                        )}
                                      </div>

                                      <div className="rounded-lg border border-orange-100 dark:border-orange-800 bg-white dark:bg-gray-900/30 p-3">
                                        <div className="flex items-center gap-2">
                                          <input
                                            type="checkbox"
                                            className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                            checked={draft.layerUseMandatory ?? true}
                                            onChange={(e) => {
                                              const nextValue = e.target.checked;
                                              const updatedDraft = {
                                                ...draft,
                                                layerUseMandatory: nextValue,
                                                layerMandatoryPercentage: nextValue
                                                  ? (draft.layerMandatoryPercentage ?? 20)
                                                  : null
                                              };
                                              if (!nextValue) {
                                                clearDraftFieldError(stairActivePart, 'layerMandatoryPercentage');
                                              }
                                              setDraft(updatedDraft);
                                            }}
                                          />
                                          <div>
                                            <label className="text-xs font-medium text-gray-700 dark:text-gray-300">
                                              حکمی (افزایش قیمت)
                                            </label>
                                            <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                              در صورت فعال بودن، قیمت سنگ لایه به صورت درصدی افزایش داده می‌شود.
                                            </p>
                                          </div>
                                        </div>
                                        {draft.layerUseMandatory !== false && (
                                          <div className="mt-3 flex items-center gap-2">
                                            <FormattedNumberInput
                                              value={draft.layerMandatoryPercentage ?? 20}
                                              onChange={(value) => {
                                                const updatedDraft = { ...draft, layerMandatoryPercentage: value ?? 0 };
                                                const error = validateDraftNumericFields(stairActivePart, updatedDraft, 'layerMandatoryPercentage', value);
                                                if (error) {
                                                  setStairDraftErrors(prev => ({
                                                    ...prev,
                                                    [stairActivePart]: { ...prev[stairActivePart], layerMandatoryPercentage: error }
                                                  }));
                                                } else {
                                                  clearDraftFieldError(stairActivePart, 'layerMandatoryPercentage');
                                                }
                                                setDraft(updatedDraft);
                                              }}
                                              min={0}
                                              max={100}
                                              step={1}
                                              className="w-24 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent text-sm"
                                            />
                                            <span className="text-xs text-gray-600 dark:text-gray-300">%</span>
                                            <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                              قیمت نهایی با {formatDisplayNumber(draft.layerMandatoryPercentage ?? 20)}% افزایش محاسبه می‌شود.
                                            </p>
                                          </div>
                                        )}
                                        {stairDraftErrors[stairActivePart]?.layerMandatoryPercentage && (
                                          <p className="mt-1 text-xs text-red-500">
                                            {stairDraftErrors[stairActivePart]?.layerMandatoryPercentage}
                                          </p>
                                        )}
                                      </div>
                                    </div>
                                  )}
                                </div>
                              </div>

                              {/* 🎯 Layer Edge Selection */}
                              <div className="md:col-span-2">
                                <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  <span className="flex items-center gap-1">
                                    <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                    انتخاب لبه‌های مورد نیاز برای لایه
                                  </span>
                                </label>
                                <div className="flex flex-wrap gap-2 p-3 bg-orange-50/50 dark:bg-orange-900/10 rounded-lg border border-orange-200 dark:border-orange-800">
                                  {stairActivePart === 'landing' && (
                                    <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                      <input 
                                        type="checkbox" 
                                        checked={!!(draft.layerEdges?.perimeter)} 
                                        onChange={(e) => {
                                          const currentEdges = draft.layerEdges || {};
                                          setDraft({ 
                                            ...draft, 
                                            layerEdges: { 
                                              ...currentEdges, 
                                              perimeter: e.target.checked,
                                              // If perimeter is checked, uncheck individual edges
                                              front: e.target.checked ? false : currentEdges.front,
                                              left: e.target.checked ? false : currentEdges.left,
                                              right: e.target.checked ? false : currentEdges.right,
                                              back: e.target.checked ? false : currentEdges.back
                                            } 
                                          });
                                        }} 
                                        className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      /> 
                                      <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">محیط کامل</span>
                                    </label>
                                  )}
                                  <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                    <input 
                                      type="checkbox" 
                                      checked={!!(draft.layerEdges?.front)} 
                                      onChange={(e) => {
                                        const currentEdges = draft.layerEdges || {};
                                        setDraft({ 
                                          ...draft, 
                                          layerEdges: { 
                                            ...currentEdges, 
                                            front: e.target.checked,
                                            perimeter: e.target.checked ? false : currentEdges.perimeter
                                          } 
                                        });
                                      }} 
                                      className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      disabled={!!(draft.layerEdges?.perimeter)}
                                    /> 
                                    <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">جلو</span>
                                  </label>
                                  {stairActivePart === 'landing' && (
                                    <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                      <input 
                                        type="checkbox" 
                                        checked={!!(draft.layerEdges?.back)} 
                                        onChange={(e) => {
                                          const currentEdges = draft.layerEdges || {};
                                          setDraft({ 
                                            ...draft, 
                                            layerEdges: { 
                                              ...currentEdges, 
                                              back: e.target.checked,
                                              perimeter: e.target.checked ? false : currentEdges.perimeter
                                            } 
                                          });
                                        }} 
                                        className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                        disabled={!!(draft.layerEdges?.perimeter)}
                                      /> 
                                      <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">عقب</span>
                                    </label>
                                  )}
                                  <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                    <input 
                                      type="checkbox" 
                                      checked={!!(draft.layerEdges?.left)} 
                                      onChange={(e) => {
                                        const currentEdges = draft.layerEdges || {};
                                        setDraft({ 
                                          ...draft, 
                                          layerEdges: { 
                                            ...currentEdges, 
                                            left: e.target.checked,
                                            perimeter: e.target.checked ? false : currentEdges.perimeter
                                          } 
                                        });
                                      }} 
                                      className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      disabled={!!(draft.layerEdges?.perimeter)}
                                    /> 
                                    <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">چپ</span>
                                  </label>
                                  <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                    <input 
                                      type="checkbox" 
                                      checked={!!(draft.layerEdges?.right)} 
                                      onChange={(e) => {
                                        const currentEdges = draft.layerEdges || {};
                                        setDraft({ 
                                          ...draft, 
                                          layerEdges: { 
                                            ...currentEdges, 
                                            right: e.target.checked,
                                            perimeter: e.target.checked ? false : currentEdges.perimeter
                                          } 
                                        });
                                      }} 
                                      className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      disabled={!!(draft.layerEdges?.perimeter)}
                                    /> 
                                    <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">راست</span>
                                  </label>
                                </div>
                                {(!draft.layerEdges || (!draft.layerEdges.front && !draft.layerEdges.left && !draft.layerEdges.right && !draft.layerEdges.back && !draft.layerEdges.perimeter)) && (
                                  <p className="mt-2 text-xs text-orange-600 dark:text-orange-400">
                                    لطفاً حداقل یک لبه را انتخاب کنید
                                  </p>
                                )}
                              </div>
                              
                              {draft.numberOfLayersPerStair && draft.layerWidthCm && draft.pricePerSquareMeter && draft.quantity && 
                               (layerTypes.length === 0 || draft.layerTypeId) &&
                               draft.layerEdges && (draft.layerEdges.front || draft.layerEdges.left || draft.layerEdges.right || draft.layerEdges.back || draft.layerEdges.perimeter) && (() => {
                                // 🎯 Use computeLayerSqmV2 for consistent calculation (accounts for overlap)
                                const totalLayers = draft.quantity * draft.numberOfLayersPerStair;
                                const totalLayerSqm = computeLayerSqmV2(stairActivePart, draft);
                                
                                const layerWidthCm = draft.layerWidthCm || 0;
                                const stoneWidthCm = draft.layerUseDifferentStone 
                                  ? (draft.layerStoneProduct?.widthValue || draft.stoneProduct?.widthValue || 0)
                                  : (draft.stoneProduct?.widthValue || 0);
                                const stairLengthM = getActualLengthMeters(draft);
                                
                                    const stoneWidthM = stoneWidthCm / 100;
                                const columnsPerStone = stoneWidthCm > 0 && layerWidthCm > 0
                                  ? Math.max(1, Math.floor(stoneWidthCm / layerWidthCm))
                                  : 0;
                                
                                const edgeDemandsPreview = getLayerEdgeDemands(stairActivePart, draft);
                                const needsNewStone = edgeDemandsPreview.filter(edge =>
                                  !(edge.edge === 'front' || edge.edge === 'back' || edge.edge === 'perimeter')
                                );
                                
                                const stoneAreaUsedSqm = (() => {
                                  if (!needsNewStone.length || !columnsPerStone || !stairLengthM || !stoneWidthM) {
                                    return 0;
                                  }
                                  let stonesNeeded = 0;
                                  needsNewStone.forEach(edge => {
                                    if (edge.lengthM <= 0) return;
                                    const stripsPerColumn = Math.max(1, Math.floor(stairLengthM / edge.lengthM));
                                    const stripsPerStone = Math.max(1, stripsPerColumn * columnsPerStone);
                                    stonesNeeded += Math.ceil(edge.layersNeeded / stripsPerStone);
                                  });
                                  if (!stonesNeeded) return 0;
                                  return stonesNeeded * stairLengthM * stoneWidthM;
                                })();
                                
                                // Use the same price as the main stair part
                                const pricePerSqm = draft.pricePerSquareMeter || 0;
                                const layerTypeUnitPrice = draft.layerTypePrice || 0;
                                
                                // 🎯 FIX: Calculate layer type cost based on total length per stair × number of stairs × layer type price per meter
                                // مجموع طوله های لایه برای یک پله (چپ + راست + جلو) × تعداد پله ها × هزینه هر نوع لایه
                                const totalLayerLengthPerStairM = getTotalLayerLengthPerStairM(stairActivePart, draft);
                                const totalLayerLengthM = totalLayerLengthPerStairM * draft.quantity;
                                const layerTypeCostPreview = totalLayerLengthM * layerTypeUnitPrice;
                                
                                // 🎯 FIX: Calculate layer stone price based on stone area used, NOT layer square meters
                                // Use stone area used for pricing (includes waste/remaining pieces)
                                const pricingStoneAreaSqm = stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : totalLayerSqm;
                                const baseLayerCost = pricingStoneAreaSqm * pricePerSqm;
                                const layerTotalPrice = baseLayerCost + layerTypeCostPreview;
                                
                                return (
                                  <div className="md:col-span-2">
                                    <div className="mt-2 rounded-lg border border-orange-200 dark:border-orange-800 bg-orange-50 dark:bg-orange-900/20 px-4 py-3 text-xs leading-5 text-orange-700 dark:text-orange-200">
                                      <div className="font-semibold mb-1">خلاصه لایه‌ها:</div>
                                      <div>تعداد کل لایه‌ها: {formatDisplayNumber(totalLayers)} عدد ({formatDisplayNumber(draft.quantity)} پله × {formatDisplayNumber(draft.numberOfLayersPerStair)} لایه)</div>
                                      <div className="mt-1">
                                        <span className="font-medium">لبه‌های انتخاب شده: </span>
                                        {stairActivePart === 'landing' && draft.layerEdges?.perimeter && (
                                          <span className="text-orange-600 dark:text-orange-400">محیط کامل</span>
                                        )}
                                        {!draft.layerEdges?.perimeter && (
                                          <>
                                            {draft.layerEdges?.front && <span className="text-orange-600 dark:text-orange-400">جلو </span>}
                                            {draft.layerEdges?.back && <span className="text-orange-600 dark:text-orange-400">عقب </span>}
                                            {draft.layerEdges?.left && <span className="text-orange-600 dark:text-orange-400">چپ </span>}
                                            {draft.layerEdges?.right && <span className="text-orange-600 dark:text-orange-400">راست </span>}
                                          </>
                                        )}
                                      </div>
                                      <div>متر مربع استفاده شده: {formatSquareMeters(totalLayerSqm)}</div>
                                      {stoneAreaUsedSqm > 0 && (
                                        <div>متر مربع سنگ: {formatSquareMeters(stoneAreaUsedSqm)}</div>
                                      )}
                                      <div className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                        قیمت هر متر مربع: {formatPrice(pricePerSqm)} (همان سنگ اصلی)
                                      </div>
                                      <div className="mt-1 pt-1 border-t border-orange-200 dark:border-orange-700">
                                        <div className="text-xs text-gray-600 dark:text-gray-400 mb-1">
                                            قیمت سنگ لایه: {formatPrice((stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : totalLayerSqm) * pricePerSqm)}
                                            {stoneAreaUsedSqm > 0 && (
                                            <span className="text-xs text-gray-500 dark:text-gray-500 mr-1">
                                                (بر اساس متر مربع سنگ: {formatSquareMeters(stoneAreaUsedSqm)})
                                            </span>
                                          )}
                                        </div>
                                        {layerTypeUnitPrice > 0 && (
                                          <div className="text-xs text-gray-600 dark:text-gray-400 mb-1">
                                            هزینه نوع لایه ({draft.layerTypeName || '-'}): {formatPrice(layerTypeCostPreview)}
                                            <span className="text-xs text-gray-500 dark:text-gray-500 ml-1">
                                              ({formatDisplayNumber(totalLayerLengthPerStairM)} متر × {formatDisplayNumber(draft.quantity)} پله × {formatPrice(layerTypeUnitPrice)}/متر)
                                            </span>
                                          </div>
                                        )}
                                        <div className="mt-1 pt-1 border-t border-orange-200 dark:border-orange-700">
                                          <span className="font-semibold">قیمت کل لایه‌ها: {formatPrice(layerTotalPrice)}</span>
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                );
                              })()}
                            </>
                          )}
                        </div>
                      </div>
                      )}

                      {stoneFinishings.length > 0 && (
                        <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-2">
                              <div className="w-1 h-5 bg-gradient-to-b from-teal-500 to-teal-600 rounded-full"></div>
                              <h5 className="text-sm font-semibold text-gray-800 dark:text-white">پرداخت سنگ</h5>
                            </div>
                            <span className="text-xs text-teal-600 dark:text-teal-300 bg-teal-50 dark:bg-teal-900/30 px-2 py-1 rounded">
                              هزینه به ازای متر مربع
                            </span>
                          </div>
                          <div className="space-y-4">
                            <label className="flex items-center gap-2 text-sm text-gray-700 dark:text-gray-200">
                              <input
                                type="checkbox"
                                className="rounded border-gray-300 text-teal-600 focus:ring-teal-500"
                                checked={!!draft.finishingEnabled}
                                onChange={(e) => {
                                  const enabled = e.target.checked;
                                  if (!enabled) {
                                    setDraft({
                                      ...draft,
                                      finishingEnabled: false,
                                      finishingId: null,
                                      finishingLabel: null,
                                      finishingPricePerSquareMeter: null
                                    });
                                    return;
                                  }
                                  const defaultFinishing = draft.finishingId
                                    ? stoneFinishings.find(option => option.id === draft.finishingId)
                                    : stoneFinishings[0];
                                  setDraft({
                                    ...draft,
                                    finishingEnabled: true,
                                    finishingId: defaultFinishing?.id || draft.finishingId || null,
                                    finishingLabel: defaultFinishing
                                      ? (defaultFinishing.namePersian || defaultFinishing.name || '')
                                      : draft.finishingLabel || null,
                                    finishingPricePerSquareMeter: defaultFinishing
                                      ? defaultFinishing.pricePerSquareMeter
                                      : draft.finishingPricePerSquareMeter || null
                                  });
                                }}
                              />
                              فعال‌سازی پرداخت برای این بخش
                            </label>

                            {draft.finishingEnabled && (
                              <>
                                <div>
                                  <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    انتخاب نوع پرداخت
                                  </label>
                                  <select
                                    value={draft.finishingId || ''}
                                    onChange={(e) => {
                                      const selectedId = e.target.value;
                                      if (!selectedId) {
                                        setDraft({
                                          ...draft,
                                          finishingId: null,
                                          finishingLabel: null,
                                          finishingPricePerSquareMeter: null
                                        });
                                        return;
                                      }
                                      const selected = stoneFinishings.find(option => option.id === selectedId);
                                      if (selected) {
                                        setDraft({
                                          ...draft,
                                          finishingEnabled: true,
                                          finishingId: selected.id,
                                          finishingLabel: selected.namePersian || selected.name || '',
                                          finishingPricePerSquareMeter: selected.pricePerSquareMeter
                                        });
                                      }
                                    }}
                                    className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                                  >
                                    <option value="">انتخاب پرداخت...</option>
                                    {stoneFinishings.map(option => (
                                      <option key={option.id} value={option.id}>
                                        {option.namePersian} - {formatPrice(option.pricePerSquareMeter)}
                                      </option>
                                    ))}
                                  </select>
                                </div>

                                {selectedFinishing && finishingPricePerSquareMeter && (
                                  <div className="rounded-lg border border-teal-200 dark:border-teal-800 bg-teal-50 dark:bg-teal-900/20 px-4 py-3 text-xs leading-5 text-teal-700 dark:text-teal-200 space-y-1.5">
                                    <div className="flex justify-between">
                                      <span>قیمت هر متر مربع:</span>
                                      <span className="font-semibold">{formatPrice(finishingPricePerSquareMeter)}</span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span>مساحت محاسباتی:</span>
                                      <span className="font-semibold">{formatSquareMeters(totals.pricingSquareMeters)}</span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span>هزینه تقریبی پرداخت:</span>
                                      <span className="font-semibold">{formatPrice(finishingPreviewCost)}</span>
                                    </div>
                                  </div>
                                )}
                            </>
                          )}
                        </div>
                      </div>
                      )}

                      {/* Part Total - Enhanced */}
                      <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 rounded-lg border-2 border-teal-300 dark:border-teal-700 p-4 flex items-center justify-between shadow-sm">
                        <div className="flex items-center gap-2">
                          <div className="w-1 h-6 bg-gradient-to-b from-teal-500 to-teal-600 rounded-full"></div>
                          <span className="text-sm font-semibold text-teal-900 dark:text-teal-200">جمع کل این بخش</span>
                        </div>
                        <div className="text-xl font-bold text-teal-700 dark:text-teal-300">{formatPrice(totals.partTotal || 0)}</div>
                      </div>
                    </div>
                  );
                })()}

                {/* Session group summary (enhanced table) */}
                <div className="mt-4 border-t border-gray-200 dark:border-gray-700 pt-4">
                  <div className="flex items-center gap-2 mb-3">
                    <div className="w-1 h-6 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                    <h4 className="text-base font-semibold text-gray-800 dark:text-white">خلاصه اقلام افزوده شده</h4>
                    <span className="px-2 py-0.5 bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded-full text-xs font-medium">
                      {stairSessionItems.length} آیتم
                    </span>
                  </div>
                  {stairSessionItems.length === 0 ? (
                    <div className="text-center py-6 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-dashed border-gray-300 dark:border-gray-600">
                      <p className="text-sm text-gray-400 dark:text-gray-500">هنوز آیتمی افزوده نشده است.</p>
                    </div>
                  ) : (
                    <div className="overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm">
                      <table className="min-w-full text-sm">
                        <thead>
                          <tr className="bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/30 dark:to-purple-800/30 border-b border-purple-200 dark:border-purple-700">
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">بخش</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">ابعاد</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">تعداد</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">متر مربع</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">قیمت متر مربع</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">ابزارها</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">هزینه ابزار</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">جمع جز</th>
                          </tr>
                        </thead>
                        <tbody>
                          {stairSessionItems.map((it, idx) => {
                            const toolsTotal = ((it as any).meta?.tools || [])?.reduce((s: number, x: any) => s + (x.totalPrice || 0), 0) || 0;
                            const isLayer = ((it as any).meta?.isLayer) || false;
                            const layerInfo = ((it as any).meta?.layerInfo) || null;
                            const partTypeLabel = isLayer 
                              ? `لایه ${it.stairPartType === 'tread' ? 'کف پله' : it.stairPartType === 'riser' ? 'خیز' : 'پاگرد'}`
                              : (it.stairPartType === 'tread' ? 'کف پله' : it.stairPartType === 'riser' ? 'خیز' : 'پاگرد');
                            const partTypeColor = isLayer 
                              ? 'orange' 
                              : (it.stairPartType === 'tread' ? 'purple' : it.stairPartType === 'riser' ? 'blue' : 'indigo');
                            const lengthDisplay = it.lengthUnit === 'm' ? `${formatDisplayNumber(it.length)} m` : `${formatDisplayNumber(it.length)} cm`;
                            const widthDisplay = `${formatDisplayNumber(it.width)} cm`;
                            const stairMeta = ((it as any).meta?.stair) || {};
                            const baseStoneQuantity = stairMeta.baseStoneQuantity || 0;
                            const piecesPerStoneMeta = stairMeta.piecesPerStone || 0;
                            const leftoverWidthMeta = stairMeta.leftoverWidthCmPerStone || 0;
                            
                            return (
                              <tr key={idx} className={`border-b border-gray-100 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors ${idx % 2 === 0 ? 'bg-white dark:bg-gray-800' : 'bg-gray-50/50 dark:bg-gray-800/30'}`}>
                                <td className="py-3 px-4">
                                  <span className={`inline-flex items-center px-2.5 py-1 rounded-full text-xs font-semibold ${
                                    partTypeColor === 'purple' ? 'bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300' :
                                    partTypeColor === 'blue' ? 'bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300' :
                                    partTypeColor === 'orange' ? 'bg-orange-100 dark:bg-orange-900/30 text-orange-700 dark:text-orange-300' :
                                    'bg-indigo-100 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300'
                                  }`}>
                                    {partTypeLabel}
                                  </span>
                                  {isLayer && layerInfo && (
                                    <div className="text-xs text-orange-600 dark:text-orange-400 mt-1">
                                      {layerInfo.numberOfLayersPerStair} لایه برای هر پله
                                    </div>
                                  )}
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300">
                                  <div className="flex flex-col gap-0.5">
                                    <span className="font-medium">طول: {lengthDisplay}</span>
                                    <span className="text-xs text-gray-500 dark:text-gray-400">عرض: {widthDisplay}</span>
                                  </div>
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300">
                                  <div className="flex flex-col gap-1">
                                    <span className="font-medium">{formatDisplayNumber(it.quantity || 0)} عدد</span>
                                    {baseStoneQuantity > 0 && (
                                      <span className="text-xs text-purple-600 dark:text-purple-300">
                                        سنگ پایه: {formatDisplayNumber(baseStoneQuantity)} عدد
                                        {piecesPerStoneMeta > 0 ? ` • ${formatDisplayNumber(piecesPerStoneMeta)} قطعه از هر سنگ` : ''}
                                        {leftoverWidthMeta > 0 ? ` • باقیمانده: ${formatDisplayNumber(leftoverWidthMeta)}cm` : ''}
                                      </span>
                                    )}
                                    {isLayer && layerInfo && (
                                      <span className="text-xs text-orange-600 dark:text-orange-400 mt-0.5">
                                        {layerInfo.layersFromRemainingStones > 0 || layerInfo.layersFromNewStones > 0
                                          ? `${layerInfo.layersFromRemainingStones || 0} از باقی‌مانده، ${layerInfo.layersFromNewStones || 0} از سنگ جدید`
                                          : ''}
                                      </span>
                                    )}
                                  </div>
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300 font-medium">
                                  {formatSquareMeters(it.squareMeters || 0)}
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300">
                                  {formatPrice(it.pricePerSquareMeter || 0)}
                                </td>
                                <td className="py-3 px-4">
                                  <div className="flex flex-col gap-1.5">
                                  {(((it as any).meta?.tools) || []).length === 0 ? (
                                    <span className="text-xs text-gray-400 dark:text-gray-500">-</span>
                                  ) : (
                                      ((it as any).meta?.tools || []).map((t: any, i: number) => (
                                        <div key={i} className="text-xs bg-purple-50 dark:bg-purple-900/20 px-2 py-1 rounded border border-purple-200 dark:border-purple-800">
                                          <span className="font-medium text-purple-700 dark:text-purple-300">{t.name}</span>
                                          <span className="text-gray-600 dark:text-gray-400"> • {formatDisplayNumber(t.computedMeters || 0)} m</span>
                                          <span className="text-gray-500 dark:text-gray-500"> × {formatPrice(t.pricePerMeter || 0)}</span>
                                        </div>
                                      ))
                                    )}
                                    {it.finishingId && it.finishingCost ? (
                                      <div className="text-xs bg-teal-50 dark:bg-teal-900/20 px-2 py-1 rounded border border-teal-200 dark:border-teal-800">
                                        <span className="font-medium text-teal-700 dark:text-teal-300">پرداخت:</span>
                                        <span className="text-gray-600 dark:text-gray-400 mr-1">
                                          {it.finishingName || 'پرداخت'} • {formatSquareMeters(it.finishingSquareMeters || it.squareMeters || 0)}
                                        </span>
                                        <span className="text-teal-600 dark:text-teal-300 font-semibold">
                                          {formatPrice(it.finishingCost)}
                                        </span>
                                      </div>
                                    ) : null}
                                  </div>
                                </td>
                                <td className="py-3 px-4">
                                  {toolsTotal > 0 ? (
                                    <span className="font-medium text-purple-600 dark:text-purple-400">{formatPrice(toolsTotal)}</span>
                                  ) : (
                                    <span className="text-xs text-gray-400 dark:text-gray-500">-</span>
                                  )}
                                </td>
                                <td className="py-3 px-4">
                                  <span className="font-semibold text-teal-600 dark:text-teal-400">
                                    {formatPrice(
                                      typeof it.totalPrice === 'number' ? it.totalPrice : (typeof it.totalPrice === 'string' ? parseFloat(it.totalPrice) || 0 : 0)
                                    )}
                                  </span>
                                </td>
                              </tr>
                            );
                          })}
                          <tr className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border-t-2 border-teal-300 dark:border-teal-700">
                            <td className="py-3 px-4 font-bold text-teal-900 dark:text-teal-200" colSpan={7}>جمع کل گروه</td>
                            <td className="py-3 px-4">
                              <span className="font-bold text-lg text-teal-700 dark:text-teal-300">
                                {formatPrice(stairSessionItems.reduce((s, it) => s + (it.totalPrice || 0), 0))}
                              </span>
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                  )}
                </div>
                </div>
              </div>
              <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex items-center justify-end gap-2 flex-shrink-0">
                <button type="button" className="px-3 py-2 rounded-md bg-gray-200 dark:bg-gray-700" onClick={() => setShowProductModal(false)}>انصراف</button>
                <button type="button" className="px-3 py-2 rounded-md bg-purple-600 text-white" onClick={() => {
                  const [draft] = getActiveDraft();
                  // Validate required fields
                  const fieldErrors = validateDraftRequiredFields(stairActivePart, draft);
                  const hasErrors = Object.values(fieldErrors).some(Boolean);
                  if (hasErrors) {
                    setStairDraftErrors(prev => ({
                      ...prev,
                      [stairActivePart]: {
                        ...prev[stairActivePart],
                        ...fieldErrors
                      }
                    }));
                    setErrors({ products: 'لطفاً خطاهای مشخص‌شده را برطرف کنید' });
                    return;
                  }
                  setStairDraftErrors(prev => ({ ...prev, [stairActivePart]: {} }));
                  setErrors({});
                  const sid = ensureStairSessionId();
                  const totals = computeTotalsV2(stairActivePart, draft);
                  const chargeableCuttingCost = totals.billableCuttingCost;
                  const chargeableCuttingCostLongitudinal = totals.billableCuttingCostLongitudinal;
                  const chargeableCuttingCostCross = totals.billableCuttingCostCross;
                  const actualLengthM = getActualLengthMeters(draft);
                  const pricingLengthM = getPricingLengthMeters(draft);
                  const widthM = (draft.widthCm || 0) / 100;
                  const toolsMeters = computeToolsMetersV2(stairActivePart, draft);
                  let metaTools = (draft.tools || []).map(t => {
                    const meters = computeToolMetersForTool(stairActivePart, draft, t);
                    return {
                      toolId: t.toolId,
                      name: t.name,
                      pricePerMeter: t.pricePerMeter,
                      edges: { front: !!t.front, left: !!t.left, right: !!t.right, back: !!t.back, perimeter: !!t.perimeter },
                      computedMeters: meters,
                      totalPrice: meters * (t.pricePerMeter || 0)
                    };
                  });
                  const stoneProduct = draft.stoneProduct!;
                  const selectedFinishing = draft.finishingId
                    ? stoneFinishings.find(option => option.id === draft.finishingId)
                    : undefined;
                  const finishingCost = computeFinishingCost(draft, totals.pricingSquareMeters);
                  if (totals.cuttingCostLongitudinal > 0 && totals.shouldChargeCuttingCost) {
                    const cutMeters = actualLengthM * totals.baseStoneQuantity;
                    metaTools = [
                      ...metaTools,
                      {
                        toolId: `cut-longitudinal-${draft.stoneId || 'new'}`,
                        name: 'برش طولی',
                        pricePerMeter: totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter,
                        edges: { front: false, left: false, right: false, back: false, perimeter: true },
                        computedMeters: cutMeters,
                        totalPrice: chargeableCuttingCostLongitudinal
                      }
                    ];
                  }
                  if (totals.cuttingCostCross > 0 && totals.shouldChargeCuttingCost) {
                    const widthMeters = ((draft.widthCm || 0) / 100) * totals.baseStoneQuantity;
                    // Use "برش کله بر" if there's only 1 cross cut (no longitudinal cut)
                    const hasOnlyCrossCut = totals.cuttingCostLongitudinal === 0 || !totals.cuttingCostLongitudinal;
                    const cutName = hasOnlyCrossCut ? 'برش کله بر' : 'برش عرضی';
                    metaTools = [
                      ...metaTools,
                      {
                        toolId: `cut-cross-${draft.stoneId || 'new'}`,
                        name: cutName,
                        pricePerMeter: totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter,
                        edges: { front: false, left: false, right: false, back: false, perimeter: true },
                        computedMeters: widthMeters,
                        totalPrice: chargeableCuttingCostCross
                      }
                    ];
                  }
                  const toolsTotal = metaTools.reduce((sum, t) => sum + (t.totalPrice || 0), 0);
                  
                  // 🎯 Use original width for pricing (like long stone products)
                  const originalWidthCm = stoneProduct.widthValue || 0;
                  const userWidthCm = draft.widthCm || 0;
                  const baseStoneQuantity = totals.baseStoneQuantity;
                  
                  const defaultMandatoryForPart = stairActivePart === 'riser' || stairActivePart === 'landing';
                  const isDraftMandatory = draft.useMandatory ?? defaultMandatoryForPart;
                  const mandatoryPercentageValue = draft.mandatoryPercentage ?? 20;
                  const mandatoryAmount = isDraftMandatory && mandatoryPercentageValue > 0
                    ? totals.baseMaterialPrice * (mandatoryPercentageValue / 100)
                    : 0;
                  const basePrice = totals.baseMaterialPrice + mandatoryAmount;
                  const totalPrice = basePrice + toolsTotal + finishingCost + chargeableCuttingCost;
                  
                  const hasWidthCut = totals.cuttingCostLongitudinal > 0;
                  const hasLengthCut = totals.cuttingCostCross > 0;
                  
                  // Calculate remaining stone if product was cut
                  let remainingStones: RemainingStone[] = [];
                  let isCut = false;
                  let cutType: 'longitudinal' | 'cross' | null = null;
                  let cuttingCost = chargeableCuttingCost;
                  let cuttingCostPerMeter = totals.shouldChargeCuttingCost ? totals.cuttingCostPerMeter : 0;
                  let cutDetails: StoneCut[] = [];
                  const cuttingBreakdown: CuttingBreakdownEntry[] = [];
                  
                  if (hasWidthCut) {
                    isCut = true;
                    cutType = 'longitudinal';
                    const remainingWidth = totals.leftoverWidthCm;
                    if (remainingWidth > 0 && actualLengthM > 0 && baseStoneQuantity > 0) {
                      const remainingStoneId = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      const remainingWidthInMeters = remainingWidth / 100;
                      const remainingStone: RemainingStone = {
                        id: remainingStoneId,
                        width: remainingWidth,
                        length: actualLengthM,
                        squareMeters: (remainingWidthInMeters * actualLengthM * baseStoneQuantity),
                        isAvailable: remainingWidth > 0,
                        sourceCutId: `cut_${draft.stoneId}_${Date.now()}`,
                        quantity: baseStoneQuantity
                      };
                      remainingStones = [remainingStone];
                    }
                    
                    const cutId = `cut_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const cutDetail: StoneCut = {
                      id: cutId,
                      originalWidth: originalWidthCm,
                      cutWidth: userWidthCm,
                      remainingWidth: totals.leftoverWidthCm,
                      length: actualLengthM * 100 * baseStoneQuantity,
                      cuttingCost: chargeableCuttingCostLongitudinal,
                      cuttingCostPerMeter: totals.shouldChargeCuttingCost
                        ? (totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter)
                        : 0,
                      orientation: 'longitudinal'
                    };
                    cutDetails = [cutDetail];
                    cuttingBreakdown.push({
                      type: 'longitudinal',
                      meters: actualLengthM * baseStoneQuantity,
                      rate: totals.shouldChargeCuttingCost
                        ? (totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter)
                        : 0,
                      cost: chargeableCuttingCostLongitudinal
                    });
                  }
                  
                  if (hasLengthCut) {
                    isCut = true;
                    if (!hasWidthCut) {
                      cutType = 'cross';
                    }
                    if (pricingLengthM > actualLengthM && baseStoneQuantity > 0) {
                      const remainingLength = pricingLengthM - actualLengthM;
                      const crossStoneId = `remaining_cross_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      const widthMeters = userWidthCm / 100;
                      const crossRemaining: RemainingStone = {
                        id: crossStoneId,
                        width: userWidthCm,
                        length: remainingLength,
                        squareMeters: widthMeters * remainingLength * baseStoneQuantity,
                        isAvailable: true,
                        sourceCutId: `cut_cross_${draft.stoneId}_${Date.now()}`,
                        quantity: baseStoneQuantity
                      };
                      remainingStones = [...remainingStones, crossRemaining];
                      
                      const crossCutId = `cut_cross_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      cutDetails = [
                        ...cutDetails,
                        {
                          id: crossCutId,
                          originalWidth: pricingLengthM * 100,
                          cutWidth: actualLengthM * 100,
                          remainingWidth: remainingLength * 100,
                          length: userWidthCm * baseStoneQuantity,
                          cuttingCost: chargeableCuttingCostCross,
                          cuttingCostPerMeter: totals.shouldChargeCuttingCost
                            ? (totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter)
                            : 0,
                          orientation: 'cross'
                        }
                      ];
                    }
                    cuttingBreakdown.push({
                      type: 'cross',
                      meters: (userWidthCm / 100) * baseStoneQuantity,
                      rate: totals.shouldChargeCuttingCost
                        ? (totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter)
                        : 0,
                      cost: chargeableCuttingCostCross
                    });
                  }
                  
                  const storedLengthValue = convertMetersToUnit(actualLengthM, draft.lengthUnit || 'm');
                  const product: ContractProduct = {
                    productId: draft.stoneId!,
                    product: stoneProduct,
                    productType: 'stair',
                    stairSystemId: sid,
                    stairPartType: stairActivePart,
                    stoneCode: stoneProduct.code,
                    stoneName: draft.stoneLabel || stoneProduct.namePersian || stoneProduct.name || '',
                    diameterOrWidth: draft.thicknessCm || stoneProduct.thicknessValue || 0, // قطر = ضخامت (thickness)
                    length: storedLengthValue,
                    lengthUnit: draft.lengthUnit || 'cm',
                    width: draft.widthCm!,
                    widthUnit: 'cm',
                    quantity: draft.quantity!,
                    squareMeters: totals.sqm,
                    pricePerSquareMeter: draft.pricePerSquareMeter!,
                    totalPrice: totalPrice,
                    description: '',
                    currency: 'تومان',
                    isMandatory: isDraftMandatory && mandatoryPercentageValue > 0,
                    mandatoryPercentage: isDraftMandatory && mandatoryPercentageValue > 0 ? mandatoryPercentageValue : 0,
                    originalTotalPrice: totals.baseMaterialPrice,
                    isCut: isCut,
                    cutType: cutType,
                    originalWidth: originalWidthCm,
                    originalLength: actualLengthM, // Store original length in meters for canvas visualization
                    cuttingCost: cuttingCost,
                    cuttingCostPerMeter: cuttingCostPerMeter,
                    cutDescription: isCut
                      ? hasWidthCut && hasLengthCut
                        ? `برش طولی (${originalWidthCm}cm → ${userWidthCm}cm) و برش عرضی (${formatDisplayNumber(pricingLengthM)}m → ${formatDisplayNumber(actualLengthM)}m)`
                        : hasWidthCut
                          ? `برش طولی (${originalWidthCm}cm → ${userWidthCm}cm)`
                          : `برش کله بر (${formatDisplayNumber(pricingLengthM)}m → ${formatDisplayNumber(actualLengthM)}m)`
                      : '',
                    remainingStones: remainingStones,
                    cutDetails: cutDetails,
                    usedRemainingStones: [],
                    totalUsedRemainingWidth: 0,
                    totalUsedRemainingLength: 0,
                    appliedSubServices: [],
                    totalSubServiceCost: toolsTotal,
                    usedLengthForSubServices: 0,
                    usedSquareMetersForSubServices: 0,
                    cuttingBreakdown: cuttingBreakdown.length ? cuttingBreakdown : undefined,
                    standardLengthValue: stairActivePart === 'riser' ? null : (draft.standardLengthValue ?? null),
                    standardLengthUnit: stairActivePart === 'riser'
                      ? (draft.lengthUnit || 'm')
                      : (draft.standardLengthUnit || draft.lengthUnit || 'm'),
                    actualLengthMeters: actualLengthM || null,
                    finishingId: draft.finishingEnabled ? draft.finishingId || null : null,
                    finishingName: draft.finishingEnabled ? (draft.finishingLabel || selectedFinishing?.namePersian || selectedFinishing?.name || null) : null,
                    finishingPricePerSquareMeter: draft.finishingEnabled ? (draft.finishingPricePerSquareMeter ?? selectedFinishing?.pricePerSquareMeter ?? null) : null,
                    finishingCost: draft.finishingEnabled ? finishingCost : null,
                    finishingSquareMeters: draft.finishingEnabled && finishingCost > 0 ? totals.pricingSquareMeters : null,
                    meta: {
                      stairStepperV2: true,
                      meters: { lengthM: actualLengthM, widthM, toolsMeters },
                      tools: metaTools,
                      stair: {
                        baseStoneQuantity: totals.baseStoneQuantity,
                        piecesPerStone: totals.piecesPerStone,
                        leftoverWidthCmPerStone: totals.leftoverWidthCm,
                        pricingSquareMeters: totals.pricingSquareMeters,
                        standardLength: stairActivePart !== 'riser' && draft.standardLengthValue ? {
                          value: draft.standardLengthValue,
                          unit: draft.standardLengthUnit || draft.lengthUnit || 'm',
                          meters: pricingLengthM
                        } : undefined,
                      },
                      finishing: draft.finishingEnabled && finishingCost > 0 ? {
                        id: draft.finishingId,
                        name: draft.finishingLabel || selectedFinishing?.namePersian || selectedFinishing?.name,
                        pricePerSquareMeter: draft.finishingPricePerSquareMeter ?? selectedFinishing?.pricePerSquareMeter ?? null,
                        squareMeters: totals.pricingSquareMeters,
                        cost: finishingCost
                        } : undefined
                    } as any
                  };
                  // ============================================================================
                  // 🎯 REFACTORED LAYER HANDLING - Single state update for all changes
                  // ============================================================================
                  
                  // Check if layers are defined with edges selected
                  const hasLayerEdges = draft.layerEdges && (
                    draft.layerEdges.front || 
                    draft.layerEdges.left || 
                    draft.layerEdges.right || 
                    draft.layerEdges.back || 
                    draft.layerEdges.perimeter
                  );
                  
                  // Prepare all updates in a single transaction
                  setStairSessionItems(prev => {
                    // Remove previous entries for this part (and its layers) to keep session consistent during edits
                    const baseItems = prev.filter(item => {
                      const isLayerItem = ((item.meta as any)?.isLayer) || false;
                      if (isLayerItem) {
                        const parentPart = (item.meta as any)?.layerInfo?.parentPartType;
                        return parentPart !== stairActivePart;
                      }
                      return item.stairPartType !== stairActivePart;
                    });

                    // Start with adding the main stair part product
                    const updatedItems = [...baseItems, product];
                    const mainStairPartIndex = updatedItems.length - 1;
                    
                    // Process layers if configured
                    if (draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && 
                        draft.layerWidthCm && hasLayerEdges && getLayerEffectivePricePerSquareMeter(draft) && 
                        draft.quantity) {
                      
                      // 🎯 STEP 1: Find existing layer product (if any)
                      // Check both session items AND wizardData.products to prevent duplicates
                      const existingLayerInSession = findExistingLayerProduct(updatedItems, draft, stairActivePart);
                      const existingLayerInWizard = findExistingLayerProduct(wizardData.products, draft, stairActivePart);
                      const existingLayerProduct = existingLayerInSession || existingLayerInWizard;
                      
                      // 🎯 STEP 2: Calculate layer metrics
                      const totalLayerSqm = computeLayerSqmV2(stairActivePart, draft);
                      const layerWidthCm = draft.layerWidthCm || 0;
                      const totalLayers = draft.quantity * draft.numberOfLayersPerStair;
                      const mainStairLengthM = getActualLengthMeters(draft);
                      // 🎯 FIX: Use maximum layer length needed (accounts for different edge types with different lengths)
                      // This ensures we have enough stone for all layer types (front, left, right, etc.)
                      const layerLengthM = getMaxLayerLengthM(stairActivePart, draft) || mainStairLengthM;
                      const layerEdgeDemands = getLayerEdgeDemands(stairActivePart, draft);
                      const layerStoneProduct = getLayerStoneProductForDraft(draft, stoneProduct);
                      const usingAlternateLayerStone = !!(draft.layerUseDifferentStone && draft.layerStoneProduct);
                      const baseLayerPricePerSqm = getLayerBasePricePerSquareMeter(draft);
                      const effectiveLayerPricePerSqm = getLayerEffectivePricePerSquareMeter(draft);

                      // Get cutting cost per meter for layer calculations
                      const layerCuttingCostPerMeter = 
                        (layerStoneProduct as any)?.cuttingCostPerMeter ??
                        getCuttingTypePricePerMeter('LONG') ??
                        0;
                      
                      // 🎯 STEP 3: Collect all available remaining stones
                      const allAvailableRemainingStones = usingAlternateLayerStone
                        ? []
                        : collectAvailableRemainingStones(updatedItems, remainingStones);
                      
                      // 🎯 STEP 4: Calculate layer metrics (remaining stone usage, cutting costs, etc.)
                      const totalLayerDemand = layerEdgeDemands.length
                        ? layerEdgeDemands.reduce((sum, demand) => sum + demand.layersNeeded, 0)
                        : totalLayers;
                      const layerMetrics = usingAlternateLayerStone
                        ? {
                            layersFromRemainingStones: 0,
                            layersFromNewStones: totalLayerDemand,
                            totalLayerCuttingCost: 0,
                            layerCutDetails: [] as StoneCut[],
                            usedRemainingStonesForLayers: [] as RemainingStone[],
                            layerRemainingPieces: [] as RemainingStone[],
                            squareMetersFromRemaining: 0,
                            squareMetersFromNew: totalLayerSqm,
                            totalLayerDemand,
                            unfulfilledDemands: layerEdgeDemands.length
                              ? layerEdgeDemands.map(demand => ({
                                  edge: demand.edge,
                                  lengthM: demand.lengthM,
                                  quantity: demand.layersNeeded
                                }))
                              : [{
                                  edge: 'front',
                                  lengthM: layerLengthM,
                                  quantity: totalLayerDemand
                                }]
                          }
                        : calculateLayerMetrics({
                            totalLayers: totalLayerDemand,
                            layerWidthCm,
                            layerLengthM,
                            availableRemainingStones: allAvailableRemainingStones,
                            cuttingCostPerMeter: layerCuttingCostPerMeter,
                            edgeDemands: layerEdgeDemands
                          });
                      
                      // 🎯 STEP 5: Calculate pricing
                      const layerSqmPerStair = totalLayerSqm / (draft.quantity * draft.numberOfLayersPerStair);
                      const layerTypeUnitPrice = draft.layerTypePrice || 0;
                      
                      // 🎯 FIX: Calculate layer type cost based on total length per stair × number of stairs × layer type price per meter
                      // مجموع طوله های لایه برای یک پله (چپ + راست + جلو) × تعداد پله ها × هزینه هر نوع لایه
                      const totalLayerLengthPerStairM = getTotalLayerLengthPerStairM(stairActivePart, draft);
                      const totalLayerLengthM = totalLayerLengthPerStairM * draft.quantity;
                      const layerTypeCost = totalLayerLengthM * layerTypeUnitPrice;
                      
                      const layerSqmFromNew = (() => {
                        if (layerMetrics.squareMetersFromNew !== undefined) {
                          return layerMetrics.squareMetersFromNew;
                        }
                        const totalDemand = layerMetrics.totalLayerDemand || totalLayerDemand || 0;
                        if (totalDemand <= 0) {
                          return 0;
                        }
                        return layerSqmPerStair * (layerMetrics.layersFromNewStones / totalDemand);
                      })();
                      
                      const calculateStoneAreaUsed = (): number => {
                        const stoneWidthCm = layerStoneProduct?.widthValue || originalWidthCm;
                        const stoneLengthM = mainStairLengthM;
                        if (stoneWidthCm <= 0 || layerWidthCm <= 0 || stoneLengthM <= 0) {
                          return usingAlternateLayerStone ? totalLayerSqm : layerSqmFromNew;
                        }
                        
                        const stoneWidthM = stoneWidthCm / 100;
                        const columnsPerStone = Math.max(1, Math.floor(stoneWidthCm / layerWidthCm));
                        const baseLength = Math.max(layerLengthM, stoneLengthM);
                        
                        const unfulfilledDemands = (layerMetrics.unfulfilledDemands && layerMetrics.unfulfilledDemands.length)
                          ? layerMetrics.unfulfilledDemands
                          : [{
                              edge: 'front' as LayerEdgeDemand['edge'],
                              lengthM: layerLengthM > 0 ? layerLengthM : stoneLengthM,
                              quantity: layerMetrics.layersFromNewStones
                            }];
                        
                        let totalStonesNeeded = 0;
                        unfulfilledDemands.forEach(demand => {
                          if (!demand.lengthM || demand.lengthM <= 0 || !demand.quantity) {
                            return;
                          }
                          
                          const stripsPerColumn = Math.max(1, Math.floor(stoneLengthM / demand.lengthM));
                          const stripsPerStone = Math.max(1, stripsPerColumn * columnsPerStone);
                          totalStonesNeeded += Math.ceil(demand.quantity / stripsPerStone);
                        });
                        
                        if (totalStonesNeeded === 0) {
                          return usingAlternateLayerStone ? totalLayerSqm : layerSqmFromNew;
                        }
                        
                        return totalStonesNeeded * stoneLengthM * stoneWidthM;
                      };
                      
                      const stoneAreaUsedSqm = usingAlternateLayerStone
                        ? totalLayerSqm
                        : calculateStoneAreaUsed();
                      
                      const pricingStoneAreaSqm = stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : layerSqmFromNew;
                      
                      const shouldChargeLayerCutting =
                        !(usingAlternateLayerStone && (draft.layerUseMandatory ?? true) && (draft.layerMandatoryPercentage ?? 0) > 0);
                      const chargeableLayerCuttingCost = shouldChargeLayerCutting ? layerMetrics.totalLayerCuttingCost : 0;
                      // 🎯 FIX: Layer material price should be based on stone area used, NOT layer square meters
                      // 🎯 NOTE: effectiveLayerPricePerSqm already includes mandatory pricing if applicable
                      // Example: stoneAreaUsedSqm (0.976 m²) × pricePerSqm (700,000) = 683,200 تومان
                      const layerMaterialPrice = pricingStoneAreaSqm * effectiveLayerPricePerSqm;
                      // 🎯 FIX: Ensure layerTotalPrice is always a number (not string) and properly rounded
                      const layerTotalPrice = Number((layerMaterialPrice + layerTypeCost + chargeableLayerCuttingCost).toFixed(2));
                      
                      // 🎯 STEP 6: Handle existing layer product merge OR create new layer product
                      if (existingLayerProduct) {
                        // Check if existing layer is in session or in wizardData
                        const existingLayerIndex = updatedItems.findIndex(item => item === existingLayerProduct);
                        
                        if (existingLayerIndex >= 0) {
                          // Merge existing layer product in session
                          const mergedLayerProduct = mergeLayerProduct(existingLayerProduct, {
                            draft,
                            parentPartType: stairActivePart,
                            newLayersNeeded: totalLayers,
                            newLayerSqm: totalLayerSqm,
                            layerMaterialPrice,
                            layerTypeCost,
                            totalLayerCuttingCost: chargeableLayerCuttingCost,
                            layerCutDetails: layerMetrics.layerCutDetails,
                            usedRemainingStonesForLayers: layerMetrics.usedRemainingStonesForLayers,
                            layersFromRemainingStones: layerMetrics.layersFromRemainingStones,
                            layersFromNewStones: layerMetrics.layersFromNewStones,
                            layerPricePerSquareMeter: effectiveLayerPricePerSqm,
                            layerStoneLabel: usingAlternateLayerStone
                              ? (draft.layerStoneLabel || layerStoneProduct?.namePersian || layerStoneProduct?.name || '')
                              : null,
                            layerUseDifferentStone: usingAlternateLayerStone,
                            layerStoneProductId: usingAlternateLayerStone
                              ? (draft.layerStoneProductId || layerStoneProduct?.id || null)
                              : null,
                            layerStoneBasePricePerSquareMeter: baseLayerPricePerSqm,
                            layerUseMandatory: draft.layerUseDifferentStone ? (draft.layerUseMandatory ?? true) : undefined,
                            layerMandatoryPercentage: draft.layerUseDifferentStone ? (draft.layerMandatoryPercentage ?? 0) : undefined,
                            stoneAreaUsedSqm: stoneAreaUsedSqm
                          });
                          updatedItems[existingLayerIndex] = mergedLayerProduct;
                        } else if (existingLayerInWizard) {
                          // Existing layer is in wizardData.products - skip creating new one in session
                          // It will be merged when adding to wizardData (handled in the "Add to Contract" button handler)
                          console.log('ℹ️ Existing layer product found in wizardData.products, will be merged when adding to contract');
                          // Don't create a new layer product in session - prevents duplicates
                        }
                      } else {
                        // Create new layer product
                        const newLayerProduct = createLayerProduct({
                          draft,
                          stoneProduct: layerStoneProduct || stoneProduct,
                          stairSystemId: sid,
                          parentPartType: stairActivePart,
                          totalLayers,
                          totalLayerSqm,
                          layerMaterialPrice,
                          layerTotalPrice,
                          layerTypeCost,
                          layersFromRemainingStones: layerMetrics.layersFromRemainingStones,
                          layersFromNewStones: layerMetrics.layersFromNewStones,
                          totalLayerCuttingCost: chargeableLayerCuttingCost,
                          layerCutDetails: layerMetrics.layerCutDetails,
                          layerRemainingPieces: layerMetrics.layerRemainingPieces,
                          usedRemainingStonesForLayers: layerMetrics.usedRemainingStonesForLayers,
                          originalWidthCm: layerStoneProduct?.widthValue || originalWidthCm,
                          lengthM: mainStairLengthM,
                          layerCuttingCostPerMeter,
                          parentProductIndexInSession: mainStairPartIndex,
                          layerPricePerSquareMeter: effectiveLayerPricePerSqm,
                          layerStoneLabel: draft.layerUseDifferentStone
                            ? (draft.layerStoneLabel || layerStoneProduct?.namePersian || layerStoneProduct?.name || '')
                            : null,
                          layerUseDifferentStone: usingAlternateLayerStone,
                          layerStoneProductId: draft.layerUseDifferentStone
                            ? (draft.layerStoneProductId || layerStoneProduct?.id || null)
                            : null,
                          layerStoneBasePricePerSquareMeter: baseLayerPricePerSqm,
                          layerUseMandatory: draft.layerUseDifferentStone ? (draft.layerUseMandatory ?? true) : undefined,
                          layerMandatoryPercentage: draft.layerUseDifferentStone ? (draft.layerMandatoryPercentage ?? 0) : undefined,
                          stoneAreaUsedSqm: stoneAreaUsedSqm
                        });
                        updatedItems.push(newLayerProduct);
                      }
                      
                      // 🎯 STEP 7: Update remaining stone usage tracking
                      if (layerMetrics.usedRemainingStonesForLayers.length > 0) {
                        const remainingStoneUpdates = updateRemainingStoneUsage(
                          updatedItems,
                          layerMetrics.usedRemainingStonesForLayers,
                          mainStairPartIndex
                        );
                        
                        // Apply all remaining stone usage updates
                        remainingStoneUpdates.forEach((updatedProduct, idx) => {
                          if (idx >= 0 && idx < updatedItems.length) {
                            updatedItems[idx] = updatedProduct;
                          }
                        });
                      }
                    }
                    
                    return updatedItems;
                  });
                  
                  // Reset fields for quick next entry (keep unit toggle)
                  const [, setDraft] = getActiveDraft();
                  const defaultMandatoryAfterReset = stairActivePart === 'riser' || stairActivePart === 'landing';
                  setDraft({
                    stoneId: null,
                    stoneLabel: '',
                    stoneProduct: null,
                    pricePerSquareMeter: null,
                    useMandatory: defaultMandatoryAfterReset,
                    mandatoryPercentage: defaultMandatoryAfterReset ? 20 : null,
                    thicknessCm: null,
                    lengthValue: null,
                    lengthUnit: draft.lengthUnit || 'm', // Default to meters for length
                    widthCm: null,
                    quantity: null,
                    squareMeters: null,
                    tools: [],
                    totalPrice: null,
                    // Reset layer fields
                    numberOfLayersPerStair: null,
                    layerWidthCm: null,
                    layerTypeId: null,
                    layerTypeName: null,
                    layerTypePrice: null,
                    layerEdges: undefined,
                    layerUseDifferentStone: false,
                    layerStoneProductId: null,
                    layerStoneProduct: null,
                    layerStoneLabel: null,
                    layerPricePerSquareMeter: null,
                    layerUseMandatory: undefined,
                    layerMandatoryPercentage: null,
                    standardLengthValue: null,
                    standardLengthUnit: draft.lengthUnit || 'm',
                    finishingEnabled: false,
                    finishingId: null,
                    finishingLabel: null,
                    finishingPricePerSquareMeter: null
                  });
                  setStoneSearchTerm('');
                  setToolsSearchTerm('');
                  setToolsDropdownOpen(false);
                  setErrors({});
                }}>افزودن این بخش</button>
                <button type="button" className="px-3 py-2 rounded-md bg-green-600 text-white" onClick={() => {
                  if (!stairSessionItems.length) { setShowProductModal(false); return; }
                  
                  // Handle edit mode: replace existing products instead of adding new ones
                  if (isEditMode && editingProductIndex !== null) {
                    // Find the old stairSystemId from the product being edited
                    const oldProduct = wizardData.products[editingProductIndex];
                    const oldStairSystemId = oldProduct?.stairSystemId;
                    
                    if (oldStairSystemId) {
                      // Remove all old products with the same stairSystemId
                      const updatedProducts = wizardData.products.filter(p => 
                        !(p.productType === 'stair' && p.stairSystemId === oldStairSystemId)
                      );
                      
                      // Preserve the stairSystemId for the updated products and recalculate parentProductIndex for layers
                      const currentProductsCount = updatedProducts.length;
                      
                      // Create a map of session items to their final indices
                      const sessionToFinalIndexMap = new Map<ContractProduct, number>();
                      let nonLayerCount = 0;
                      stairSessionItems.forEach((item) => {
                        const isLayer = ((item.meta as any)?.isLayer) || false;
                        if (!isLayer) {
                          sessionToFinalIndexMap.set(item, currentProductsCount + nonLayerCount);
                          nonLayerCount++;
                        }
                      });
                      
                      const productsToAdd = stairSessionItems.map((item, sessionIndex) => {
                        const isLayer = ((item.meta as any)?.isLayer) || false;
                        if (isLayer) {
                          const layerInfo = (item.meta as any)?.layerInfo;
                          const parentIndexInSession = layerInfo?.parentProductIndexInSession;
                          
                          if (parentIndexInSession !== undefined && parentIndexInSession >= 0) {
                            const parentInSession = stairSessionItems[parentIndexInSession];
                            if (parentInSession) {
                              const parentFinalIndex = sessionToFinalIndexMap.get(parentInSession);
                              if (parentFinalIndex !== undefined && parentFinalIndex >= 0) {
                                return {
                                  ...item,
                                  stairSystemId: oldStairSystemId,
                                  parentProductIndex: parentFinalIndex
                                };
                              }
                            }
                          }
                        }
                        return {
                          ...item,
                          stairSystemId: oldStairSystemId
                        };
                      });
                      
                      // Add updated products
                      updateWizardData({ products: [...updatedProducts, ...productsToAdd] });
                    } else {
                      // Fallback: just replace the single product
                      const updatedProducts = [...wizardData.products];
                      updatedProducts[editingProductIndex] = stairSessionItems[0];
                      updateWizardData({ products: updatedProducts });
                    }
                  } else {
                    // Add mode: append session items to wizardData
                    // 🎯 Set parentProductIndex for layer products to link them to their parent stair part
                    const currentProductsCount = wizardData.products.length;
                    
                    // First, check for existing layer products in wizardData that should be merged
                    // Filter out layer products from session that already exist in wizardData
                    const sessionItemsToAdd: ContractProduct[] = [];
                    const layerProductsToMerge: Array<{ existing: ContractProduct; new: ContractProduct }> = [];
                    
                    stairSessionItems.forEach((item) => {
                      const isLayer = ((item.meta as any)?.isLayer) || false;
                      if (isLayer) {
                        // Check if this layer already exists in wizardData
                        const existingLayer = findExistingLayerProduct(wizardData.products, {
                          layerEdges: (item.meta as any)?.layerEdges,
                          layerWidthCm: item.width,
                          lengthValue: item.length,
                          lengthUnit: item.lengthUnit || 'm',
                          numberOfLayersPerStair: ((item.meta as any)?.layerInfo)?.numberOfLayersPerStair,
                          layerUseDifferentStone: item.layerUseDifferentStone,
                          layerStoneProductId: item.layerUseDifferentStone
                            ? (item.layerStoneProductId || item.productId)
                            : null
                        } as StairPartDraftV2, ((item.meta as any)?.layerInfo)?.parentPartType || 'tread');
                        
                        if (existingLayer) {
                          // Layer exists in wizardData - mark for merge instead of adding new
                          layerProductsToMerge.push({ existing: existingLayer, new: item });
                        } else {
                          // New layer - add to session items
                          sessionItemsToAdd.push(item);
                        }
                      } else {
                        // Non-layer item - always add
                        sessionItemsToAdd.push(item);
                      }
                    });
                    
                    // Create a map of session items to their final indices in wizardData.products
                    const sessionToFinalIndexMap = new Map<ContractProduct, number>();
                    let nonLayerCount = 0;
                    sessionItemsToAdd.forEach((item) => {
                      const isLayer = ((item.meta as any)?.isLayer) || false;
                      if (!isLayer) {
                        // Non-layer items are added in order
                        sessionToFinalIndexMap.set(item, currentProductsCount + nonLayerCount);
                        nonLayerCount++;
                      }
                    });
                    
                    // Now map all items and set parentProductIndex for layers
                    const productsToAdd = sessionItemsToAdd.map((item) => {
                      const isLayer = ((item.meta as any)?.isLayer) || false;
                      if (isLayer) {
                        const layerInfo = (item.meta as any)?.layerInfo;
                        const parentIndexInSession = layerInfo?.parentProductIndexInSession;
                        
                        if (parentIndexInSession !== undefined && parentIndexInSession >= 0) {
                          // Find the parent product in original session items (not filtered)
                          const parentInSession = stairSessionItems[parentIndexInSession];
                          
                          if (parentInSession) {
                            // Get the parent's final index from our map
                            const parentFinalIndex = sessionToFinalIndexMap.get(parentInSession);
                            
                            if (parentFinalIndex !== undefined && parentFinalIndex >= 0) {
                              return {
                                ...item,
                                parentProductIndex: parentFinalIndex
                              };
                            } else {
                              // Fallback: calculate based on session index (shouldn't happen, but handle gracefully)
                              console.warn('⚠️ Could not find parent final index for layer product, using fallback calculation');
                              // Find parent's index in original session
                              const parentSessionIndex = stairSessionItems.findIndex(p => p === parentInSession);
                              if (parentSessionIndex >= 0) {
                                // Count non-layer items before parent in session
                                let nonLayerBeforeParent = 0;
                                for (let i = 0; i < parentSessionIndex; i++) {
                                  if (!((stairSessionItems[i].meta as any)?.isLayer)) {
                                    nonLayerBeforeParent++;
                                  }
                                }
                                return {
                                  ...item,
                                  parentProductIndex: currentProductsCount + nonLayerBeforeParent
                                };
                              }
                            }
                          }
                        }
                      }
                      return item;
                    });
                    
                    // Merge existing layer products in wizardData
                    const updatedProducts = [...wizardData.products];
                    layerProductsToMerge.forEach(({ existing, new: newLayer }) => {
                      const existingIndex = updatedProducts.findIndex(p => p === existing);
                      if (existingIndex >= 0) {
                        const layerInfo = (newLayer.meta as any)?.layerInfo;
                        const existingLayerInfo = (existing.meta as any)?.layerInfo;
                        
                        // Merge the layer product
                        const metaLayerType = (newLayer.meta as any)?.layerType;
                        const mergedLayer = mergeLayerProduct(existing, {
                          draft: {
                            layerEdges: (newLayer.meta as any)?.layerEdges,
                            numberOfLayersPerStair: layerInfo?.numberOfLayersPerStair,
                            quantity: layerInfo?.parentQuantity || 0,
                            layerTypeId: newLayer.layerTypeId ?? metaLayerType?.id ?? null,
                            layerTypeName: newLayer.layerTypeName ?? metaLayerType?.name ?? null,
                            layerTypePrice: newLayer.layerTypePrice ?? metaLayerType?.pricePerLayer ?? null,
                            layerUseDifferentStone: newLayer.layerUseDifferentStone,
                            layerStoneProductId: newLayer.layerStoneProductId || newLayer.productId,
                            layerStoneProduct: newLayer.layerUseDifferentStone ? newLayer.product : null,
                            layerStoneLabel: newLayer.layerStoneName || newLayer.stoneName,
                            layerPricePerSquareMeter: newLayer.layerStonePricePerSquareMeter || newLayer.pricePerSquareMeter
                          } as StairPartDraftV2,
                          parentPartType: layerInfo?.parentPartType || 'tread',
                          newLayersNeeded: newLayer.quantity || 0,
                          newLayerSqm: newLayer.squareMeters || 0,
                          layerMaterialPrice: newLayer.originalTotalPrice || 0,
                          layerTypeCost: metaLayerType?.totalCost ?? ((newLayer.layerTypePrice || 0) * (newLayer.quantity || 0)),
                          totalLayerCuttingCost: newLayer.cuttingCost || 0,
                          layerCutDetails: newLayer.cutDetails || [],
                          usedRemainingStonesForLayers: newLayer.usedRemainingStones || [],
                          layersFromRemainingStones: layerInfo?.layersFromRemainingStones || 0,
                          layersFromNewStones: layerInfo?.layersFromNewStones || 0,
                          layerPricePerSquareMeter: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStonePricePerSquareMeter || newLayer.pricePerSquareMeter || 0)
                            : (newLayer.pricePerSquareMeter || 0),
                          layerStoneLabel: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStoneName || newLayer.stoneName)
                            : null,
                          layerUseDifferentStone: newLayer.layerUseDifferentStone,
                          layerStoneProductId: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStoneProductId || newLayer.productId)
                            : null,
                          layerStoneBasePricePerSquareMeter: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStoneBasePricePerSquareMeter || newLayer.layerStonePricePerSquareMeter || newLayer.pricePerSquareMeter || 0)
                            : null,
                          layerUseMandatory: newLayer.layerUseDifferentStone ? (newLayer.layerUseMandatory ?? true) : undefined,
                          layerMandatoryPercentage: newLayer.layerUseDifferentStone ? (newLayer.layerMandatoryPercentage ?? 0) : undefined,
                          stoneAreaUsedSqm: (newLayer.meta as any)?.stoneAreaUsedSqm
                        });
                        updatedProducts[existingIndex] = mergedLayer;
                      }
                    });
                    
                    updateWizardData({ products: [...updatedProducts, ...productsToAdd] });
                  }
                  
                  setStairSessionItems([]);
                  setStairSessionId(null);
                  setIsEditMode(false);
                  setEditingProductIndex(null);
                  setShowProductModal(false);
                }}>اتمام و افزودن به قرارداد</button>
              </div>
            </div>
          </div>
        )}
        {showProductModal && (productConfig.productType !== 'stair' || !useStairFlowV2) && (selectedProduct || (productConfig.productType === 'stair' && stairSystemConfig)) && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999] p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto z-[10000]">
              <div className="p-6">
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-white">
                    {isEditMode ? 'ویرایش تنظیمات محصول' : 'تنظیمات محصول'}
                  </h3>
                  <button
                    onClick={() => {
                      // Validate before closing if it's a stair system
                      if (productConfig.productType === 'stair' && stairSystemConfig) {
                        const hasSelectedPart = stairSystemConfig.tread.isSelected || 
                                                stairSystemConfig.riser.isSelected || 
                                                stairSystemConfig.landing.isSelected;
                        
                        if (!hasSelectedPart) {
                          setErrors({ products: 'لطفاً حداقل یکی از بخش‌های پله (کف پله، خیز پله، یا پاگرد) را انتخاب کنید' });
                          return;
                        }
                      }
                      
                      setShowProductModal(false);
                      setSelectedProduct(null);
                      setProductConfig({});
                      setLengthUnit('m');
                      setWidthUnit('cm');
                      setIsMandatory(false);
                      setMandatoryPercentage(20);
                      setIsEditMode(false);
                      setEditingProductIndex(null);
                      setTouchedFields(new Set()); // Reset touched fields
                      setStairSystemConfig(null);
                      setErrors({});
                    }}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                  >
                    <FaTimes className="w-6 h-6" />
                  </button>
                </div>

                {/* Error Display */}
                {errors.products && (
                  <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
                    <p className="text-red-600 dark:text-red-400 text-sm">{errors.products}</p>
                  </div>
                )}

                {/* Product Info - Show for longitudinal and slab products */}
                {selectedProduct && (productConfig.productType === 'longitudinal' || productConfig.productType === 'slab') && (
                  <div className={`mb-6 p-4 rounded-lg ${
                    productConfig.productType === 'slab' 
                      ? 'bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20 border border-indigo-200 dark:border-indigo-800' 
                      : 'bg-gray-50 dark:bg-gray-700'
                  }`}>
                    <div className="flex items-center justify-between mb-2">
                      <div className="flex items-center gap-2">
                        <h4 className="font-medium text-gray-800 dark:text-white">
                          {selectedProduct.namePersian}
                        </h4>
                        {productConfig.productType === 'slab' && (
                          <span className="px-2 py-1 bg-indigo-500 text-white text-xs rounded-full font-medium">
                            سنگ اسلب
                          </span>
                        )}
                        {productConfig.productType === 'longitudinal' && (
                          <span className="px-2 py-1 bg-teal-500 text-white text-xs rounded-full font-medium">
                            سنگ طولی
                          </span>
                        )}
                      </div>
                      {isEditMode && (
                        <span className="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 text-xs rounded-full">
                          حالت ویرایش
                        </span>
                      )}
                    </div>
                    <p className="text-sm text-gray-600 dark:text-gray-300">
                      {selectedProduct.stoneTypeNamePersian} • عرض {selectedProduct.widthValue}×ضخامت {selectedProduct.thicknessValue}cm
                      {productConfig.productType === 'slab' && (
                        <span className="ml-2 text-indigo-600 dark:text-indigo-400">• برش دو بعدی (طول و عرض)</span>
                      )}
                    </p>
                  </div>
                )}
                
                {/* Stair System Info - Show when editing stair system */}
                {productConfig.productType === 'stair' && stairSystemConfig && (
                  <div className="mb-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg border border-purple-200 dark:border-purple-800">
                    <div className="flex items-center justify-between mb-2">
                      <h4 className="font-medium text-purple-800 dark:text-purple-200">
                        ویرایش دستگاه پله
                      </h4>
                      {isEditMode && (
                        <span className="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 text-xs rounded-full">
                          حالت ویرایش
                        </span>
                      )}
                    </div>
                    <p className="text-sm text-purple-600 dark:text-purple-300">
                      {stairSystemConfig.numberOfSteps} پله ({stairSystemConfig.quantityType === 'steps' ? 'تعداد پله' : 'تعداد پله‌کان'})
                    </p>
                  </div>
                )}

                {/* Configuration Form */}
                <div className="space-y-4">
                  {/* Conditional rendering based on product type */}
                  {productConfig.productType === 'stair' ? (
                    /* STAIR SYSTEM (دستگاه پله) CONFIGURATION FORM - 3 Sections */
                    <>
                      {/* Common Configuration */}
                      <div className="space-y-4">
                        {/* Quantity Type Switcher */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg p-4 bg-gray-50 dark:bg-gray-700/50">
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
                            نوع تعداد:
                          </label>
                          <div className="flex gap-2">
                            <button
                              type="button"
                              onClick={() => {
                                setQuantityType('steps');
                                updateStairSystemConfig(prev => prev ? { ...prev, quantityType: 'steps' } : null);
                              }}
                              className={`flex-1 px-4 py-3 rounded-lg transition-all font-medium ${
                                stairSystemConfig?.quantityType === 'steps'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              تعداد پله
                            </button>
                            <button
                              type="button"
                              onClick={() => {
                                setQuantityType('staircases');
                                updateStairSystemConfig(prev => prev ? { ...prev, quantityType: 'staircases' } : null);
                              }}
                              className={`flex-1 px-4 py-3 rounded-lg transition-all font-medium ${
                                stairSystemConfig?.quantityType === 'staircases'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              تعداد پله‌کان کامل
                            </button>
                          </div>
                        </div>

                        {/* Number of Steps (Common) */}
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            {stairSystemConfig?.quantityType === 'steps' ? 'تعداد پله' : 'تعداد پله در هر پله‌کان'}
                          </label>
                          <FormattedNumberInput
                            value={stairSystemConfig?.numberOfSteps || 0}
                            onChange={(value) => {
                              updateStairSystemConfig(prev => {
                                if (!prev) return null;
                                const newNumberOfSteps = value || 0;
                                // Update default quantities for tread and riser if they haven't been manually changed
                                return {
                                  ...prev,
                                  numberOfSteps: newNumberOfSteps,
                                  tread: {
                                    ...prev.tread,
                                    quantity: prev.tread.quantity === 0 || prev.tread.quantity === prev.numberOfSteps 
                                      ? newNumberOfSteps 
                                      : prev.tread.quantity
                                  },
                                  riser: {
                                    ...prev.riser,
                                    quantity: prev.riser.quantity === 0 || prev.riser.quantity === prev.numberOfSteps 
                                      ? newNumberOfSteps 
                                      : prev.riser.quantity
                                  }
                                };
                              });
                            }}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                            min={0}
                            step={1}
                            placeholder="تعداد پله"
                          />
                        </div>

                        {/* Number of Staircases (if quantityType === 'staircases') */}
                        {stairSystemConfig?.quantityType === 'staircases' && (
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              تعداد پله‌کان کامل
                            </label>
                            <FormattedNumberInput
                              value={stairSystemConfig?.numberOfStaircases || 1}
                              onChange={(value) => {
                                updateStairSystemConfig(prev => prev ? { ...prev, numberOfStaircases: value || 1 } : null);
                              }}
                              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                              min={1}
                              step={1}
                              placeholder="1"
                            />
                          </div>
                        )}
                      </div>
                      {/* Three Collapsible Sections for Stair Parts */}
                      <div className="space-y-4">
                        {/* Section 1: کف پله (Tread) */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden">
                          <button
                            type="button"
                            onClick={() => setTreadExpanded(!treadExpanded)}
                            className="w-full flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                          >
                            <div className="flex items-center gap-3">
                              <input
                                type="checkbox"
                                checked={stairSystemConfig?.tread.isSelected || false}
                                onChange={(e) => {
                                  updateStairPart('tread', { isSelected: e.target.checked });
                                }}
                                onClick={(e) => e.stopPropagation()}
                                className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                              />
                              <span className="font-semibold text-gray-800 dark:text-white">کف پله (Tread)</span>
                            </div>
                            {treadExpanded ? (
                              <FaChevronUp className="text-gray-500 dark:text-gray-400" />
                            ) : (
                              <FaChevronDown className="text-gray-500 dark:text-gray-400" />
                            )}
                          </button>
                          
                          {treadExpanded && stairSystemConfig && (
                            <div className="p-4 space-y-4 border-t border-gray-200 dark:border-gray-600">
                              {/* Product Selection for Tread */}
                              <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  انتخاب محصول:
                                </label>
                                {stairSystemConfig.tread.product ? (
                                  <div className="p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg mb-2">
                                    <div className="flex items-center justify-between">
                                      <div>
                                        <p className="font-medium text-gray-800 dark:text-white">
                                          {generateFullProductName(stairSystemConfig.tread.product)}
                                        </p>
                                        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                          {stairSystemConfig.tread.product.stoneTypeNamePersian} • عرض {stairSystemConfig.tread.product.widthValue}×ضخامت {stairSystemConfig.tread.product.thicknessValue}cm
                                        </p>
                                      </div>
                                      <button
                                        type="button"
                                        onClick={() => {
                                          updateStairPart('tread', {
                                            productId: null,
                                            product: null,
                                            pricePerSquareMeter: 0
                                          });
                                          syncDraftWithProduct('tread', null);
                                          if (stairActivePart === 'tread') {
                                            setStoneSearchTerm('');
                                          }
                                          setTreadProductSearchTerm('');
                                        }}
                                        className="text-sm text-teal-600 dark:text-teal-400 hover:text-teal-700 dark:hover:text-teال-300"
                                      >
                                        تغییر
                                      </button>
                                    </div>
                                  </div>
                                ) : (
                                  <div className="mb-2">
                                    <div className="relative">
                                      <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                        <FaSearch className="h-5 w-5 text-gray-400" />
                                      </div>
                                      <input
                                        type="text"
                                        placeholder="جستجو محصول..."
                                        value={treadProductSearchTerm}
                                        onChange={(e) => setTreadProductSearchTerm(e.target.value)}
                                        className="w-full pr-10 pl-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      />
                                    </div>
                                    {treadProductSearchTerm && (
                                      <div className="mt-2 max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800">
                                        {filteredTreadProducts.map((product) => (
                                          <div
                                            key={product.id}
                                            onClick={() => {
                                              selectProductForStairPart('tread', product);
                                              setTreadProductSearchTerm('');
                                            }}
                                            className="p-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0"
                                          >
                                            <p className="font-medium text-gray-800 dark:text-white text-sm">
                                              {generateFullProductName(product)}
                                            </p>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                              {product.basePrice ? formatPrice(product.basePrice, product.currency) : 'قیمت تعیین نشده'}
                                            </p>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>

                              {/* Tread Dimensions */}
                              {stairSystemConfig.tread.product && (
                                <>
                                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {/* Tread Width */}
                                    <div>
                                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        طول پله (عرض پله‌کان)
                                      </label>
                                      <div className="space-y-2">
                                        <FormattedNumberInput
                                          value={stairSystemConfig.tread.treadWidth || 0}
                                          onChange={(value) => {
                                            updateStairPart('tread', { treadWidth: value || 0 });
                                          }}
                                          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                          min={0}
                                          step={0.1}
                                          placeholder="طول پله"
                                        />
                                        <div className="flex gap-1">
                                          <button
                                            type="button"
                                            onClick={() => {
                                              updateStairPart('tread', { lengthUnit: 'cm' });
                                              if (stairSystemConfig.tread.treadWidth) {
                                                const converted = stairSystemConfig.tread.lengthUnit === 'm' ? stairSystemConfig.tread.treadWidth * 100 : stairSystemConfig.tread.treadWidth;
                                                updateStairPart('tread', { treadWidth: converted });
                                              }
                                            }}
                                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                              stairSystemConfig.tread.lengthUnit === 'cm'
                                                ? 'bg-teal-500 text-white shadow-lg'
                                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                                            }`}
                                          >
                                            سانتی‌متر (cm)
                                          </button>
                                          <button
                                            type="button"
                                            onClick={() => {
                                              updateStairPart('tread', { lengthUnit: 'm' });
                                              if (stairSystemConfig.tread.treadWidth) {
                                                const converted = stairSystemConfig.tread.lengthUnit === 'cm' ? stairSystemConfig.tread.treadWidth / 100 : stairSystemConfig.tread.treadWidth;
                                                updateStairPart('tread', { treadWidth: converted });
                                              }
                                            }}
                                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                              stairSystemConfig.tread.lengthUnit === 'm'
                                                ? 'bg-teal-500 text-white shadow-lg'
                                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                                            }`}
                                          >
                                            متر (m)
                                          </button>
                                        </div>
                                      </div>
                                    </div>

                                    {/* Tread Depth */}
                                    <div>
                                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        عرض پله (عمق پله) (cm)
                                      </label>
                                      <FormattedNumberInput
                                        value={stairSystemConfig.tread.treadDepth || 30}
                                        onChange={(value) => {
                                          updateStairPart('tread', { treadDepth: value || 30 });
                                        }}
                                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        min={0}
                                        step={0.1}
                                        placeholder="30"
                                      />
                                      <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                        معمولاً 28-32 سانتی‌متر
                                      </p>
                                    </div>
                                  </div>

                                  {/* Quantity for Tread */}
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                      تعداد (پیش‌فرض: {stairSystemConfig.numberOfSteps || 0})
                                    </label>
                                    <FormattedNumberInput
                                      value={stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0}
                                      onChange={(value) => {
                                        updateStairPart('tread', { quantity: value || 0 });
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      min={0}
                                      step={1}
                                      placeholder={`${stairSystemConfig.numberOfSteps || 0}`}
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                      به طور پیش‌فرض با تعداد پله همگام است، اما می‌توانید تغییر دهید
                                    </p>
                                  </div>

                                  {/* Tread Calculations */}
                                  {(() => {
                                    const treadMetrics = calculateTreadMetrics({
                                      treadWidth: stairSystemConfig.tread.treadWidth || 0,
                                      treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                                      treadDepth: stairSystemConfig.tread.treadDepth || 30,
                                      quantity: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                                      quantityType: stairSystemConfig.quantityType,
                                      numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                                    });
                                    
                                    const nosingCost = calculateNosingCuttingCost({
                                      nosingType: stairSystemConfig.tread.nosingType || 'none',
                                      treadWidth: stairSystemConfig.tread.treadWidth || 0,
                                      treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                                      numberOfSteps: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                                      numberOfStaircases: stairSystemConfig.quantityType === 'staircases' ? (stairSystemConfig.numberOfStaircases || 1) : 1,
                                      quantityType: stairSystemConfig.quantityType
                                    });
                                    
                                    const basePrice = treadMetrics.totalArea * (stairSystemConfig.tread.pricePerSquareMeter || 0);
                                    const mandatoryPrice = stairSystemConfig.tread.isMandatory && stairSystemConfig.tread.mandatoryPercentage
                                      ? basePrice * (stairSystemConfig.tread.mandatoryPercentage / 100)
                                      : 0;
                                    const totalPrice = basePrice + mandatoryPrice + nosingCost.cuttingCost;
                                    
                                    // Update stair part with calculated values
                                    // Always update if squareMeters or totalPrice changed (to handle price/mandatory/nosing changes)
                                    // Use Math.abs to handle floating point comparison issues
                                    const squareMetersChanged = Math.abs((stairSystemConfig.tread.squareMeters || 0) - treadMetrics.totalArea) > 0.001;
                                    const totalPriceChanged = Math.abs((stairSystemConfig.tread.totalPrice || 0) - totalPrice) > 0.01;
                                    
                                    if (squareMetersChanged || totalPriceChanged) {
                                      // Use requestAnimationFrame for better state update timing
                                      requestAnimationFrame(() => {
                                        updateStairPart('tread', {
                                          squareMeters: treadMetrics.totalArea,
                                          totalPrice: totalPrice,
                                          originalTotalPrice: basePrice,
                                          nosingCuttingCost: nosingCost.cuttingCost,
                                          nosingCuttingCostPerMeter: nosingCost.cuttingCostPerMeter
                                        });
                                      });
                                    }
                                    
                                    return (
                                      <div className="space-y-3">
                                        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                                          <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">متر مربع:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatSquareMeters(treadMetrics.totalArea)}
                                              </span>
                                            </div>
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">تعداد:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatDisplayNumber(treadMetrics.totalQuantity)}
                                              </span>
                                            </div>
                                          </div>
                                        </div>

                                        {/* Nosing Configuration (only for tread) */}
                                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg p-3">
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            نوع پیشانی:
                                          </label>
                                          <select
                                            value={stairSystemConfig.tread.nosingType || 'none'}
                                            onChange={(e) => {
                                              updateStairPart('tread', { nosingType: e.target.value });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                          >
                                            {NOSING_TYPES.filter(n => n.available).map(nosing => (
                                              <option key={nosing.id} value={nosing.id}>
                                                {nosing.name} {nosing.cuttingCostPerMeter > 0 ? `(${formatPrice(nosing.cuttingCostPerMeter, 'تومان')}/متر)` : ''}
                                              </option>
                                            ))}
                                          </select>
                                          {nosingCost.cuttingCost > 0 && (
                                            <p className="text-xs text-blue-600 dark:text-blue-400 mt-2">
                                              هزینه برش پیشانی: {formatPrice(nosingCost.cuttingCost, 'تومان')}
                                            </p>
                                          )}
                                        </div>

                                        {/* Price per Square Meter */}
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            فی هر متر مربع (تومان):
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.tread.pricePerSquareMeter || 0}
                                            onChange={(value) => {
                                              updateStairPart('tread', { pricePerSquareMeter: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={1000}
                                            placeholder="قیمت هر متر مربع"
                                          />
                                        </div>

                                        {/* Mandatory Pricing for Tread */}
                                        <div className="border-t border-gray-200 dark:border-gray-600 pt-3">
                                          <div className="flex items-center space-x-3 space-x-reverse mb-2">
                                            <input
                                              type="checkbox"
                                              checked={stairSystemConfig.tread.isMandatory || false}
                                              onChange={(e) => {
                                                updateStairPart('tread', { isMandatory: e.target.checked });
                                              }}
                                              className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                                            />
                                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                              حکمی (افزایش قیمت)
                                            </label>
                                          </div>
                                          {stairSystemConfig.tread.isMandatory && (
                                            <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-3">
                                              <div className="flex items-center space-x-3 space-x-reverse">
                                                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                                  درصد افزایش:
                                                </label>
                                                <FormattedNumberInput
                                                  value={stairSystemConfig.tread.mandatoryPercentage || 20}
                                                  onChange={(value) => {
                                                    updateStairPart('tread', { mandatoryPercentage: value || 20 });
                                                  }}
                                                  className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                                  min={0}
                                                  max={100}
                                                />
                                                <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                                              </div>
                                            </div>
                                          )}
                                        </div>

                                        {/* Total Price for Tread */}
                                        {totalPrice > 0 && (
                                          <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border border-teal-200 dark:border-teal-800 rounded-lg p-3">
                                            <div className="flex justify-between items-center">
                                              <span className="text-sm font-medium text-teal-800 dark:text-teal-200">
                                                قیمت کل کف پله:
                                              </span>
                                              <span className="text-lg font-bold text-teal-900 dark:text-teal-100">
                                                {formatPrice(totalPrice, 'تومان')}
                                              </span>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })()}
                                </>
                              )}
                            </div>
                          )}
                        </div>
                        {/* Section 2: خیز پله (Riser) */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden">
                          <button
                            type="button"
                            onClick={() => setRiserExpanded(!riserExpanded)}
                            className="w-full flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                          >
                            <div className="flex items-center gap-3">
                              <input
                                type="checkbox"
                                checked={stairSystemConfig?.riser.isSelected || false}
                                onChange={(e) => {
                                  updateStairPart('riser', { isSelected: e.target.checked });
                                }}
                                onClick={(e) => e.stopPropagation()}
                                className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                              />
                              <span className="font-semibold text-gray-800 dark:text-white">خیز پله (Riser)</span>
                            </div>
                            {riserExpanded ? (
                              <FaChevronUp className="text-gray-500 dark:text-gray-400" />
                            ) : (
                              <FaChevronDown className="text-gray-500 dark:text-gray-400" />
                            )}
                          </button>
                          
                          {riserExpanded && stairSystemConfig && (
                            <div className="p-4 space-y-4 border-t border-gray-200 dark:border-gray-600">
                              {/* Product Selection for Riser */}
                              <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  انتخاب محصول:
                                </label>
                                {stairSystemConfig.riser.product ? (
                                  <div className="p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg mb-2">
                                    <div className="flex items-center justify-between">
                                      <div>
                                        <p className="font-medium text-gray-800 dark:text-white">
                                          {generateFullProductName(stairSystemConfig.riser.product)}
                                        </p>
                                        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                          {stairSystemConfig.riser.product.stoneTypeNamePersian} • عرض {stairSystemConfig.riser.product.widthValue}×ضخامت {stairSystemConfig.riser.product.thicknessValue}cm
                                        </p>
                                      </div>
                                      <button
                                        type="button"
                                        onClick={() => {
                                          updateStairPart('riser', {
                                            productId: null,
                                            product: null,
                                            pricePerSquareMeter: 0
                                          });
                                          syncDraftWithProduct('riser', null);
                                          if (stairActivePart === 'riser') {
                                            setStoneSearchTerm('');
                                          }
                                          setRiserProductSearchTerm('');
                                        }}
                                        className="text-sm text-teal-600 dark:text-teal-400 hover:text-teal-700 dark:hover:text-teال-300"
                                      >
                                        تغییر
                                      </button>
                                    </div>
                                  </div>
                                ) : (
                                  <div className="mb-2">
                                    <div className="relative">
                                      <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                        <FaSearch className="h-5 w-5 text-gray-400" />
                                      </div>
                                      <input
                                        type="text"
                                        placeholder="جستجو محصول..."
                                        value={riserProductSearchTerm}
                                        onChange={(e) => setRiserProductSearchTerm(e.target.value)}
                                        className="w-full pr-10 pl-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      />
                                    </div>
                                    {riserProductSearchTerm && (
                                      <div className="mt-2 max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800">
                                        {filteredRiserProducts.map((product) => (
                                          <div
                                            key={product.id}
                                            onClick={() => {
                                              selectProductForStairPart('riser', product);
                                              setRiserProductSearchTerm('');
                                            }}
                                            className="p-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0"
                                          >
                                            <p className="font-medium text-gray-800 dark:text-white text-sm">
                                              {generateFullProductName(product)}
                                            </p>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                              {product.basePrice ? formatPrice(product.basePrice, product.currency) : 'قیمت تعیین نشده'}
                                            </p>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>

                              {/* Riser Dimensions */}
                              {stairSystemConfig.riser.product && (
                                <>
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                      ارتفاع قائمه (cm)
                                    </label>
                                    <FormattedNumberInput
                                      value={stairSystemConfig.riser.riserHeight || 17}
                                      onChange={(value) => {
                                        updateStairPart('riser', { riserHeight: value || 17 });
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      min={0}
                                      step={0.1}
                                      placeholder="17"
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                      معمولاً 15-19 سانتی‌متر
                                    </p>
                                  </div>

                                  {/* Quantity for Riser */}
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                      تعداد (پیش‌فرض: {stairSystemConfig.numberOfSteps || 0})
                                    </label>
                                    <FormattedNumberInput
                                      value={stairSystemConfig.riser.quantity || stairSystemConfig.numberOfSteps || 0}
                                      onChange={(value) => {
                                        updateStairPart('riser', { quantity: value || 0 });
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      min={0}
                                      step={1}
                                      placeholder={`${stairSystemConfig.numberOfSteps || 0}`}
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                      به طور پیش‌فرض با تعداد پله همگام است، اما می‌توانید تغییر دهید
                                    </p>
                                  </div>

                                  {/* Riser Calculations */}
                                  {(() => {
                                    const treadWidth = stairSystemConfig.tread.treadWidth || 100;
                                    const treadWidthUnit = stairSystemConfig.tread.lengthUnit || 'm';
                                    
                                    const riserMetrics = calculateRiserMetrics({
                                      treadWidth: treadWidth,
                                      treadWidthUnit: treadWidthUnit,
                                      riserHeight: stairSystemConfig.riser.riserHeight || 17,
                                      quantity: stairSystemConfig.riser.quantity || stairSystemConfig.numberOfSteps || 0,
                                      quantityType: stairSystemConfig.quantityType,
                                      numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                                    });
                                    
                                    const basePrice = riserMetrics.totalArea * (stairSystemConfig.riser.pricePerSquareMeter || 0);
                                    const mandatoryPrice = stairSystemConfig.riser.isMandatory && stairSystemConfig.riser.mandatoryPercentage
                                      ? basePrice * (stairSystemConfig.riser.mandatoryPercentage / 100)
                                      : 0;
                                    const totalPrice = basePrice + mandatoryPrice;
                                    
                                    // Update riser part with calculated values
                                    // Always update if squareMeters or totalPrice changed (to handle price/mandatory changes)
                                    // Use Math.abs to handle floating point comparison issues
                                    const squareMetersChanged = Math.abs((stairSystemConfig.riser.squareMeters || 0) - riserMetrics.totalArea) > 0.001;
                                    const totalPriceChanged = Math.abs((stairSystemConfig.riser.totalPrice || 0) - totalPrice) > 0.01;
                                    
                                    if (squareMetersChanged || totalPriceChanged) {
                                      // Use requestAnimationFrame for better state update timing
                                      requestAnimationFrame(() => {
                                        updateStairPart('riser', {
                                          squareMeters: riserMetrics.totalArea,
                                          totalPrice: totalPrice,
                                          originalTotalPrice: basePrice
                                        });
                                      });
                                    }
                                    
                                    return (
                                      <div className="space-y-3">
                                        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                                          <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">متر مربع:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatSquareMeters(riserMetrics.totalArea)}
                                              </span>
                                            </div>
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">تعداد:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatDisplayNumber(riserMetrics.totalQuantity)}
                                              </span>
                                            </div>
                                          </div>
                                        </div>

                                        {/* Price per Square Meter */}
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            فی هر متر مربع (تومان):
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.riser.pricePerSquareMeter || 0}
                                            onChange={(value) => {
                                              updateStairPart('riser', { pricePerSquareMeter: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={1000}
                                            placeholder="قیمت هر متر مربع"
                                          />
                                        </div>

                                        {/* Mandatory Pricing for Riser */}
                                        <div className="border-t border-gray-200 dark:border-gray-600 pt-3">
                                          <div className="flex items-center space-x-3 space-x-reverse mb-2">
                                            <input
                                              type="checkbox"
                                              checked={stairSystemConfig.riser.isMandatory || false}
                                              onChange={(e) => {
                                                updateStairPart('riser', { isMandatory: e.target.checked });
                                              }}
                                              className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                                            />
                                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                              حکمی (افزایش قیمت)
                                            </label>
                                          </div>
                                          {stairSystemConfig.riser.isMandatory && (
                                            <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-3">
                                              <div className="flex items-center space-x-3 space-x-reverse">
                                                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                                  درصد افزایش:
                                                </label>
                                                <FormattedNumberInput
                                                  value={stairSystemConfig.riser.mandatoryPercentage || 20}
                                                  onChange={(value) => {
                                                    updateStairPart('riser', { mandatoryPercentage: value || 20 });
                                                  }}
                                                  className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                                  min={0}
                                                  max={100}
                                                />
                                                <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                                              </div>
                                            </div>
                                          )}
                                        </div>

                                        {/* Total Price for Riser */}
                                        {totalPrice > 0 && (
                                          <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border border-teal-200 dark:border-teal-800 rounded-lg p-3">
                                            <div className="flex justify-between items-center">
                                              <span className="text-sm font-medium text-teal-800 dark:text-teal-200">
                                                قیمت کل خیز پله:
                                              </span>
                                              <span className="text-lg font-bold text-teal-900 dark:text-teal-100">
                                                {formatPrice(totalPrice, 'تومان')}
                                              </span>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })()}
                                </>
                              )}
                            </div>
                          )}
                        </div>
                        {/* Section 3: پاگرد (Landing) */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden">
                          <button
                            type="button"
                            onClick={() => setLandingExpanded(!landingExpanded)}
                            className="w-full flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                          >
                            <div className="flex items-center gap-3">
                              <input
                                type="checkbox"
                                checked={stairSystemConfig?.landing.isSelected || false}
                                onChange={(e) => {
                                  updateStairPart('landing', { isSelected: e.target.checked });
                                }}
                                onClick={(e) => e.stopPropagation()}
                                className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                              />
                              <span className="font-semibold text-gray-800 dark:text-white">پاگرد (Landing)</span>
                            </div>
                            {landingExpanded ? (
                              <FaChevronUp className="text-gray-500 dark:text-gray-400" />
                            ) : (
                              <FaChevronDown className="text-gray-500 dark:text-gray-400" />
                            )}
                          </button>
                          
                          {landingExpanded && stairSystemConfig && (
                            <div className="p-4 space-y-4 border-t border-gray-200 dark:border-gray-600">
                              {/* Product Selection for Landing */}
                              <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  انتخاب محصول:
                                </label>
                                {stairSystemConfig.landing.product ? (
                                  <div className="p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg mb-2">
                                    <div className="flex items-center justify-between">
                                      <div>
                                        <p className="font-medium text-gray-800 dark:text-white">
                                          {generateFullProductName(stairSystemConfig.landing.product)}
                                        </p>
                                        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                          {stairSystemConfig.landing.product.stoneTypeNamePersian} • عرض {stairSystemConfig.landing.product.widthValue}×ضخامت {stairSystemConfig.landing.product.thicknessValue}cm
                                        </p>
                                      </div>
                                      <button
                                        type="button"
                                        onClick={() => {
                                          updateStairPart('landing', {
                                            productId: null,
                                            product: null,
                                            pricePerSquareMeter: 0
                                          });
                                          syncDraftWithProduct('landing', null);
                                          if (stairActivePart === 'landing') {
                                            setStoneSearchTerm('');
                                          }
                                          setLandingProductSearchTerm('');
                                        }}
                                        className="text-sm text-teal-600 dark:text-teal-400 hover:text-teal-700 dark:hover:text-teال-300"
                                      >
                                        تغییر
                                      </button>
                                    </div>
                                  </div>
                                ) : (
                                  <div className="mb-2">
                                    <div className="relative">
                                      <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                        <FaSearch className="h-5 w-5 text-gray-400" />
                                      </div>
                                      <input
                                        type="text"
                                        placeholder="جستجو محصول..."
                                        value={landingProductSearchTerm}
                                        onChange={(e) => setLandingProductSearchTerm(e.target.value)}
                                        className="w-full pr-10 pl-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      />
                                    </div>
                                    {landingProductSearchTerm && (
                                      <div className="mt-2 max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800">
                                        {filteredLandingProducts.map((product) => (
                                          <div
                                            key={product.id}
                                            onClick={() => {
                                              selectProductForStairPart('landing', product);
                                              setLandingProductSearchTerm('');
                                            }}
                                            className="p-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0"
                                          >
                                            <p className="font-medium text-gray-800 dark:text-white text-sm">
                                              {generateFullProductName(product)}
                                            </p>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                              {product.basePrice ? formatPrice(product.basePrice, product.currency) : 'قیمت تعیین نشده'}
                                            </p>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>

                              {/* Landing Dimensions */}
                              {stairSystemConfig.landing.product && (
                                <>
                                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div>
                                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        تعداد پاگرد
                                      </label>
                                      <FormattedNumberInput
                                        value={stairSystemConfig.landing.numberOfLandings || 0}
                                        onChange={(value) => {
                                          updateStairPart('landing', { numberOfLandings: value || 0 });
                                        }}
                                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        min={0}
                                        step={1}
                                        placeholder="0"
                                      />
                                    </div>
                                    {stairSystemConfig.landing.numberOfLandings && stairSystemConfig.landing.numberOfLandings > 0 && (
                                      <>
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            عرض پاگرد (cm)
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.landing.landingWidth || 0}
                                            onChange={(value) => {
                                              updateStairPart('landing', { landingWidth: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={0.1}
                                            placeholder="عرض"
                                          />
                                        </div>
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            عمق پاگرد (cm)
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.landing.landingDepth || 0}
                                            onChange={(value) => {
                                              updateStairPart('landing', { landingDepth: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={0.1}
                                            placeholder="عمق"
                                          />
                                        </div>
                                      </>
                                    )}
                                  </div>

                                  {/* Landing Calculations */}
                                  {(() => {
                                    const landingMetrics = calculateLandingMetrics({
                                      landingWidth: stairSystemConfig.landing.landingWidth || 0,
                                      landingDepth: stairSystemConfig.landing.landingDepth || 0,
                                      numberOfLandings: stairSystemConfig.landing.numberOfLandings || 0,
                                      quantityType: stairSystemConfig.quantityType,
                                      numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                                    });
                                    
                                    const basePrice = landingMetrics.totalArea * (stairSystemConfig.landing.pricePerSquareMeter || 0);
                                    const mandatoryPrice = stairSystemConfig.landing.isMandatory && stairSystemConfig.landing.mandatoryPercentage
                                      ? basePrice * (stairSystemConfig.landing.mandatoryPercentage / 100)
                                      : 0;
                                    const totalPrice = basePrice + mandatoryPrice;
                                    
                                    // Update landing part with calculated values
                                    // Always update if squareMeters or totalPrice changed (to handle price/mandatory changes)
                                    // Use Math.abs to handle floating point comparison issues
                                    const squareMetersChanged = Math.abs((stairSystemConfig.landing.squareMeters || 0) - landingMetrics.totalArea) > 0.001;
                                    const totalPriceChanged = Math.abs((stairSystemConfig.landing.totalPrice || 0) - totalPrice) > 0.01;
                                    
                                    if (squareMetersChanged || totalPriceChanged) {
                                      // Use requestAnimationFrame for better state update timing
                                      requestAnimationFrame(() => {
                                        updateStairPart('landing', {
                                          squareMeters: landingMetrics.totalArea,
                                          quantity: landingMetrics.totalQuantity,
                                          totalPrice: totalPrice,
                                          originalTotalPrice: basePrice
                                        });
                                      });
                                    }
                                    
                                    return (
                                      <div className="space-y-3">
                                        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                                          <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">متر مربع:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatSquareMeters(landingMetrics.totalArea)}
                                              </span>
                                            </div>
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">تعداد:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatDisplayNumber(landingMetrics.totalQuantity)}
                                              </span>
                                            </div>
                                          </div>
                                        </div>

                                        {/* Price per Square Meter */}
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            فی هر متر مربع (تومان):
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.landing.pricePerSquareMeter || 0}
                                            onChange={(value) => {
                                              updateStairPart('landing', { pricePerSquareMeter: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={1000}
                                            placeholder="قیمت هر متر مربع"
                                          />
                                        </div>

                                        {/* Mandatory Pricing for Landing */}
                                        <div className="border-t border-gray-200 dark:border-gray-600 pt-3">
                                          <div className="flex items-center space-x-3 space-x-reverse mb-2">
                                            <input
                                              type="checkbox"
                                              checked={stairSystemConfig.landing.isMandatory || false}
                                              onChange={(e) => {
                                                updateStairPart('landing', { isMandatory: e.target.checked });
                                              }}
                                              className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                                            />
                                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                              حکمی (افزایش قیمت)
                                            </label>
                                          </div>
                                          {stairSystemConfig.landing.isMandatory && (
                                            <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-3">
                                              <div className="flex items-center space-x-3 space-x-reverse">
                                                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                                  درصد افزایش:
                                                </label>
                                                <FormattedNumberInput
                                                  value={stairSystemConfig.landing.mandatoryPercentage || 20}
                                                  onChange={(value) => {
                                                    updateStairPart('landing', { mandatoryPercentage: value || 20 });
                                                  }}
                                                  className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                                  min={0}
                                                  max={100}
                                                />
                                                <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                                              </div>
                                            </div>
                                          )}
                                        </div>

                                        {/* Total Price for Landing */}
                                        {totalPrice > 0 && (
                                          <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border border-teal-200 dark:border-teal-800 rounded-lg p-3">
                                            <div className="flex justify-between items-center">
                                              <span className="text-sm font-medium text-teal-800 dark:text-teal-200">
                                                قیمت کل پاگرد:
                                              </span>
                                              <span className="text-lg font-bold text-teal-900 dark:text-teal-100">
                                                {formatPrice(totalPrice, 'تومان')}
                                              </span>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })()}
                                </>
                              )}
                            </div>
                          )}
                        </div>
                        {/* Total Summary */}
                        {stairSystemConfig && (() => {
                          // Calculate totals directly from current values to ensure accuracy
                          // This avoids relying on state that might not be updated yet
                          
                          // Calculate Tread Total
                          let treadTotal = 0;
                          if (stairSystemConfig.tread.isSelected && stairSystemConfig.tread.product) {
                            const treadMetrics = calculateTreadMetrics({
                              treadWidth: stairSystemConfig.tread.treadWidth || 0,
                              treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                              treadDepth: stairSystemConfig.tread.treadDepth || 30,
                              quantity: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                              quantityType: stairSystemConfig.quantityType,
                              numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                            });
                            
                            const nosingCost = calculateNosingCuttingCost({
                              nosingType: stairSystemConfig.tread.nosingType || 'none',
                              treadWidth: stairSystemConfig.tread.treadWidth || 0,
                              treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                              numberOfSteps: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                              numberOfStaircases: stairSystemConfig.quantityType === 'staircases' ? (stairSystemConfig.numberOfStaircases || 1) : 1,
                              quantityType: stairSystemConfig.quantityType
                            });
                            
                            const basePrice = treadMetrics.totalArea * (stairSystemConfig.tread.pricePerSquareMeter || 0);
                            const mandatoryPrice = stairSystemConfig.tread.isMandatory && stairSystemConfig.tread.mandatoryPercentage
                              ? basePrice * (stairSystemConfig.tread.mandatoryPercentage / 100)
                              : 0;
                            treadTotal = basePrice + mandatoryPrice + nosingCost.cuttingCost;
                          }
                          
                          // Calculate Riser Total
                          let riserTotal = 0;
                          if (stairSystemConfig.riser.isSelected && stairSystemConfig.riser.product) {
                            const treadWidth = stairSystemConfig.tread.treadWidth || 100;
                            const treadWidthUnit = stairSystemConfig.tread.lengthUnit || 'm';
                            
                            const riserMetrics = calculateRiserMetrics({
                              treadWidth: treadWidth,
                              treadWidthUnit: treadWidthUnit,
                              riserHeight: stairSystemConfig.riser.riserHeight || 17,
                              quantity: stairSystemConfig.riser.quantity || stairSystemConfig.numberOfSteps || 0,
                              quantityType: stairSystemConfig.quantityType,
                              numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                            });
                            
                            const basePrice = riserMetrics.totalArea * (stairSystemConfig.riser.pricePerSquareMeter || 0);
                            const mandatoryPrice = stairSystemConfig.riser.isMandatory && stairSystemConfig.riser.mandatoryPercentage
                              ? basePrice * (stairSystemConfig.riser.mandatoryPercentage / 100)
                              : 0;
                            riserTotal = basePrice + mandatoryPrice;
                          }
                          
                          // Calculate Landing Total
                          let landingTotal = 0;
                          if (stairSystemConfig.landing.isSelected && stairSystemConfig.landing.product) {
                            const landingMetrics = calculateLandingMetrics({
                              landingWidth: stairSystemConfig.landing.landingWidth || 0,
                              landingDepth: stairSystemConfig.landing.landingDepth || 0,
                              numberOfLandings: stairSystemConfig.landing.numberOfLandings || 0,
                              quantityType: stairSystemConfig.quantityType,
                              numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                            });
                            
                            const basePrice = landingMetrics.totalArea * (stairSystemConfig.landing.pricePerSquareMeter || 0);
                            const mandatoryPrice = stairSystemConfig.landing.isMandatory && stairSystemConfig.landing.mandatoryPercentage
                              ? basePrice * (stairSystemConfig.landing.mandatoryPercentage / 100)
                              : 0;
                            landingTotal = basePrice + mandatoryPrice;
                          }
                          
                          const grandTotal = treadTotal + riserTotal + landingTotal;
                          
                          return (
                            <div className="bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/30 dark:to-purple-800/30 border border-purple-200 dark:border-purple-800 rounded-lg p-4">
                              <h4 className="text-sm font-semibold text-purple-800 dark:text-purple-200 mb-3">
                                خلاصه دستگاه پله:
                              </h4>
                              <div className="space-y-2 text-sm">
                                {stairSystemConfig.tread.isSelected && treadTotal > 0 && (
                                  <div className="flex justify-between">
                                    <span className="text-gray-700 dark:text-gray-300">کف پله:</span>
                                    <span className="font-semibold text-gray-800 dark:text-white">
                                      {formatPrice(treadTotal, 'تومان')}
                                    </span>
                                  </div>
                                )}
                                {stairSystemConfig.riser.isSelected && riserTotal > 0 && (
                                  <div className="flex justify-between">
                                    <span className="text-gray-700 dark:text-gray-300">خیز پله:</span>
                                    <span className="font-semibold text-gray-800 dark:text-white">
                                      {formatPrice(riserTotal, 'تومان')}
                                    </span>
                                  </div>
                                )}
                                {stairSystemConfig.landing.isSelected && landingTotal > 0 && (
                                  <div className="flex justify-between">
                                    <span className="text-gray-700 dark:text-gray-300">پاگرد:</span>
                                    <span className="font-semibold text-gray-800 dark:text-white">
                                      {formatPrice(landingTotal, 'تومان')}
                                    </span>
                                  </div>
                                )}
                                <div className="border-t border-purple-200 dark:border-purple-700 pt-2 mt-2">
                                  <div className="flex justify-between">
                                    <span className="font-bold text-purple-800 dark:text-purple-200">جمع کل:</span>
                                    <span className="font-bold text-lg text-purple-900 dark:text-purple-100">
                                      {formatPrice(grandTotal, 'تومان')}
                                    </span>
                                  </div>
                                </div>
                              </div>
                            </div>
                          );
                        })()}
                      </div>
                    </>
                  ) : null}
                  
                  {/* Conditional for longitudinal and slab stones (only shown if not stair) */}
                  {(productConfig.productType === 'longitudinal' || productConfig.productType === 'slab') && (
                    <>
                      {/* LONGITUDINAL STONE CONFIGURATION FORM (existing) */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            نام کامل سنگ
                          </label>
                          <div className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-600 text-gray-800 dark:text-white">
                            {selectedProduct ? generateFullProductName(selectedProduct) : 'محصولی انتخاب نشده است'}
                          </div>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            نام یا نوع سنگ
                          </label>
                          <input
                            type="text"
                            value={productConfig.stoneName || ''}
                            onFocus={() => handleFieldFocus('stoneName', productConfig.stoneName, '')}
                            onChange={(e) => setProductConfig(prev => ({ ...prev, stoneName: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                          />
                        </div>
                      </div>
                  {/* For Slab: Enhanced Requested Dimensions Section */}
                  {productConfig.productType === 'slab' ? (
                    <div className="bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20 border-2 border-blue-200 dark:border-blue-800 rounded-xl p-6 shadow-lg">
                      <div className="flex items-center gap-3 mb-5">
                        <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 dark:from-blue-600 dark:to-indigo-700 flex items-center justify-center shadow-md">
                          <FaRuler className="text-white text-xl" />
                        </div>
                    <div>
                          <h4 className="text-lg font-bold text-blue-900 dark:text-blue-100">ابعاد درخواستی</h4>
                          <p className="text-xs text-blue-700 dark:text-blue-300">مشخصات مورد نیاز برای محصول نهایی</p>
                        </div>
                      </div>
                      
                      {/* Length and Width Inputs in Row */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        {/* Length Input */}
                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-blue-200 dark:border-blue-700 shadow-sm">
                          <label className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3 flex items-center gap-2">
                            <FaRuler className="text-blue-600 dark:text-blue-400" />
                            طول درخواستی
                      </label>
                        <FormattedNumberInput
                          value={productConfig.length || 0}
                          onFocus={() => handleFieldFocus('length', productConfig.length, 0)}
                          onChange={(value) => {
                            // Update the length first
                            setProductConfig(prev => {
                              const updatedConfig = { ...prev, length: value };
                              // Trigger smart calculation with updated config
                              const smartResult = handleSmartCalculation('length', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                              const finalConfig = {
                                ...updatedConfig,
                                width: smartResult.width,
                                squareMeters: smartResult.squareMeters
                              };
                              
                              // For slab products, validate length against original length
                              if (prev.productType === 'slab' && value > 0) {
                                const userLengthInCm = lengthUnit === 'm' ? value * 100 : value;
                                const originalLength = (isEditMode && prev.originalLength !== undefined) 
                                  ? prev.originalLength 
                                  : ((selectedProduct as any).lengthValue || 300);
                                const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
                                
                                if (originalLengthCm > 0 && userLengthInCm > originalLengthCm) {
                                  setErrors({ 
                                    products: `طول وارد شده (${value}${lengthUnit === 'm' ? 'm' : 'cm'}) بیشتر از طول اصلی اسلب (${originalLengthCm / (lengthUnit === 'm' ? 100 : 1)}${lengthUnit === 'm' ? 'm' : 'cm'}) است. لطفاً طولی کمتر یا مساوی وارد کنید.` 
                                  });
                                } else if (errors.products && errors.products.includes('طول وارد شده')) {
                                  setErrors({});
                                }
                              }
                              
                              // Check if we need to auto-select longitudinal cut after smart calculation
                              const userWidthInCm = widthUnit === 'm' ? finalConfig.width * 100 : finalConfig.width;
                              // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
                              const originalWidth = (isEditMode && prev.originalWidth) ? prev.originalWidth : (selectedProduct?.widthValue || 0);
                              const shouldAutoSelectLongitudinalCut = userWidthInCm < originalWidth && userWidthInCm > 0;
                              
                              console.log('📏 Length Changed - Auto Cut Selection:', {
                                userLength: value,
                                userLengthUnit: lengthUnit,
                                calculatedWidth: finalConfig.width,
                                userWidthInCm,
                                originalWidth,
                                shouldAutoSelectLongitudinalCut,
                                comparison: `${userWidthInCm} < ${originalWidth} = ${userWidthInCm < originalWidth}`
                              });
                              
                              // Automatically get cutting type price if cut should be applied
                              let cuttingCostPerMeter: number | null | undefined = prev.cuttingCostPerMeter || null;
                              if (shouldAutoSelectLongitudinalCut && !cuttingCostPerMeter) {
                                // Fetch price from cutting types for "LONG" (برش طولی)
                                cuttingCostPerMeter = getCuttingTypePricePerMeter('LONG');
                                console.log('🔧 Auto-fetched cutting cost per meter from services:', cuttingCostPerMeter);
                              } else if (!shouldAutoSelectLongitudinalCut) {
                                // Clear cutting cost if cut is not needed
                                cuttingCostPerMeter = undefined;
                              }
                              
                              // Calculate cutting cost automatically
                              const effectiveQuantity = getEffectiveQuantity();
                              const updatedCuttingCost = calculateAutoCuttingCost(
                                value,
                                lengthUnit,
                                cuttingCostPerMeter,
                                effectiveQuantity
                              );
                              
                              // Auto-select cut type based on calculated width
                              if (shouldAutoSelectLongitudinalCut && cuttingCostPerMeter) {
                                return {
                                  ...finalConfig,
                                  isCut: true,
                                  cutType: 'longitudinal',
                                  cuttingCostPerMeter: cuttingCostPerMeter,
                                  cuttingCost: updatedCuttingCost
                                };
                              } else {
                                return {
                                  ...finalConfig,
                                  isCut: false,
                                  cutType: null,
                                  cuttingCostPerMeter: undefined,
                                  cuttingCost: 0
                                };
                              }
                            });
                          }}
                          className="w-full px-4 py-3 text-base border-2 border-blue-300 dark:border-blue-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                          min={0}
                          step={0.1}
                          placeholder="مقدار طول"
                        />
                          <div className="flex gap-2 mt-3">
                          <button
                            type="button"
                            onClick={() => handleLengthUnitChange('cm')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                              lengthUnit === 'cm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                            }`}
                          >
                            سانتی‌متر (cm)
                          </button>
                          <button
                            type="button"
                            onClick={() => handleLengthUnitChange('m')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                              lengthUnit === 'm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                            }`}
                          >
                            متر (m)
                          </button>
                        </div>
                      </div>
                        
                        {/* Width Input */}
                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-blue-200 dark:border-blue-700 shadow-sm">
                          <label className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3 flex items-center gap-2">
                            <FaRuler className="text-blue-600 dark:text-blue-400" />
                            عرض درخواستی
                      </label>
                        <FormattedNumberInput
                          value={productConfig.width || 0}
                          onFocus={() => {
                            handleFieldFocus('width', productConfig.width, 0);
                            // Clear width error on focus to allow user to fix it
                            if (errors.products && errors.products.includes('عرض وارد شده')) {
                              setErrors({});
                            }
                          }}
                          onChange={(value) => {
                            // Update the width first
                            setProductConfig(prev => {
                              const updatedConfig = { ...prev, width: value };
                              // Trigger smart calculation with updated config
                              const smartResult = handleSmartCalculation('width', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                              return {
                                ...updatedConfig,
                                length: smartResult.length,
                                squareMeters: smartResult.squareMeters
                              };
                            });
                            
                            // Calculate width in cm for comparison
                            const userWidthInCm = widthUnit === 'm' ? value * 100 : value;
                            
                            // Get original width for validation
                            const originalWidth = (isEditMode && productConfig.originalWidth) 
                              ? productConfig.originalWidth 
                              : (selectedProduct?.widthValue || 0);
                            
                            // Validate: width cannot exceed original width
                            if (value > 0 && originalWidth > 0 && userWidthInCm > originalWidth) {
                              // Show error message
                              setErrors({ 
                                products: `عرض وارد شده (${value}${widthUnit === 'm' ? 'm' : 'cm'}) بیشتر از عرض اصلی سنگ (${originalWidth}cm) است. لطفاً عرضی کمتر یا مساوی با ${originalWidth}cm وارد کنید.` 
                              });
                            } else {
                              // Clear error if width is valid
                              if (errors.products && errors.products.includes('عرض وارد شده')) {
                                setErrors({});
                              }
                            }
                            
                            // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
                            setProductConfig(prev => {
                              const originalWidth = (isEditMode && prev.originalWidth) ? prev.originalWidth : (selectedProduct?.widthValue || 0);
                              const shouldAutoSelectLongitudinalCut = userWidthInCm < originalWidth && userWidthInCm > 0;
                              
                              // Log width change and auto-selection logic
                              console.log('📏 Width Changed - Auto Cut Selection:', {
                                userWidth: value,
                                userWidthUnit: widthUnit,
                                userWidthInCm,
                                originalWidth,
                                shouldAutoSelectLongitudinalCut,
                                comparison: `${userWidthInCm} < ${originalWidth} = ${userWidthInCm < originalWidth}`
                              });
                              
                              // Automatically get cutting type price if cut should be applied
                              let cuttingCostPerMeter: number | null | undefined = prev.cuttingCostPerMeter || null;
                              if (shouldAutoSelectLongitudinalCut && !cuttingCostPerMeter) {
                                // Fetch price from cutting types for "LONG" (برش طولی)
                                cuttingCostPerMeter = getCuttingTypePricePerMeter('LONG');
                                console.log('🔧 Auto-fetched cutting cost per meter from services:', cuttingCostPerMeter);
                              } else if (!shouldAutoSelectLongitudinalCut) {
                                // Clear cutting cost if cut is not needed
                                cuttingCostPerMeter = undefined;
                              }
                              
                              // Calculate cutting cost automatically
                              const effectiveQuantity = getEffectiveQuantity();
                              const updatedCuttingCost = calculateAutoCuttingCost(
                                prev.length,
                                lengthUnit,
                                cuttingCostPerMeter,
                                effectiveQuantity
                              );
                              
                              // Update cut type based on width comparison
                              if (shouldAutoSelectLongitudinalCut && cuttingCostPerMeter) {
                                return {
                                  ...prev,
                                  isCut: true,
                                  cutType: 'longitudinal',
                                  cuttingCostPerMeter: cuttingCostPerMeter,
                                  cuttingCost: updatedCuttingCost
                                };
                              } else {
                                return {
                                  ...prev,
                                  isCut: false,
                                  cutType: null,
                                  cuttingCostPerMeter: undefined,
                                  cuttingCost: 0
                                };
                              }
                            });
                          }}
                          className={`w-full px-4 py-3 text-base border-2 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 transition-all ${
                            errors.products && errors.products.includes('عرض وارد شده')
                              ? 'border-red-500 dark:border-red-500 focus:ring-red-500 focus:border-red-500'
                              : 'border-blue-300 dark:border-blue-600 focus:ring-blue-500 focus:border-blue-500'
                          }`}
                          min={0}
                          step={0.1}
                          placeholder="مقدار عرض"
                        />
                          <div className="flex gap-2 mt-3">
                            <button
                              type="button"
                              onClick={() => handleWidthUnitChange('cm')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                                widthUnit === 'cm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                              }`}
                            >
                              سانتی‌متر (cm)
                            </button>
                            <button
                              type="button"
                              onClick={() => handleWidthUnitChange('m')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                                widthUnit === 'm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                              }`}
                            >
                              متر (m)
                            </button>
                          </div>
                        </div>
                      </div>
                      
                      {/* Quantity and Summary Row */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-blue-200 dark:border-blue-700">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">
                            تعداد
                          </label>
                          <FormattedNumberInput
                            value={getQuantityDisplayValue()}
                            onFocus={() => handleFieldFocus('quantity', getQuantityDisplayValue(), 0)}
                            onChange={(value) => {
                              // Check if quantity is being cleared/deleted (empty or 0)
                              const isQuantityCleared = !value || value === 0;
                              
                              // Mark quantity as interacted
                              if (!hasQuantityBeenInteracted) {
                                setHasQuantityBeenInteracted(true);
                                console.log('🎯 Quantity First Interaction');
                              }
                              
                              // Handle mandatory pricing based on quantity state
                              if (isQuantityCleared) {
                                // If quantity is cleared, uncheck mandatory pricing and reset interaction state
                                setIsMandatory(false);
                                setHasQuantityBeenInteracted(false);
                                console.log('🔄 Quantity Cleared - Deactivating mandatory pricing and resetting interaction state');
                              } else {
                                // If quantity has a value, activate mandatory pricing
                                setIsMandatory(true);
                                console.log('✅ Quantity Has Value - Activating mandatory pricing');
                              }
                              
                              // Update the quantity
                              setProductConfig(prev => {
                                const updatedConfig = { ...prev, quantity: value };
                                // Use effective quantity for calculations
                                const effectiveQuantity = value || 1;
                                // Trigger smart calculation with effective quantity
                                const smartResult = handleSmartCalculation('quantity', effectiveQuantity, updatedConfig, lengthUnit, widthUnit, effectiveQuantity);
                                
                                // Recalculate cutting cost automatically using helper function
                                const updatedCuttingCost = calculateAutoCuttingCost(
                                  updatedConfig.length,
                                  lengthUnit,
                                  prev.cuttingCostPerMeter || null,
                                  effectiveQuantity
                                );
                                
                                return {
                                  ...updatedConfig,
                                  squareMeters: smartResult.squareMeters,
                                  cuttingCost: updatedCuttingCost
                                };
                              });
                              
                              console.log('📊 Quantity Changed:', {
                                displayValue: value,
                                effectiveQuantity: value || 1,
                                isQuantityCleared,
                                hasBeenInteracted: !isQuantityCleared,
                                mandatoryActivated: !isQuantityCleared
                              });
                            }}
                            className="w-full px-4 py-3 text-base border-2 border-blue-300 dark:border-blue-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                            min={1}
                            placeholder="تعداد"
                          />
                        </div>
                        
                        {/* Summary Card */}
                        <div className="bg-gradient-to-br from-blue-100 to-indigo-100 dark:from-blue-900/30 dark:to-indigo-900/30 rounded-lg p-4 border-2 border-blue-300 dark:border-blue-600">
                          <p className="text-xs font-semibold text-blue-800 dark:text-blue-200 mb-2">خلاصه ابعاد</p>
                          <div className="space-y-2">
                            <div className="flex justify-between items-center">
                              <span className="text-sm text-gray-600 dark:text-gray-400">طول:</span>
                              <span className="text-sm font-bold text-gray-900 dark:text-white">
                                {productConfig.length ? `${formatDisplayNumber(productConfig.length)} ${lengthUnit === 'm' ? 'm' : 'cm'}` : 'وارد نشده'}
                              </span>
                            </div>
                            <div className="flex justify-between items-center">
                              <span className="text-sm text-gray-600 dark:text-gray-400">عرض:</span>
                              <span className="text-sm font-bold text-gray-900 dark:text-white">
                                {productConfig.width ? `${formatDisplayNumber(productConfig.width)} ${widthUnit === 'm' ? 'm' : 'cm'}` : 'وارد نشده'}
                              </span>
                            </div>
                            <div className="flex justify-between items-center pt-2 border-t border-blue-300 dark:border-blue-700">
                              <span className="text-sm text-gray-600 dark:text-gray-400">تعداد:</span>
                              <span className="text-sm font-bold text-blue-900 dark:text-blue-100">
                                {productConfig.quantity || 0} عدد
                              </span>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    /* For Non-Slab: Original Layout */
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          طول
                        </label>
                        <div className="space-y-2">
                          <FormattedNumberInput
                            value={productConfig.length || 0}
                            onFocus={() => handleFieldFocus('length', productConfig.length, 0)}
                            onChange={(value) => {
                              setProductConfig(prev => {
                                const updatedConfig = { ...prev, length: value };
                                const smartResult = handleSmartCalculation('length', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                                return {
                                  ...updatedConfig,
                                  width: smartResult.width,
                                  squareMeters: smartResult.squareMeters
                                };
                              });
                            }}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                            min={0}
                            step={0.1}
                            placeholder="مقدار طول"
                          />
                          <div className="flex gap-1">
                            <button
                              type="button"
                              onClick={() => handleLengthUnitChange('cm')}
                              className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                lengthUnit === 'cm'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              سانتی‌متر (cm)
                            </button>
                            <button
                              type="button"
                              onClick={() => handleLengthUnitChange('m')}
                              className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                lengthUnit === 'm'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              متر (m)
                            </button>
                          </div>
                        </div>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          عرض
                        </label>
                        <div className="space-y-2">
                          <FormattedNumberInput
                            value={productConfig.width || 0}
                            onFocus={() => handleFieldFocus('width', productConfig.width, 0)}
                            onChange={(value) => {
                              setProductConfig(prev => {
                                const updatedConfig = { ...prev, width: value };
                                const smartResult = handleSmartCalculation('width', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                                return {
                                  ...updatedConfig,
                                  length: smartResult.length,
                                  squareMeters: smartResult.squareMeters
                                };
                              });
                            }}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                          min={0}
                          step={0.1}
                          placeholder="مقدار عرض"
                        />
                        <div className="flex gap-1">
                          <button
                            type="button"
                            onClick={() => handleWidthUnitChange('cm')}
                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                              widthUnit === 'cm'
                                ? 'bg-teal-500 text-white shadow-lg'
                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                            }`}
                          >
                            سانتی‌متر (cm)
                          </button>
                          <button
                            type="button"
                            onClick={() => handleWidthUnitChange('m')}
                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                              widthUnit === 'm'
                                ? 'bg-teal-500 text-white shadow-lg'
                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                            }`}
                          >
                            متر (m)
                          </button>
                      </div>
                    </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          تعداد
                        </label>
                        <FormattedNumberInput
                          value={getQuantityDisplayValue()}
                          onFocus={() => handleFieldFocus('quantity', getQuantityDisplayValue(), 0)}
                          onChange={(value) => {
                            const isQuantityCleared = !value || value === 0;
                            if (!hasQuantityBeenInteracted) {
                              setHasQuantityBeenInteracted(true);
                            }
                            if (isQuantityCleared) {
                              setIsMandatory(false);
                              setHasQuantityBeenInteracted(false);
                            } else {
                              setIsMandatory(true);
                            }
                            setProductConfig(prev => {
                              const updatedConfig = { ...prev, quantity: value };
                              const effectiveQuantity = value || 1;
                              const smartResult = handleSmartCalculation('quantity', effectiveQuantity, updatedConfig, lengthUnit, widthUnit, effectiveQuantity);
                              const updatedCuttingCost = calculateAutoCuttingCost(
                                updatedConfig.length,
                                lengthUnit,
                                prev.cuttingCostPerMeter || null,
                                effectiveQuantity
                              );
                              return {
                                ...updatedConfig,
                                squareMeters: smartResult.squareMeters,
                                cuttingCost: updatedCuttingCost
                              };
                            });
                          }}
                          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                          min={1}
                          placeholder="تعداد"
                        />
                      </div>
                        </div>
                      )
                    </div>
                  )}
                  
                  {/* Slab-specific sections */}
                  {productConfig.productType === 'slab' && (() => {
                      const slabCuttingMode = productConfig.slabCuttingMode || 'lineBased';
                      const requestedLengthCm = productConfig.length ? (lengthUnit === 'm' ? productConfig.length * 100 : productConfig.length) : 0;
                      const requestedWidthCm = productConfig.width ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width) : 0;
                      const wantedQuantity = productConfig.quantity || 0;
                      
                      // Get standard dimensions array or initialize empty
                      const standardDimensions = productConfig.slabStandardDimensions || [];
                      
                      // Calculate total quantity from standard dimensions
                      const totalStandardQuantity = standardDimensions.reduce((sum, entry) => sum + (entry.quantity || 0), 0);
                      
                      // Calculate total area for pricing
                      const totalStandardAreaSqm = standardDimensions.reduce((sum, entry) => {
                        return sum + ((entry.standardLengthCm * entry.standardWidthCm * entry.quantity) / 10000);
                      }, 0);
                      
                      // Validation: check if standard dimensions are >= wanted dimensions
                      const validateStandardDimensions = (entry: SlabStandardDimensionEntry): string | null => {
                        if (entry.standardLengthCm < requestedLengthCm) {
                          return `طول استاندارد (${entry.standardLengthCm}cm) نمی‌تواند کمتر از طول درخواستی (${requestedLengthCm}cm) باشد`;
                        }
                        if (entry.standardWidthCm < requestedWidthCm) {
                          return `عرض استاندارد (${entry.standardWidthCm}cm) نمی‌تواند کمتر از عرض درخواستی (${requestedWidthCm}cm) باشد`;
                        }
                        if (entry.quantity <= 0) {
                          return 'تعداد باید بیشتر از صفر باشد';
                        }
                        return null;
                      };
                      
                      // Add new standard dimension entry
                      const handleAddStandardDimension = () => {
                        const newEntry: SlabStandardDimensionEntry = {
                          id: `std_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                          standardLengthCm: requestedLengthCm || 300,
                          standardWidthCm: requestedWidthCm || 200,
                          quantity: 1
                        };
                        setProductConfig(prev => ({
                          ...prev,
                          slabStandardDimensions: [...(prev.slabStandardDimensions || []), newEntry]
                        }));
                      };
                      
                      // Update standard dimension entry
                      const handleUpdateStandardDimension = (id: string, field: keyof SlabStandardDimensionEntry, value: number) => {
                        setProductConfig(prev => {
                          const updated = (prev.slabStandardDimensions || []).map(entry => 
                            entry.id === id ? { ...entry, [field]: value } : entry
                          );
                          return { ...prev, slabStandardDimensions: updated };
                        });
                      };
                      
                      // Remove standard dimension entry
                      const handleRemoveStandardDimension = (id: string) => {
                        setProductConfig(prev => ({
                          ...prev,
                          slabStandardDimensions: (prev.slabStandardDimensions || []).filter(entry => entry.id !== id)
                        }));
                      };
                      
                      return (
                        <div className="space-y-6">
                          {/* ابعاد استاندارد Section */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-indigo-200 dark:border-indigo-800 shadow-lg overflow-hidden">
                            <div className="bg-gradient-to-r from-indigo-500 to-indigo-600 dark:from-indigo-600 dark:to-indigo-700 px-6 py-4">
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                  <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                    <FaWarehouse className="text-white text-lg" />
                                  </div>
                                  <div>
                                    <h4 className="text-lg font-bold text-white">ابعاد استاندارد موجود در انبار</h4>
                                    <p className="text-xs text-indigo-100">ابعاد سنگ‌های موجود در انبار را اضافه کنید</p>
                                  </div>
                                </div>
                                <button
                                  type="button"
                                  onClick={handleAddStandardDimension}
                                  className="flex items-center gap-2 px-4 py-2.5 text-sm font-semibold text-indigo-700 bg-white rounded-lg hover:bg-indigo-50 transition-all shadow-md hover:shadow-lg transform hover:scale-105"
                                >
                                  <FaPlus className="text-base" />
                                  افزودن ابعاد
                                </button>
                              </div>
                            </div>
                            
                            <div className="p-6">
                              {standardDimensions.length > 0 ? (
                                <div className="space-y-4">
                                  <div className="overflow-x-auto -mx-6 px-6">
                                    <table className="w-full text-sm">
                                      <thead>
                                        <tr className="bg-indigo-50 dark:bg-indigo-900/30 border-b-2 border-indigo-200 dark:border-indigo-700">
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">طول استاندارد (cm)</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">عرض استاندارد (cm)</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">تعداد</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">مساحت (m²)</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">عملیات</th>
                                        </tr>
                                      </thead>
                                      <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                                        {standardDimensions.map((entry, index) => {
                                          const validationError = validateStandardDimensions(entry);
                                          const entryAreaSqm = (entry.standardLengthCm * entry.standardWidthCm * entry.quantity) / 10000;
                                          const isValid = !validationError && entry.standardLengthCm >= requestedLengthCm && entry.standardWidthCm >= requestedWidthCm;
                                          
                                          return (
                                            <tr 
                                              key={entry.id} 
                                              className={`transition-colors hover:bg-indigo-50/50 dark:hover:bg-indigo-900/10 ${
                                                validationError 
                                                  ? 'bg-red-50 dark:bg-red-900/20' 
                                                  : isValid 
                                                    ? 'bg-green-50/30 dark:bg-green-900/10' 
                                                    : ''
                                              }`}
                                            >
                                              <td className="py-3 px-4">
                                                <div className="space-y-1">
                                                  <FormattedNumberInput
                                                    value={entry.standardLengthCm}
                                                    onChange={(value) => handleUpdateStandardDimension(entry.id, 'standardLengthCm', value || 0)}
                                                    min={requestedLengthCm}
                                                    className={`w-full px-3 py-2 text-sm border rounded-lg transition-all ${
                                                      validationError && entry.standardLengthCm < requestedLengthCm 
                                                        ? 'border-red-500 bg-red-50 dark:bg-red-900/20' 
                                                        : isValid
                                                          ? 'border-green-500 bg-green-50 dark:bg-green-900/20'
                                                          : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700'
                                                    } focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`}
                                                  />
                                                  {validationError && entry.standardLengthCm < requestedLengthCm && (
                                                    <p className="text-xs text-red-600 dark:text-red-400 flex items-center gap-1">
                                                      <FaTimes className="text-xs" />
                                                      {validationError}
                                                    </p>
                                                  )}
                                                  {isValid && entry.standardLengthCm >= requestedLengthCm && (
                                                    <p className="text-xs text-green-600 dark:text-green-400 flex items-center gap-1">
                                                      <FaCheck className="text-xs" />
                                                      مناسب
                                                    </p>
                                                  )}
                                                </div>
                                              </td>
                                              <td className="py-3 px-4">
                                                <div className="space-y-1">
                                                  <FormattedNumberInput
                                                    value={entry.standardWidthCm}
                                                    onChange={(value) => handleUpdateStandardDimension(entry.id, 'standardWidthCm', value || 0)}
                                                    min={requestedWidthCm}
                                                    className={`w-full px-3 py-2 text-sm border rounded-lg transition-all ${
                                                      validationError && entry.standardWidthCm < requestedWidthCm 
                                                        ? 'border-red-500 bg-red-50 dark:bg-red-900/20' 
                                                        : isValid
                                                          ? 'border-green-500 bg-green-50 dark:bg-green-900/20'
                                                          : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700'
                                                    } focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`}
                                                  />
                                                  {validationError && entry.standardWidthCm < requestedWidthCm && (
                                                    <p className="text-xs text-red-600 dark:text-red-400 flex items-center gap-1">
                                                      <FaTimes className="text-xs" />
                                                      {validationError}
                                                    </p>
                                                  )}
                                                  {isValid && entry.standardWidthCm >= requestedWidthCm && (
                                                    <p className="text-xs text-green-600 dark:text-green-400 flex items-center gap-1">
                                                      <FaCheck className="text-xs" />
                                                      مناسب
                                                    </p>
                                                  )}
                                                </div>
                                              </td>
                                              <td className="py-3 px-4">
                                                <FormattedNumberInput
                                                  value={entry.quantity}
                                                  onChange={(value) => handleUpdateStandardDimension(entry.id, 'quantity', value || 0)}
                                                  min={1}
                                                  className={`w-full px-3 py-2 text-sm border rounded-lg ${
                                                    validationError && entry.quantity <= 0 
                                                      ? 'border-red-500 bg-red-50 dark:bg-red-900/20' 
                                                      : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700'
                                                  } focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`}
                                                />
                                              </td>
                                              <td className="py-3 px-4">
                                                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">
                                                  {formatSquareMeters(entryAreaSqm)}
                                                </div>
                                              </td>
                                              <td className="py-3 px-4">
                                                <button
                                                  type="button"
                                                  onClick={() => handleRemoveStandardDimension(entry.id)}
                                                  className="p-2 text-red-600 dark:text-red-400 hover:text-white hover:bg-red-600 dark:hover:bg-red-700 rounded-lg transition-all"
                                                  title="حذف"
                                                >
                                                  <FaTrash className="text-base" />
                                                </button>
                                              </td>
                                            </tr>
                                          );
                                        })}
                                      </tbody>
                                    </table>
                                  </div>
                                  
                                  {/* Summary Footer */}
                                  <div className="bg-gradient-to-r from-indigo-50 to-blue-50 dark:from-indigo-900/30 dark:to-blue-900/30 rounded-lg p-4 border border-indigo-200 dark:border-indigo-700">
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-3">
                                      <div className="bg-white dark:bg-gray-800 rounded-lg p-3 border border-indigo-200 dark:border-indigo-700">
                                        <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">مجموع تعداد</p>
                                        <p className={`text-xl font-bold ${totalStandardQuantity === wantedQuantity ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                                          {totalStandardQuantity}
                                        </p>
                                        <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">از {wantedQuantity} مورد نیاز</p>
                                      </div>
                                      <div className="bg-white dark:bg-gray-800 rounded-lg p-3 border border-indigo-200 dark:border-indigo-700">
                                        <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">مجموع مساحت</p>
                                        <p className="text-xl font-bold text-indigo-600 dark:text-indigo-400">
                                          {formatSquareMeters(totalStandardAreaSqm)}
                                        </p>
                                      </div>
                                      <div className="bg-white dark:bg-gray-800 rounded-lg p-3 border border-indigo-200 dark:border-indigo-700">
                                        <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">وضعیت</p>
                                        {totalStandardQuantity === wantedQuantity ? (
                                          <div className="flex items-center gap-2">
                                            <FaCheck className="text-green-600 dark:text-green-400" />
                                            <span className="text-sm font-semibold text-green-600 dark:text-green-400">تعداد کافی است</span>
                                          </div>
                                        ) : totalStandardQuantity < wantedQuantity ? (
                                          <div className="flex items-center gap-2">
                                            <FaTimes className="text-red-600 dark:text-red-400" />
                                            <span className="text-sm font-semibold text-red-600 dark:text-red-400">
                                              {wantedQuantity - totalStandardQuantity} عدد کم است
                                            </span>
                                          </div>
                                        ) : (
                                          <div className="flex items-center gap-2">
                                            <FaTimes className="text-orange-600 dark:text-orange-400" />
                                            <span className="text-sm font-semibold text-orange-600 dark:text-orange-400">
                                              {totalStandardQuantity - wantedQuantity} عدد اضافه
                                            </span>
                                          </div>
                                        )}
                                      </div>
                                    </div>
                                  </div>
                                </div>
                              ) : (
                                <div className="text-center py-12">
                                  <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-indigo-100 dark:bg-indigo-900/30 flex items-center justify-center">
                                    <FaWarehouse className="text-2xl text-indigo-500 dark:text-indigo-400" />
                                  </div>
                                  <p className="text-gray-600 dark:text-gray-400 mb-2">هنوز ابعاد استانداردی اضافه نشده است</p>
                                  <p className="text-sm text-gray-500 dark:text-gray-500">برای شروع، دکمه "افزودن ابعاد" را کلیک کنید</p>
                                </div>
                              )}
                            </div>
                          </div>

                          {/* نوع محاسبه برش Section */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-indigo-200 dark:border-indigo-800 shadow-lg overflow-hidden">
                            <div className="bg-gradient-to-r from-purple-500 to-purple-600 dark:from-purple-600 dark:to-purple-700 px-6 py-4">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                  <FaTools className="text-white text-lg" />
                                </div>
                                <div>
                                  <h4 className="text-lg font-bold text-white">نوع محاسبه برش</h4>
                                  <p className="text-xs text-purple-100">روش محاسبه هزینه برش را انتخاب کنید</p>
                                </div>
                              </div>
                            </div>
                            
                            <div className="p-6">
                              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <button
                                  type="button"
                                  onClick={() => setProductConfig(prev => ({ ...prev, slabCuttingMode: 'perSquareMeter' }))}
                                  className={`relative p-5 rounded-xl border-2 transition-all transform hover:scale-105 ${
                                    slabCuttingMode === 'perSquareMeter'
                                      ? 'bg-gradient-to-br from-indigo-500 to-indigo-600 text-white border-indigo-600 shadow-xl'
                                      : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:border-indigo-400 dark:hover:border-indigo-500'
                                  }`}
                                >
                                  {slabCuttingMode === 'perSquareMeter' && (
                                    <div className="absolute top-3 right-3">
                                      <div className="w-6 h-6 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                        <FaCheck className="text-white text-sm" />
                                      </div>
                                    </div>
                                  )}
                                  <div className="text-center">
                                    <div className={`w-12 h-12 mx-auto mb-3 rounded-lg flex items-center justify-center ${
                                      slabCuttingMode === 'perSquareMeter' ? 'bg-white/20' : 'bg-indigo-100 dark:bg-indigo-900/30'
                                    }`}>
                                      <FaSquare className={`text-2xl ${slabCuttingMode === 'perSquareMeter' ? 'text-white' : 'text-indigo-600 dark:text-indigo-400'}`} />
                                    </div>
                                    <h5 className="font-bold text-lg mb-1">بر اساس متر مربع</h5>
                                    <p className="text-xs opacity-90">محاسبه بر اساس مساحت قطعه نهایی</p>
                                  </div>
                                </button>
                                
                                <button
                                  type="button"
                                  onClick={() => setProductConfig(prev => ({ ...prev, slabCuttingMode: 'lineBased' }))}
                                  className={`relative p-5 rounded-xl border-2 transition-all transform hover:scale-105 ${
                                    slabCuttingMode === 'lineBased'
                                      ? 'bg-gradient-to-br from-indigo-500 to-indigo-600 text-white border-indigo-600 shadow-xl'
                                      : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:border-indigo-400 dark:hover:border-indigo-500'
                                  }`}
                                >
                                  {slabCuttingMode === 'lineBased' && (
                                    <div className="absolute top-3 right-3">
                                      <div className="w-6 h-6 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                        <FaCheck className="text-white text-sm" />
                                      </div>
                                    </div>
                                  )}
                                  <div className="text-center">
                                    <div className={`w-12 h-12 mx-auto mb-3 rounded-lg flex items-center justify-center ${
                                      slabCuttingMode === 'lineBased' ? 'bg-white/20' : 'bg-indigo-100 dark:bg-indigo-900/30'
                                    }`}>
                                      <FaRuler className={`text-2xl ${slabCuttingMode === 'lineBased' ? 'text-white' : 'text-indigo-600 dark:text-indigo-400'}`} />
                                    </div>
                                    <h5 className="font-bold text-lg mb-1">بر اساس خطوط</h5>
                                    <p className="text-xs opacity-90">محاسبه بر اساس طول خطوط برش</p>
                                  </div>
                                </button>
                              </div>
                              
                              {slabCuttingMode === 'perSquareMeter' ? (
                                <div className="bg-indigo-50 dark:bg-indigo-900/20 rounded-lg p-4 border border-indigo-200 dark:border-indigo-700">
                                  <label className="block text-sm font-semibold text-indigo-900 dark:text-indigo-100 mb-2">
                                    هزینه برش هر متر مربع (تومان)
                                  </label>
                                  <FormattedNumberInput
                                    value={productConfig.slabCuttingPricePerSquareMeter || 0}
                                    onChange={(value) => setProductConfig(prev => ({ ...prev, slabCuttingPricePerSquareMeter: value || 0 }))}
                                    min={0}
                                    placeholder="مثلاً 150,000"
                                    className="w-full px-4 py-3 text-base border-2 border-indigo-300 dark:border-indigo-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                  />
                                  <p className="text-xs text-indigo-700 dark:text-indigo-300 mt-2 flex items-center gap-1">
                                    <FaSquare className="text-xs" />
                                    هزینه برش بر اساس متر مربع قطعه نهایی محاسبه می‌شود.
                                  </p>
                                </div>
                              ) : (
                                <div className="bg-indigo-50 dark:bg-indigo-900/20 rounded-lg p-4 border border-indigo-200 dark:border-indigo-700">
                                  <p className="text-sm text-indigo-800 dark:text-indigo-200 mb-3 leading-relaxed">
                                    در این حالت هزینه برش بر اساس طول خطوط طولی و عرضی محاسبه می‌شود. طول برش اصلی برابر بعدی است که به ابعاد استاندارد نزدیک‌تر باشد و برش دیگر بر اساس بعد درخواستی محاسبه می‌گردد.
                                  </p>
                                  {(() => {
                                    if (standardDimensions.length > 0 && requestedLengthCm > 0 && requestedWidthCm > 0) {
                                      const firstEntry = standardDimensions[0];
                                      const linePlanPreview = determineSlabLineCutPlan({
                                        requestedLengthCm,
                                        requestedWidthCm,
                                        standardLengthCm: firstEntry.standardLengthCm,
                                        standardWidthCm: firstEntry.standardWidthCm
                                      });
                                      return (
                                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-indigo-300 dark:border-indigo-600">
                                          <p className="font-semibold mb-3 text-indigo-900 dark:text-indigo-100 flex items-center gap-2">
                                            <FaRuler className="text-indigo-600 dark:text-indigo-400" />
                                            خلاصه محاسبه خطوط (نمونه برای اولین ابعاد استاندارد)
                                          </p>
                                          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3">
                                              <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">برش اصلی</p>
                                              <p className="font-bold text-indigo-700 dark:text-indigo-300">
                                                {linePlanPreview.axisUsingStandard === 'length' ? 'طول' : 'عرض'}
                                              </p>
                                            </div>
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3">
                                              <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">خطوط طولی</p>
                                              <p className="font-bold text-indigo-700 dark:text-indigo-300">
                                                {formatDisplayNumber(linePlanPreview.longitudinalMeters)} m
                                              </p>
                                            </div>
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3">
                                              <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">خطوط عرضی</p>
                                              <p className="font-bold text-indigo-700 dark:text-indigo-300">
                                                {formatDisplayNumber(linePlanPreview.crossMeters)} m
                                              </p>
                                            </div>
                                          </div>
                                          {standardDimensions.length > 1 && (
                                            <div className="mt-3 pt-3 border-t border-indigo-200 dark:border-indigo-700">
                                              <p className="text-xs text-indigo-600 dark:text-indigo-400 flex items-center gap-1">
                                                <FaTimes className="text-xs" />
                                                توجه: محاسبه برای هر ابعاد استاندارد به صورت جداگانه انجام می‌شود.
                                              </p>
                                            </div>
                                          )}
                                        </div>
                                      );
                                    }
                                    return null;
                                  })()}
                                </div>
                              )}
                            </div>
                          </div>

                          {/* برش قائم Section - 4 Side Edge Cuts */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-teal-200 dark:border-teal-800 shadow-lg overflow-hidden">
                            <div className="bg-gradient-to-r from-teal-500 to-teal-600 dark:from-teal-600 dark:to-teal-700 px-6 py-4">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                  <FaRuler className="text-white text-lg" />
                                </div>
                                <div>
                                  <h4 className="text-lg font-bold text-white">برش قائم (پرداخت لبه‌ها)</h4>
                                  <p className="text-xs text-teal-100">انتخاب لبه‌هایی که نیاز به برش قائم دارند</p>
                                </div>
                              </div>
                            </div>
                            
                            <div className="p-6">
                              <p className="text-sm text-gray-700 dark:text-gray-300 mb-4 leading-relaxed">
                                هر سنگ استاندارد اسلب نیاز به برش قائم روی لبه‌ها دارد تا تمام لبه‌ها صاف و دقیق شوند و آماده برای برش‌های اصلی باشند.
                              </p>
                              
                              {/* Visual representation of slab with 4 sides */}
                              <div className="bg-gradient-to-br from-teal-50 to-cyan-50 dark:from-teal-900/20 dark:to-cyan-900/20 rounded-xl p-6 border-2 border-teal-200 dark:border-teal-700 mb-4">
                                <div className="relative mx-auto" style={{ width: '200px', height: '150px' }}>
                                  {/* Slab representation */}
                                  <div className="absolute inset-0 bg-white dark:bg-gray-700 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-md"></div>
                                  
                                  {/* Top side checkbox */}
                                  <div className="absolute -top-3 left-1/2 transform -translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.top !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: e.target.checked,
                                            bottom: prev.slabVerticalCutSides?.bottom !== false,
                                            left: prev.slabVerticalCutSides?.left !== false,
                                            right: prev.slabVerticalCutSides?.right !== false
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">بالا</span>
                                    </label>
                                  </div>
                                  
                                  {/* Bottom side checkbox */}
                                  <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.bottom !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: prev.slabVerticalCutSides?.top !== false,
                                            bottom: e.target.checked,
                                            left: prev.slabVerticalCutSides?.left !== false,
                                            right: prev.slabVerticalCutSides?.right !== false
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">پایین</span>
                                    </label>
                                  </div>
                                  
                                  {/* Left side checkbox */}
                                  <div className="absolute left-0 top-1/2 transform -translate-y-1/2 -translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.left !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: prev.slabVerticalCutSides?.top !== false,
                                            bottom: prev.slabVerticalCutSides?.bottom !== false,
                                            left: e.target.checked,
                                            right: prev.slabVerticalCutSides?.right !== false
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">چپ</span>
                                    </label>
                                  </div>
                                  
                                  {/* Right side checkbox */}
                                  <div className="absolute right-0 top-1/2 transform -translate-y-1/2 translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.right !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: prev.slabVerticalCutSides?.top !== false,
                                            bottom: prev.slabVerticalCutSides?.bottom !== false,
                                            left: prev.slabVerticalCutSides?.left !== false,
                                            right: e.target.checked
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">راست</span>
                                    </label>
                                  </div>
                                </div>
                              </div>
                              
                              {/* Cost preview */}
                              {(() => {
                                const verticalCutSides = productConfig.slabVerticalCutSides || { top: true, bottom: true, left: true, right: true };
                                const activeSides = Object.values(verticalCutSides).filter(Boolean).length;
                                const hasActiveSides = activeSides > 0;
                                const verticalCutCostPerMeter = getCuttingTypePricePerMeter('VERTICAL') || getCuttingTypePricePerMeter('LONG') || 0;
                                
                                // Calculate برش قائم for each standard dimension entry
                                let totalMeters = 0;
                                let totalEstimatedCost = 0;
                                
                                if (hasActiveSides && verticalCutCostPerMeter > 0 && standardDimensions.length > 0) {
                                  // Loop through each standard dimension entry
                                  for (const entry of standardDimensions) {
                                    // Calculate perimeter for this entry based on standard dimensions
                                    let entryMeters = 0;
                                    if (verticalCutSides.top) entryMeters += entry.standardWidthCm / 100; // width in meters
                                    if (verticalCutSides.bottom) entryMeters += entry.standardWidthCm / 100;
                                    if (verticalCutSides.left) entryMeters += entry.standardLengthCm / 100; // length in meters
                                    if (verticalCutSides.right) entryMeters += entry.standardLengthCm / 100;
                                    
                                    // Multiply by quantity for this entry
                                    const entryTotalMeters = entryMeters * entry.quantity;
                                    totalMeters += entryTotalMeters;
                                    
                                    // Calculate cost for this entry
                                    const entryCost = entryTotalMeters * verticalCutCostPerMeter;
                                    totalEstimatedCost += entryCost;
                                  }
                                }
                                
                                if (hasActiveSides && totalMeters > 0 && verticalCutCostPerMeter > 0) {
                                  return (
                                    <div className="bg-teal-50 dark:bg-teal-900/20 rounded-lg p-4 border border-teal-200 dark:border-teal-700">
                                      <div className="flex items-center justify-between mb-2">
                                        <p className="text-sm font-semibold text-teal-900 dark:text-teal-100">
                                          هزینه برش قائم (پیش‌نمایش)
                                        </p>
                                        <span className="text-xs text-teal-700 dark:text-teal-300">
                                          {activeSides} لبه فعال
                                        </span>
                                      </div>
                                      <div className="grid grid-cols-2 gap-3 text-sm">
                                        <div>
                                          <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">مجموع طول لبه‌ها</p>
                                          <p className="font-bold text-teal-700 dark:text-teal-300">
                                            {formatDisplayNumber(totalMeters)} متر
                                          </p>
                                        </div>
                                        <div>
                                          <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">هزینه کل</p>
                                          <p className="font-bold text-teal-700 dark:text-teal-300">
                                            {formatPrice(totalEstimatedCost, 'تومان')}
                                          </p>
                                        </div>
                                      </div>
                                      {standardDimensions.length > 1 && (
                                        <div className="mt-3 pt-3 border-t border-teal-200 dark:border-teal-700">
                                          <p className="text-xs text-teal-600 dark:text-teal-400 flex items-center gap-1">
                                            <FaTimes className="text-xs" />
                                            محاسبه برای هر ابعاد استاندارد به صورت جداگانه انجام می‌شود.
                                          </p>
                                        </div>
                                      )}
                        </div>
                      );
                                }
                                return null;
                              })()}
                            </div>
                          </div>

                          {/* CAD Designer Section */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-indigo-200 dark:border-indigo-800 shadow-lg overflow-hidden mt-6">
                            <div className="bg-gradient-to-r from-indigo-500 to-indigo-600 dark:from-indigo-600 dark:to-indigo-700 px-6 py-4">
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                  <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                    <FaRuler className="text-white text-lg" />
                                  </div>
                                  <div>
                                    <h4 className="text-lg font-bold text-white">ابزار طراحی CAD</h4>
                                    <p className="text-xs text-indigo-100">طراحی و برنامه‌ریزی برش‌ها به صورت بصری</p>
                                  </div>
                                </div>
                                <button
                                  type="button"
                                  onClick={() => setShowCADDesigner(!showCADDesigner)}
                                  className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg transition-colors text-sm font-medium"
                                >
                                  {showCADDesigner ? 'مخفی کردن' : 'نمایش'}
                                </button>
                              </div>
                            </div>
                            
                            {showCADDesigner && (
                              <div className="p-6">
                                <p className="text-sm text-gray-700 dark:text-gray-300 mb-4 leading-relaxed">
                                  از این ابزار برای طراحی و برنامه‌ریزی برش‌ها روی سنگ‌های استاندارد استفاده کنید. می‌توانید ابعاد مورد نظر را رسم کنید و هزینه‌ها به صورت خودکار محاسبه می‌شوند.
                                </p>
                                
                                {standardDimensions && standardDimensions.length > 0 ? (
                                  <StoneCADDesigner
                                    originalLength={productConfig.length || 0}
                                    originalWidth={productConfig.width || 0}
                                    lengthUnit={lengthUnit}
                                    widthUnit={widthUnit}
                                    standardDimensions={standardDimensions}
                                    productType="slab"
                                    mode="design"
                                    enableCostCalculation={true}
                                    enableAutoSync={true}
                                    onDimensionsCalculated={(dims) => {
                                      // Sync CAD dimensions with product config
                                      if (dims.length && dims.width) {
                                        setProductConfig(prev => ({
                                          ...prev,
                                          length: dims.length,
                                          width: dims.width,
                                          squareMeters: dims.squareMeters
                                        }));
                                      }
                                    }}
                                    onCostCalculated={(cost) => {
                                      // Update cutting cost in product config
                                      setProductConfig(prev => ({
                                        ...prev,
                                        cuttingCost: cost
                                      }));
                                    }}
                                    onDesignChange={(design) => {
                                      // Store CAD design for later use
                                      setProductConfig(prev => ({
                                        ...prev,
                                        cadDesign: design
                                      }));
                                    }}
                                    initialDesign={productConfig.cadDesign || null}
                                  />
                                ) : (
                                  <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
                                    <p className="text-sm text-yellow-800 dark:text-yellow-200">
                                      لطفاً ابتدا ابعاد استاندارد را اضافه کنید تا بتوانید از ابزار طراحی استفاده کنید.
                                    </p>
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })()}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        تعداد
                      </label>
                      <FormattedNumberInput
                        value={getQuantityDisplayValue()}
                        onFocus={() => handleFieldFocus('quantity', getQuantityDisplayValue(), 0)}
                        onChange={(value) => {
                          // Check if quantity is being cleared/deleted (empty or 0)
                          const isQuantityCleared = !value || value === 0;
                          
                          // Mark quantity as interacted
                          if (!hasQuantityBeenInteracted) {
                            setHasQuantityBeenInteracted(true);
                            console.log('🎯 Quantity First Interaction');
                          }
                          
                          // Handle mandatory pricing based on quantity state
                          if (isQuantityCleared) {
                            // If quantity is cleared, uncheck mandatory pricing and reset interaction state
                            setIsMandatory(false);
                            setHasQuantityBeenInteracted(false);
                            console.log('🔄 Quantity Cleared - Deactivating mandatory pricing and resetting interaction state');
                          } else {
                            // If quantity has a value, activate mandatory pricing
                            setIsMandatory(true);
                            console.log('✅ Quantity Has Value - Activating mandatory pricing');
                          }
                          
                          // Update the quantity
                          setProductConfig(prev => {
                            const updatedConfig = { ...prev, quantity: value };
                            // Use effective quantity for calculations
                            const effectiveQuantity = value || 1;
                            // Trigger smart calculation with effective quantity
                            const smartResult = handleSmartCalculation('quantity', effectiveQuantity, updatedConfig, lengthUnit, widthUnit, effectiveQuantity);
                            
                            // Recalculate cutting cost automatically using helper function
                            const updatedCuttingCost = calculateAutoCuttingCost(
                              updatedConfig.length,
                              lengthUnit,
                              prev.cuttingCostPerMeter || null,
                              effectiveQuantity
                            );
                            
                            return {
                              ...updatedConfig,
                              squareMeters: smartResult.squareMeters,
                              cuttingCost: updatedCuttingCost
                            };
                          });
                          
                          console.log('📊 Quantity Changed:', {
                            displayValue: value,
                            effectiveQuantity: value || 1,
                            isQuantityCleared,
                            hasBeenInteracted: !isQuantityCleared,
                            mandatoryActivated: !isQuantityCleared
                          });
                        }}
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                        min={1}
                        placeholder="تعداد"
                      />
                    </div>
                  </>)}

                  {/* Unit Selection Help Text - Only for slab/longitudinal */}
                  {(productConfig.productType === 'longitudinal' || productConfig.productType === 'slab') && (
                    <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                      <p className="text-sm text-blue-700 dark:text-blue-300">
                        <strong>راهنمای انتخاب واحد:</strong> برای هر فیلد طول و عرض، روی دکمه‌های "سانتی‌متر" یا "متر" کلیک کنید تا واحد مورد نظر را انتخاب کنید. 
                        دکمه انتخاب شده با رنگ آبی نمایش داده می‌شود. سیستم به طور خودکار محاسبات را انجام می‌دهد.
                      </p>
                    </div>
                  )}

                  {/* Slab 2D Cutting Info Cards */}
                  {productConfig.productType === 'slab' && selectedProduct && (() => {
                    const { standardLengthCm, standardWidthCm } = getSlabStandardDimensions();
                    const originalWidth = standardWidthCm || selectedProduct.widthValue || 0;
                    const originalLengthCm = standardLengthCm || (selectedProduct as any)?.lengthValue || 300;
                    
                    const userWidthInCm = productConfig.width 
                      ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width)
                      : 0;
                    const userLengthInCm = productConfig.length 
                      ? (lengthUnit === 'm' ? productConfig.length * 100 : productConfig.length)
                      : 0;
                    const needsLongitudinalCut = userWidthInCm > 0 && userWidthInCm < originalWidth && originalWidth > 0;
                    const needsCrossCut = userLengthInCm > 0 && userLengthInCm < originalLengthCm && originalLengthCm > 0;
                    const hasCuts = needsLongitudinalCut || needsCrossCut;
                    const slabCuttingMode = productConfig.slabCuttingMode || 'lineBased';
                    const effectiveQuantity = getEffectiveQuantity();
                    const linePlan = determineSlabLineCutPlan({
                      requestedLengthCm: userLengthInCm,
                      requestedWidthCm: userWidthInCm,
                      standardLengthCm,
                      standardWidthCm
                    });
                    
                    const requestedAreaSqm = productConfig.squareMeters && productConfig.squareMeters > 0
                      ? productConfig.squareMeters
                      : (userLengthInCm > 0 && userWidthInCm > 0
                          ? (userLengthInCm * userWidthInCm * effectiveQuantity) / 10000
                          : 0);
                    
                    const cuttingCostPerMeterLongitudinal = needsLongitudinalCut ? (getCuttingTypePricePerMeter('LONG') || 0) : 0;
                    const cuttingCostPerMeterCross = needsCrossCut ? (getCuttingTypePricePerMeter('CROSS') || getCuttingTypePricePerMeter('LONG') || 0) : 0;
                    
                    const longitudinalCuttingCost = needsLongitudinalCut && slabCuttingMode === 'lineBased' && cuttingCostPerMeterLongitudinal > 0
                      ? linePlan.longitudinalMeters * cuttingCostPerMeterLongitudinal * effectiveQuantity
                      : 0;
                    const crossCuttingCost = needsCrossCut && slabCuttingMode === 'lineBased' && cuttingCostPerMeterCross > 0
                      ? linePlan.crossMeters * cuttingCostPerMeterCross * effectiveQuantity
                      : 0;
                    const totalCuttingCost = slabCuttingMode === 'lineBased' ? (longitudinalCuttingCost + crossCuttingCost) : 0;
                    
                    const remainingWidth = originalWidth - userWidthInCm;
                    const remainingLength = originalLengthCm - userLengthInCm;
                    const remainingPiecesCount = (remainingWidth > 0 ? 1 : 0) + (remainingLength > 0 ? 1 : 0) + (remainingWidth > 0 && remainingLength > 0 ? 1 : 0);
                    const showLineCard = slabCuttingMode === 'lineBased' && hasCuts && productConfig.length && productConfig.width;
                    
                    if (!showLineCard && slabCuttingMode === 'lineBased' && !requestedAreaSqm) {
                      return null;
                    }
                    
                    return (
                      <div className="space-y-3">
                        {slabCuttingMode === 'perSquareMeter' ? (
                          <div className="bg-indigo-50 dark:bg-indigo-900/20 border border-indigo-200 dark:border-indigo-800 rounded-lg p-4">
                            <div className="flex items-center gap-2 mb-2">
                              <div className="w-2 h-2 rounded-full bg-indigo-500"></div>
                              <h5 className="text-sm font-semibold text-indigo-800 dark:text-indigo-200">
                                برش بر اساس متر مربع
                              </h5>
                            </div>
                            <p className="text-xs text-indigo-700 dark:text-indigo-300">
                              {requestedAreaSqm > 0
                                ? `مساحت درخواستی: ${formatSquareMeters(requestedAreaSqm)}`
                                : 'برای محاسبه دقیق، طول و عرض درخواستی را وارد کنید.'}
                            </p>
                            {productConfig.slabCuttingPricePerSquareMeter ? (
                              <p className="text-xs text-indigo-700 dark:text-indigo-300 mt-1">
                                هزینه برش: {formatPrice(productConfig.slabCuttingPricePerSquareMeter)} × {formatSquareMeters(requestedAreaSqm || 0)}
                              </p>
                            ) : (
                              <p className="text-xs text-indigo-500 dark:text-indigo-200 mt-1">
                                لطفاً هزینه برش هر متر مربع را وارد کنید.
                              </p>
                            )}
                          </div>
                        ) : showLineCard ? (
                        <div className="bg-indigo-50 dark:bg-indigo-900/20 border border-indigo-200 dark:border-indigo-800 rounded-lg p-4">
                          <div className="flex items-center gap-2 mb-2">
                            <div className="w-2 h-2 rounded-full bg-indigo-500"></div>
                            <h5 className="text-sm font-semibold text-indigo-800 dark:text-indigo-200">
                              اطلاعات برش دو بعدی
                            </h5>
                          </div>
                          <div className="space-y-2 text-xs text-indigo-700 dark:text-indigo-300">
                            {needsLongitudinalCut && (
                              <div>
                                <span className="font-medium">برش طولی:</span> عرض {formatDisplayNumber(originalWidth)}cm → {formatDisplayNumber(userWidthInCm)}cm
                                {cuttingCostPerMeterLongitudinal > 0 && (
                                  <span className="ml-2">
                                      ({formatDisplayNumber(linePlan.longitudinalMeters)} m × {formatPrice(cuttingCostPerMeterLongitudinal)} = {formatPrice(longitudinalCuttingCost)})
                                  </span>
                                )}
                              </div>
                            )}
                            {needsCrossCut && (
                              <div>
                                <span className="font-medium">{needsLongitudinalCut ? 'برش عرضی' : 'برش کله بر'}:</span> طول {formatDisplayNumber(originalLengthCm)}cm → {formatDisplayNumber(userLengthInCm)}cm
                                {cuttingCostPerMeterCross > 0 && (
                                  <span className="ml-2">
                                      ({formatDisplayNumber(linePlan.crossMeters)} m × {formatPrice(cuttingCostPerMeterCross)} = {formatPrice(crossCuttingCost)})
                                  </span>
                                )}
                              </div>
                            )}
                            {totalCuttingCost > 0 && (
                              <div className="mt-2 pt-2 border-t border-indigo-200 dark:border-indigo-700">
                                <span className="font-semibold">هزینه کل برش: {formatPrice(totalCuttingCost)}</span>
                              </div>
                            )}
                          </div>
                        </div>
                        ) : null}
                        
                        {hasCuts && productConfig.length && productConfig.width && remainingPiecesCount > 0 && (
                          <div className="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
                            <div className="flex items-center gap-2 mb-2">
                              <div className="w-2 h-2 rounded-full bg-amber-500"></div>
                              <h5 className="text-sm font-semibold text-amber-800 dark:text-amber-200">
                                باقیمانده‌های اسلب ({remainingPiecesCount} قطعه)
                              </h5>
                            </div>
                            <div className="space-y-1 text-xs text-amber-700 dark:text-amber-300">
                              {remainingWidth > 0 && userLengthInCm > 0 && (
                                <div>
                                  • قطعه عرضی: {formatDisplayNumber(remainingWidth)}cm × {formatDisplayNumber(userLengthInCm)}cm
                                  <span className="text-amber-600 dark:text-amber-400 ml-1">
                                    ({formatSquareMeters((remainingWidth * userLengthInCm * effectiveQuantity) / 10000)})
                                  </span>
                                </div>
                              )}
                              {remainingLength > 0 && userWidthInCm > 0 && (
                                <div>
                                  • قطعه طولی: {formatDisplayNumber(userWidthInCm)}cm × {formatDisplayNumber(remainingLength)}cm
                                  <span className="text-amber-600 dark:text-amber-400 ml-1">
                                    ({formatSquareMeters((userWidthInCm * remainingLength * effectiveQuantity) / 10000)})
                                  </span>
                                </div>
                              )}
                              {remainingWidth > 0 && remainingLength > 0 && (
                                <div>
                                  • قطعه گوشه: {formatDisplayNumber(remainingWidth)}cm × {formatDisplayNumber(remainingLength)}cm
                                  <span className="text-amber-600 dark:text-amber-400 ml-1">
                                    ({formatSquareMeters((remainingWidth * remainingLength * effectiveQuantity) / 10000)})
                                  </span>
                                </div>
                              )}
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })()}

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        فی هر متر مربع (تومان)
                      </label>
                      <FormattedNumberInput
                        value={productConfig.pricePerSquareMeter || 0}
                        onFocus={() => handleFieldFocus('pricePerSquareMeter', productConfig.pricePerSquareMeter, 0)}
                        onChange={(value) => setProductConfig(prev => ({ ...prev, pricePerSquareMeter: value }))}
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                        min={0}
                        step={1000}
                        placeholder="فی هر متر مربع (تومان)"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        متر مربع
                      </label>
                      <FormattedNumberInput
                        key={`square-meters-${lengthUnit}-${widthUnit}`}
                        value={(() => {
                          console.log('🎯 متر مربع Field Value:', {
                            productConfigSquareMeters: productConfig.squareMeters,
                            lengthUnit,
                            widthUnit,
                            finalValue: productConfig.squareMeters || 0
                          });
                          return productConfig.squareMeters || 0;
                        })()}
                        onFocus={() => handleFieldFocus('squareMeters', productConfig.squareMeters, 0)}
                        onChange={(value) => {
                          // Update the square meters first
                          setProductConfig(prev => {
                            // Get original width for calculations
                            const originalWidth = (isEditMode && prev.originalWidth) ? prev.originalWidth : (selectedProduct?.widthValue || 0);
                            
                            // Check if user entered ONLY squareMeters (no length, no width)
                            const hasNoLength = !prev.length || prev.length === 0;
                            const hasNoWidth = !prev.width || prev.width === 0;
                            const onlySquareMetersEntered = hasNoLength && hasNoWidth && value > 0;
                            
                            let updatedConfig = { ...prev, squareMeters: value };
                            
                            // If only squareMeters is entered, automatically set width to original width
                            if (onlySquareMetersEntered && originalWidth > 0) {
                              // Convert original width to the selected width unit
                              const originalWidthInSelectedUnit = widthUnit === 'cm' 
                                ? originalWidth 
                                : (originalWidth / 100);
                              
                              // Set width to original width
                              updatedConfig = {
                                ...updatedConfig,
                                width: originalWidthInSelectedUnit
                              };
                              
                              console.log('🎯 Auto-setting width to original width:', {
                                originalWidth,
                                widthUnit,
                                originalWidthInSelectedUnit,
                                squareMeters: value
                              });
                            }
                            
                            // Trigger smart calculation with updated config
                            const smartResult = handleSmartCalculation('squareMeters', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                            const finalConfig = {
                              ...updatedConfig,
                              length: smartResult.length,
                              width: smartResult.width || updatedConfig.width // Preserve auto-set width if smart calculation doesn't return width
                            };
                            
                            // Check if we need to auto-select longitudinal cut after smart calculation
                            const userWidthInCm = widthUnit === 'm' ? (finalConfig.width || 0) * 100 : (finalConfig.width || 0);
                            
                            // Validate: calculated width cannot exceed original width
                            if (finalConfig.width > 0 && originalWidth > 0 && userWidthInCm > originalWidth) {
                              // Show error message
                              setErrors({ 
                                products: `عرض محاسبه شده (${finalConfig.width.toFixed(2)}${widthUnit === 'm' ? 'm' : 'cm'}) بیشتر از عرض اصلی سنگ (${originalWidth}cm) است. لطفاً متر مربع را تغییر دهید تا عرض کمتر یا مساوی با ${originalWidth}cm باشد.` 
                              });
                            } else {
                              // Clear error if calculated width is valid
                              if (errors.products && errors.products.includes('عرض محاسبه شده')) {
                                setErrors({});
                              }
                            }
                            
                            const shouldAutoSelectLongitudinalCut = userWidthInCm < originalWidth;
                            
                            console.log('📏 Square Meters Changed - Auto Cut Selection:', {
                              userSquareMeters: value,
                              calculatedWidth: finalConfig.width,
                              userWidthInCm,
                              originalWidth,
                              shouldAutoSelectLongitudinalCut,
                              comparison: `${userWidthInCm} < ${originalWidth} = ${userWidthInCm < originalWidth}`
                            });
                            
                            // Auto-select cut type based on calculated width
                            if (shouldAutoSelectLongitudinalCut) {
                              return {
                                ...finalConfig,
                                isCut: true,
                                cutType: 'longitudinal'
                              };
                            } else {
                              return {
                                ...finalConfig,
                                isCut: false,
                                cutType: null
                              };
                            }
                          });
                        }}
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                        min={0}
                        step={0.01}
                        placeholder="محاسبه شده یا وارد کنید"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      توضیحات
                    </label>
                    <textarea
                      value={productConfig.description || ''}
                      onFocus={() => handleFieldFocus('description', productConfig.description, '')}
                      onChange={(e) => setProductConfig(prev => ({ ...prev, description: e.target.value }))}
                      rows={3}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                      placeholder="توضیحات اضافی..."
                    />
                  </div>
                  {/* Mandatory Pricing Section - Only for longitudinal stones, not for slab */}
                  {productConfig.productType !== 'slab' && (
                  <div className="border-t border-gray-200 dark:border-gray-600 pt-4">
                    <div className="flex items-center space-x-3 space-x-reverse mb-4">
                      <input
                        type="checkbox"
                        id="isMandatory"
                        checked={isMandatory}
                        onChange={(e) => setIsMandatory(e.target.checked)}
                        className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                      />
                      <div className="flex flex-col">
                        <label htmlFor="isMandatory" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                          حکمی (افزایش قیمت)
                        </label>
                        {hasQuantityBeenInteracted && (
                          <span className="text-xs text-blue-600 dark:text-blue-400 mt-1">
                            {isMandatory ? '✅ فعال شده توسط تعداد' : '❌ غیرفعال شده توسط تعداد'}
                          </span>
                        )}
                      </div>
                    </div>
                    
                    {isMandatory && (
                      <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
                        <div className="flex items-center space-x-3 space-x-reverse">
                          <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                            درصد افزایش:
                          </label>
                          <FormattedNumberInput
                            value={mandatoryPercentage}
                            onChange={(value) => setMandatoryPercentage(value)}
                            className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                            min={0}
                            max={100}
                          />
                          <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                        </div>
                        <p className="text-xs text-yellow-700 dark:text-yellow-300 mt-2">
                          قیمت نهایی با {mandatoryPercentage}% افزایش محاسبه خواهد شد
                        </p>
                        
                        {/* Price Preview */}
                        {(() => {
                          console.log('🔍 Price Preview Calculation:', {
                            productConfigWidth: productConfig.width,
                            length: productConfig.length,
                            quantity: productConfig.quantity,
                            pricePerSquareMeter: productConfig.pricePerSquareMeter
                          });
                          
                          // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
                          const originalWidthForCalculation = (isEditMode && productConfig.originalWidth) 
                            ? productConfig.originalWidth 
                            : (selectedProduct?.widthValue || 0);
                          
                          const calculated = calculateStoneMetrics({
                            length: productConfig.length,
                            width: productConfig.width,
                            quantity: productConfig.quantity,
                            squareMeters: productConfig.squareMeters,
                            pricePerSquareMeter: productConfig.pricePerSquareMeter,
                            lengthUnit: lengthUnit,
                            widthUnit: widthUnit,
                            isMandatory: isMandatory,
                            mandatoryPercentage: mandatoryPercentage,
                            isCut: productConfig.isCut || false,
                            originalWidth: originalWidthForCalculation,
                            cuttingCostPerMeter: productConfig.cuttingCostPerMeter || 0
                          });
                          
                          console.log('🔍 Price Preview Result:', {
                            originalTotalPrice: calculated.originalTotalPrice,
                            totalPrice: calculated.totalPrice,
                            squareMeters: calculated.squareMeters
                          });
                          
                          if (calculated.originalTotalPrice > 0) {
                            return (
                              <div className="mt-3 p-2 bg-white dark:bg-gray-800 rounded border border-yellow-300 dark:border-yellow-600">
                                <div className="text-xs text-gray-600 dark:text-gray-400">
                                  قیمت اصلی: {formatPrice(calculated.originalTotalPrice, 'تومان')}
                                </div>
                                <div className="text-sm font-medium text-yellow-800 dark:text-yellow-200">
                                  قیمت نهایی: {formatPrice(calculated.totalPrice, 'تومان')}
                                </div>
                              </div>
                            );
                          }
                          return null;
                        })()}
                      </div>
                    )}
                </div>
              )}
            </div>

                {/* Action Buttons */}
                <div className="flex justify-end gap-3 mt-6">
                  <button
                    onClick={() => {
                      // Validate before closing if it's a stair system
                      if (productConfig.productType === 'stair' && stairSystemConfig) {
                        const hasSelectedPart = stairSystemConfig.tread.isSelected || 
                                                stairSystemConfig.riser.isSelected || 
                                                stairSystemConfig.landing.isSelected;
                        
                        if (!hasSelectedPart) {
                          setErrors({ products: 'لطفاً حداقل یکی از بخش‌های پله (کف پله، خیز پله، یا پاگرد) را انتخاب کنید' });
                          return;
                        }
                      }
                      
                      setShowProductModal(false);
                      setSelectedProduct(null);
                      setProductConfig({});
                      setLengthUnit('m');
                      setWidthUnit('cm');
                      setIsMandatory(false);
                      setMandatoryPercentage(20);
                      setIsEditMode(false);
                      setEditingProductIndex(null);
                      setTouchedFields(new Set()); // Reset touched fields
                      setStairSystemConfig(null);
                      setErrors({});
                    }}
                    className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                  >
                    انصراف
                  </button>
                  <button
                    onClick={() => {
                      console.log('🔘 Main Product Button clicked!');
                      handleAddProductToContract();
                    }}
                    className="px-6 py-2 bg-gradient-to-r from-teal-500 to-teal-600 hover:from-teal-600 hover:to-teal-700 text-white rounded-lg transition-all duration-200 font-medium"
                  >
                    {isEditMode ? 'ذخیره تغییرات' : 'افزودن به قرارداد'}
                  </button>
                </div>
              </div>
            </div>
            </div>
        )}
        {/* Remaining Stone Configuration Modal */}
        {showRemainingStoneModal && selectedRemainingStone && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
              <div className="p-6">
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-white">
                    ایجاد محصول از سنگ باقی‌مانده
                  </h3>
                  <button
                    onClick={() => {
                      setShowRemainingStoneModal(false);
                      setSelectedRemainingStone(null);
                      setRemainingStoneConfig({});
                      setPartitions([{
                        id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        width: 0,
                        length: 0,
                        squareMeters: 0
                      }]);
                      setRemainingStoneLengthUnit('cm');
                      setRemainingStoneWidthUnit('cm');
                      setPartitionLengthUnit('m');
                      setPartitionWidthUnit('cm');
                      setRemainingStoneIsMandatory(false);
                      setRemainingStoneMandatoryPercentage(20);
                    }}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                  >
                    <FaTimes className="w-6 h-6" />
                  </button>
                </div>

                {/* Error Display */}
                {errors.products && (
                  <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
                    <p className="text-red-600 dark:text-red-400 text-sm">{errors.products}</p>
                  </div>
                )}

                {/* Remaining Stone Info */}
                <div className="mb-6 p-4 bg-orange-50 dark:bg-orange-900/20 rounded-lg border border-orange-200 dark:border-orange-800">
                  <div className="flex items-center justify-between mb-2">
                    <h4 className="font-medium text-orange-800 dark:text-orange-200">
                      سنگ باقی‌مانده
                    </h4>
                    <span className="px-2 py-1 bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-200 text-xs rounded-full">
                      عرض: {formatDisplayNumber(selectedRemainingStone.width)}cm
                    </span>
                  </div>
                  <div className="grid grid-cols-3 gap-4 text-sm">
                    <div>
                      <span className="text-orange-600 dark:text-orange-400">عرض باقی‌مانده:</span>
                      <span className="font-medium text-orange-800 dark:text-orange-200 mr-2">{formatDisplayNumber(selectedRemainingStone.width)}cm</span>
                    </div>
                    <div>
                      <span className="text-orange-600 dark:text-orange-400">طول باقی‌مانده:</span>
                      <span className="font-medium text-orange-800 dark:text-orange-200 mr-2">{formatDisplayNumber(selectedRemainingStone.length * 100)}cm</span>
                    </div>
                    <div>
                      <span className="text-orange-600 dark:text-orange-400">متر مربع:</span>
                      <span className="font-medium text-orange-800 dark:text-orange-200 mr-2">{formatDisplayNumber(selectedRemainingStone.squareMeters)}</span>
                    </div>
                  </div>
                </div>

                {/* Partitions Table */}
                <div className="mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <h4 className="text-lg font-semibold text-gray-800 dark:text-white">
                      پارتیشن‌ها
                    </h4>
                    <button
                      onClick={handleAddPartition}
                      className="px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg transition-colors flex items-center gap-2 text-sm"
                    >
                      <FaPlus className="w-4 h-4" />
                      افزودن ردیف
                    </button>
                  </div>

                  {/* Unit Selectors */}
                  <div className="mb-4 flex gap-4">
                    <div className="flex-1">
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        واحد عرض
                      </label>
                      <div className="flex gap-1">
                        <button
                          type="button"
                          onClick={() => setPartitionWidthUnit('cm')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            partitionWidthUnit === 'cm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          سانتی‌متر (cm)
                        </button>
                        <button
                          type="button"
                          onClick={() => setPartitionWidthUnit('m')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            partitionWidthUnit === 'm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          متر (m)
                        </button>
                      </div>
                    </div>
                    <div className="flex-1">
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        واحد طول
                      </label>
                      <div className="flex gap-1">
                        <button
                          type="button"
                          onClick={() => setPartitionLengthUnit('cm')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            partitionLengthUnit === 'cm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          سانتی‌متر (cm)
                        </button>
                        <button
                          type="button"
                          onClick={() => setPartitionLengthUnit('m')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            partitionLengthUnit === 'm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          متر (m)
                        </button>
                      </div>
                    </div>
                  </div>

                  {/* Partitions Table */}
                  <div className="overflow-x-auto border border-gray-200 dark:border-gray-700 rounded-lg">
                    <table className="w-full">
                      <thead className="bg-gray-50 dark:bg-gray-700">
                        <tr>
                          <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                            عرض ({partitionWidthUnit === 'm' ? 'm' : 'cm'})
                          </th>
                          <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                            طول ({partitionLengthUnit === 'm' ? 'm' : 'cm'})
                          </th>
                          <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                            متر مربع (محاسبه شده)
                          </th>
                          <th className="px-4 py-3 text-center text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600 w-20">
                            عملیات
                          </th>
                        </tr>
                      </thead>
                      <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                        {partitions.map((partition, index) => {
                          const widthInCm = partitionWidthUnit === 'm' ? partition.width * 100 : partition.width;
                          const lengthInCm = partitionLengthUnit === 'm' ? partition.length * 100 : partition.length;
                          const isValidWidth = widthInCm <= selectedRemainingStone.width && widthInCm > 0;
                          const isValidLength = lengthInCm <= (selectedRemainingStone.length * 100) && lengthInCm > 0;
                          
                          // Get validation error for this partition (from state or partition.validationError)
                          const partitionError = partition.validationError || partitionValidationErrors.get(partition.id);
                          const hasError = !!partitionError || (!isValidWidth && partition.width > 0) || (!isValidLength && partition.length > 0);

                          return (
                            <tr 
                              key={partition.id} 
                              className={`hover:bg-gray-50 dark:hover:bg-gray-700/50 ${
                                hasError ? 'bg-red-50/50 dark:bg-red-900/10' : ''
                              }`}
                            >
                              <td className="px-4 py-3">
                                <FormattedNumberInput
                                  value={partition.width}
                                  onChange={(value) => handleUpdatePartition(partition.id, 'width', value)}
                                  className={`w-full px-3 py-2 border rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-orange-500 focus:border-transparent text-sm ${
                                    hasError
                                      ? 'border-red-500 dark:border-red-400'
                                      : 'border-gray-300 dark:border-gray-600'
                                  }`}
                                  min={0}
                                  step={0.1}
                                  placeholder="0"
                                />
                                {!isValidWidth && partition.width > 0 && (
                                  <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                                    حداکثر: {formatDisplayNumber(selectedRemainingStone.width)}cm
                                  </p>
                                )}
                              </td>
                              <td className="px-4 py-3">
                                <FormattedNumberInput
                                  value={partition.length}
                                  onChange={(value) => handleUpdatePartition(partition.id, 'length', value)}
                                  className={`w-full px-3 py-2 border rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-orange-500 focus:border-transparent text-sm ${
                                    hasError
                                      ? 'border-red-500 dark:border-red-400'
                                      : 'border-gray-300 dark:border-gray-600'
                                  }`}
                                  min={0}
                                  step={0.1}
                                  placeholder="0"
                                />
                                {!isValidLength && partition.length > 0 && (
                                  <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                                    حداکثر: {formatDisplayNumber(selectedRemainingStone.length * 100)}cm
                                  </p>
                                )}
                              </td>
                              <td className="px-4 py-3">
                                <div className="text-sm text-gray-700 dark:text-gray-300 font-medium">
                                  {formatDisplayNumber(partition.squareMeters)}
                                </div>
                              </td>
                              <td className="px-4 py-3 text-center">
                                <button
                                  onClick={() => handleRemovePartition(partition.id)}
                                  disabled={partitions.length === 1}
                                  className="p-2 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                  title="حذف"
                                >
                                  <FaTrash className="w-4 h-4" />
                                </button>
                              </td>
                            </tr>
                          );
                        })}
                        {/* Display partition-specific validation errors below the table */}
                        {partitions.some(p => p.validationError || partitionValidationErrors.has(p.id)) && (
                          <tr>
                            <td colSpan={4} className="px-4 py-3">
                              <div className="space-y-2">
                                {partitions.map(partition => {
                                  const error = partition.validationError || partitionValidationErrors.get(partition.id);
                                  if (!error) return null;
                                  
                                  return (
                                    <div 
                                      key={`error-${partition.id}`}
                                      className="flex items-start gap-2 p-2 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg"
                                    >
                                      <span className="text-red-600 dark:text-red-400 font-medium text-xs">⚠️</span>
                                      <div className="flex-1">
                                        <p className="text-xs text-red-700 dark:text-red-300 font-medium">
                                          پارتیشن #{partitions.findIndex(p => p.id === partition.id) + 1}:
                                        </p>
                                        <p className="text-xs text-red-600 dark:text-red-400 mt-1">
                                          {error}
                                        </p>
                                      </div>
                                    </div>
                                  );
                                })}
                              </div>
                            </td>
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </div>

                  {/* Summary */}
                  {(() => {
                    const validPartitions = partitions.filter(p => p.width > 0 && p.length > 0);
                    const totalUsedSquareMeters = validPartitions.reduce((sum, p) => sum + p.squareMeters, 0);
                    const remainingSquareMeters = selectedRemainingStone.squareMeters - totalUsedSquareMeters;

                    return validPartitions.length > 0 && (
                      <div className="mt-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                        <div className="grid grid-cols-3 gap-4 text-sm">
                          <div>
                            <span className="text-blue-600 dark:text-blue-400">مجموع متر مربع استفاده شده:</span>
                            <span className="font-medium text-blue-800 dark:text-blue-200 mr-2">{formatDisplayNumber(totalUsedSquareMeters)}</span>
                          </div>
                          <div>
                            <span className="text-blue-600 dark:text-blue-400">متر مربع باقی‌مانده:</span>
                            <span className={`font-medium mr-2 ${remainingSquareMeters >= 0 ? 'text-blue-800 dark:text-blue-200' : 'text-red-600 dark:text-red-400'}`}>
                              {formatDisplayNumber(remainingSquareMeters)}
                            </span>
                          </div>
                          <div>
                            <span className="text-blue-600 dark:text-blue-400">تعداد پارتیشن‌ها:</span>
                            <span className="font-medium text-blue-800 dark:text-blue-200 mr-2">{validPartitions.length}</span>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                </div>

                {/* CAD Designer for Remaining Stone */}
                <div className="mt-6 bg-white dark:bg-gray-800 rounded-xl border-2 border-orange-200 dark:border-orange-800 shadow-lg overflow-hidden">
                  <div className="bg-gradient-to-r from-orange-500 to-orange-600 dark:from-orange-600 dark:to-orange-700 px-6 py-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                          <FaRuler className="text-white text-lg" />
                        </div>
                        <div>
                          <h4 className="text-lg font-bold text-white">ابزار طراحی CAD</h4>
                          <p className="text-xs text-orange-100">طراحی پارتیشن‌ها روی سنگ باقی‌مانده</p>
                        </div>
                      </div>
                      <button
                        type="button"
                        onClick={() => setShowRemainingStoneCAD(!showRemainingStoneCAD)}
                        className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg transition-colors text-sm font-medium"
                      >
                        {showRemainingStoneCAD ? 'مخفی کردن' : 'نمایش'}
                      </button>
                    </div>
                  </div>
                  
                  {showRemainingStoneCAD && selectedRemainingStone && (
                    <div className="p-6">
                      <p className="text-sm text-gray-700 dark:text-gray-300 mb-4 leading-relaxed">
                        از این ابزار برای طراحی و برنامه‌ریزی پارتیشن‌ها روی سنگ باقی‌مانده استفاده کنید. می‌توانید پارتیشن‌ها را به صورت بصری رسم کنید.
                      </p>
                      
                      <StoneCADDesigner
                        originalLength={selectedRemainingStone.length}
                        originalWidth={selectedRemainingStone.width}
                        lengthUnit="m"
                        widthUnit="cm"
                        productType="longitudinal"
                        mode="design"
                        enableCostCalculation={false}
                        enableAutoSync={true}
                        onDimensionsCalculated={(dims) => {
                          // When dimensions are drawn in CAD, update partitions
                          if (dims.length && dims.width && partitions.length > 0) {
                            const firstPartition = partitions[0];
                            handleUpdatePartition(firstPartition.id, 'width', dims.width);
                            handleUpdatePartition(firstPartition.id, 'length', dims.length);
                          }
                        }}
                      />
                    </div>
                  )}
                </div>

                {/* Action Buttons */}
                <div className="flex justify-end gap-3 mt-6">
                  <button
                    onClick={() => {
                      setShowRemainingStoneModal(false);
                      setSelectedRemainingStone(null);
                      setRemainingStoneConfig({});
                      setPartitions([{
                        id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        width: 0,
                        length: 0,
                        squareMeters: 0
                      }]);
                      setRemainingStoneLengthUnit('cm');
                      setRemainingStoneWidthUnit('cm');
                      setPartitionLengthUnit('m');
                      setPartitionWidthUnit('cm');
                      setRemainingStoneIsMandatory(false);
                      setRemainingStoneMandatoryPercentage(20);
                    }}
                    className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                  >
                    انصراف
                  </button>
                  <button
                    onClick={() => {
                      console.log('🔘 Partition Button clicked!');
                      handleAddRemainingStoneToContract();
                    }}
                    className="px-6 py-2 bg-gradient-to-r from-orange-500 to-orange-600 hover:from-orange-600 hover:to-orange-700 text-white rounded-lg transition-all duration-200 font-medium"
                  >
                    ایجاد پارتیشن‌ها
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
        {/* SubService Selection Modal */}
        {showSubServiceModal && selectedSubServiceProductIndex !== null && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
              <div className="p-6">
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-white">
                    مدیریت ابزار برای محصول
                  </h3>
                  <button
                    onClick={() => {
                      setShowSubServiceModal(false);
                      setSelectedSubServiceProductIndex(null);
                      setSelectedSubServices([]);
                      setSubServiceMeterValues({});
                      setSubServiceCalculationBases({});
                    }}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                  >
                    <FaTimes className="w-6 h-6" />
                  </button>
                </div>

                {/* Product Info */}
                {(() => {
                  const currentProduct = wizardData.products[selectedSubServiceProductIndex];
                  if (!currentProduct) return null;
                  
                  const lengthInMeters = currentProduct.lengthUnit === 'm' ? currentProduct.length : (currentProduct.length / 100);
                  const availableLength = lengthInMeters - (currentProduct.usedLengthForSubServices || 0);
                  const availableSquareMeters = currentProduct.squareMeters - (currentProduct.usedSquareMetersForSubServices || 0);
                  
                  return (
                    <div className="mb-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg border border-purple-200 dark:border-purple-800">
                      <h4 className="font-medium text-purple-800 dark:text-purple-200 mb-2">
                        {currentProduct.stoneName}
                      </h4>
                      <div className="grid grid-cols-2 gap-4 text-sm">
                        <div>
                          <span className="text-purple-600 dark:text-purple-400">طول باقی‌مانده:</span>
                          <span className="font-medium text-purple-800 dark:text-purple-200 mr-2">
                            {formatDisplayNumber(availableLength)}m
                          </span>
                        </div>
                        <div>
                          <span className="text-purple-600 dark:text-purple-400">متر مربع باقی‌مانده:</span>
                          <span className="font-medium text-purple-800 dark:text-purple-200 mr-2">
                            {formatDisplayNumber(availableSquareMeters)} متر مربع
                          </span>
                        </div>
                      </div>
                    </div>
                  );
                })()}

                {/* SubService Selection */}
                <div className="mb-6">
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
                    انتخاب ابزارها
                  </label>
                  <div className="space-y-2 max-h-60 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded-lg p-3">
                    {subServices.length === 0 ? (
                      <p className="text-gray-500 dark:text-gray-400 text-center py-4">
                        هیچ ابزاری تعریف نشده است
                      </p>
                    ) : (
                      subServices.map((subService) => (
                        <label
                          key={subService.id}
                          className="flex items-center space-x-3 space-x-reverse p-3 hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg cursor-pointer border border-gray-200 dark:border-gray-700"
                        >
                          <input
                            type="checkbox"
                            checked={selectedSubServices.some(s => s.id === subService.id)}
                            onChange={(e) => {
                              if (e.target.checked) {
                                setSelectedSubServices(prev => [...prev, subService]);
                                // Initialize with default calculation base from subService
                                if (!subServiceCalculationBases[subService.id]) {
                                  setSubServiceCalculationBases(prev => ({ ...prev, [subService.id]: subService.calculationBase }));
                                }
                                // Initialize meter value to 0 (will be set to default when user selects unit)
                                if (!subServiceMeterValues[subService.id]) {
                                  setSubServiceMeterValues(prev => ({ ...prev, [subService.id]: 0 }));
                                }
                              } else {
                                setSelectedSubServices(prev => prev.filter(s => s.id !== subService.id));
                                setSubServiceMeterValues(prev => {
                                  const newValues = { ...prev };
                                  delete newValues[subService.id];
                                  return newValues;
                                });
                                setSubServiceCalculationBases(prev => {
                                  const newBases = { ...prev };
                                  delete newBases[subService.id];
                                  return newBases;
                                });
                              }
                            }}
                            className="w-4 h-4 text-purple-600 bg-gray-100 border-gray-300 rounded focus:ring-purple-500"
                          />
                          <div className="flex-1">
                            <div className="font-medium text-gray-900 dark:text-white">
                              {subService.namePersian}
                            </div>
                            <div className="text-xs text-gray-500 dark:text-gray-400">
                              هزینه: {formatPrice(subService.pricePerMeter, 'تومان')} / {subService.calculationBase === 'length' ? 'متر' : 'متر مربع'}
                            </div>
                          </div>
                        </label>
                      ))
                    )}
                  </div>
                </div>

                {/* Meter Input for Selected SubServices */}
                {selectedSubServices.length > 0 && (
                  <div className="mb-6 space-y-4">
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
                      مقدار استفاده (متر یا متر مربع)
                    </label>
                    {selectedSubServices.map((subService) => {
                      const currentProduct = wizardData.products[selectedSubServiceProductIndex];
                      if (!currentProduct) return null;
                      
                      const lengthInMeters = currentProduct.lengthUnit === 'm' ? currentProduct.length : (currentProduct.length / 100);
                      const availableLength = lengthInMeters - (currentProduct.usedLengthForSubServices || 0);
                      const availableSquareMeters = currentProduct.squareMeters - (currentProduct.usedSquareMetersForSubServices || 0);
                      
                      // Get selected calculation base (user can override default)
                      const selectedCalculationBase = subServiceCalculationBases[subService.id] || subService.calculationBase;
                      
                      // Calculate max value and default value based on selected calculation base
                      const maxValue = selectedCalculationBase === 'length' ? availableLength : availableSquareMeters;
                      const unitLabel = selectedCalculationBase === 'length' ? 'متر' : 'متر مربع';
                      
                      // Get current meter value, or set to maxValue if it's 0 (default to complete amount)
                      const currentMeterValue = subServiceMeterValues[subService.id] || 0;
                      const meterValue = currentMeterValue > 0 ? currentMeterValue : maxValue; // Default to complete amount
                      
                      // Calculate cost based on selected unit and amount
                      const calculatedCost = meterValue > 0 ? meterValue * subService.pricePerMeter : 0;
                      
                      // Handle unit toggle
                      const handleUnitToggle = (newBase: 'length' | 'squareMeters') => {
                        setSubServiceCalculationBases(prev => ({ ...prev, [subService.id]: newBase }));
                        // Reset meter value when switching units (will default to new max)
                        setSubServiceMeterValues(prev => ({ ...prev, [subService.id]: 0 }));
                      };
                      
                      // Handle meter value change
                      const handleMeterValueChange = (value: number) => {
                        setSubServiceMeterValues(prev => ({ ...prev, [subService.id]: value }));
                      };
                      
                      return (
                        <div key={subService.id} className="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg border border-gray-200 dark:border-gray-600">
                          <div className="flex items-center justify-between mb-3">
                            <div className="flex-1">
                              <div className="font-medium text-gray-900 dark:text-white mb-1">
                                {subService.namePersian}
                              </div>
                              <div className="text-xs text-gray-500 dark:text-gray-400 mb-2">
                                مبنای پیش‌فرض: {subService.calculationBase === 'length' ? 'طول' : 'متر مربع'}
                              </div>
                              {/* Unit Toggle */}
                              <div className="flex items-center gap-2 mt-2">
                                <span className="text-xs text-gray-600 dark:text-gray-400">واحد محاسبه:</span>
                                <div className="flex gap-1">
                                  <button
                                    type="button"
                                    onClick={() => handleUnitToggle('length')}
                                    className={`px-3 py-1 text-xs rounded transition-colors ${
                                      selectedCalculationBase === 'length'
                                        ? 'bg-purple-600 text-white'
                                        : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                                    }`}
                                  >
                                    متر
                                  </button>
                                  <button
                                    type="button"
                                    onClick={() => handleUnitToggle('squareMeters')}
                                    className={`px-3 py-1 text-xs rounded transition-colors ${
                                      selectedCalculationBase === 'squareMeters'
                                        ? 'bg-purple-600 text-white'
                                        : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                                    }`}
                                  >
                                    متر مربع
                                  </button>
                                </div>
                              </div>
                            </div>
                            {calculatedCost > 0 && (
                              <div className="text-purple-600 dark:text-purple-400 font-semibold text-right ml-4">
                                <div className="text-sm">{formatPrice(calculatedCost, 'تومان')}</div>
                                <div className="text-xs text-gray-500 dark:text-gray-400">
                                  {formatPrice(subService.pricePerMeter, 'تومان')} / {unitLabel}
                                </div>
                              </div>
                            )}
                          </div>
                          <div className="mt-3">
                          <FormattedNumberInput
                            value={meterValue}
                              onChange={handleMeterValueChange}
                            className={`w-full px-3 py-2 border rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-purple-500 focus:border-transparent ${
                              meterValue > maxValue ? 'border-red-500 dark:border-red-400' : 'border-gray-300 dark:border-gray-600'
                            }`}
                            min={0}
                            step={0.01}
                            placeholder={`حداکثر: ${formatDisplayNumber(maxValue)} ${unitLabel}`}
                          />
                          {meterValue > maxValue && (
                            <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                              مقدار نمی‌تواند بیشتر از {formatDisplayNumber(maxValue)} {unitLabel} باشد
                            </p>
                          )}
                            <div className="flex items-center justify-between mt-1">
                              <p className="text-xs text-gray-500 dark:text-gray-400">
                            حداکثر موجود: {formatDisplayNumber(maxValue)} {unitLabel}
                          </p>
                              {meterValue === maxValue && (
                                <p className="text-xs text-green-600 dark:text-green-400">
                                  ✓ مقدار کامل
                                </p>
                              )}
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}

                {/* Action Buttons */}
                <div className="flex justify-end gap-3 mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
                  <button
                    onClick={() => {
                      setShowSubServiceModal(false);
                      setSelectedSubServiceProductIndex(null);
                      setSelectedSubServices([]);
                      setSubServiceMeterValues({});
                      setSubServiceCalculationBases({});
                    }}
                    className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                  >
                    انصراف
                  </button>
                  <button
                    onClick={() => {
                      if (selectedSubServiceProductIndex === null) return;
                      
                      const currentProduct = wizardData.products[selectedSubServiceProductIndex];
                      if (!currentProduct) return;
                      
                      // Validate all meter values
                      let isValid = true;
                      const lengthInMeters = currentProduct.lengthUnit === 'm' ? currentProduct.length : (currentProduct.length / 100);
                      const availableLength = lengthInMeters - (currentProduct.usedLengthForSubServices || 0);
                      const availableSquareMeters = currentProduct.squareMeters - (currentProduct.usedSquareMetersForSubServices || 0);
                      
                      selectedSubServices.forEach(subService => {
                        const selectedCalculationBase = subServiceCalculationBases[subService.id] || subService.calculationBase;
                        const currentMeterValue = subServiceMeterValues[subService.id] || 0;
                        const maxValue = selectedCalculationBase === 'length' ? availableLength : availableSquareMeters;
                        const meterValue = currentMeterValue > 0 ? currentMeterValue : maxValue; // Use max if 0 (default)
                        
                        if (meterValue > maxValue || meterValue <= 0) {
                          isValid = false;
                        }
                      });
                      
                      if (!isValid) {
                        setErrors({ products: 'لطفاً مقادیر معتبر برای ابزارها وارد کنید' });
                        return;
                      }
                      
                      // Calculate applied sub-services with user-selected calculation base and amount
                      const appliedSubServices: AppliedSubService[] = selectedSubServices.map(subService => {
                        const selectedCalculationBase = subServiceCalculationBases[subService.id] || subService.calculationBase;
                        const currentMeterValue = subServiceMeterValues[subService.id] || 0;
                        const maxValue = selectedCalculationBase === 'length' ? availableLength : availableSquareMeters;
                        const meterValue = currentMeterValue > 0 ? currentMeterValue : maxValue; // Use max if 0 (default to complete)
                        const cost = meterValue * subService.pricePerMeter;
                        
                        return {
                          id: `applied_${subService.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                          subServiceId: subService.id,
                          subService: subService,
                          meter: meterValue,
                          cost: cost,
                          calculationBase: selectedCalculationBase // Use user-selected calculation base
                        };
                      });
                      
                      // Calculate totals - ADD to existing sub-services (incremental addition)
                      const existingSubServices = currentProduct.appliedSubServices || [];
                      const allAppliedSubServices = [...existingSubServices, ...appliedSubServices];
                      
                      const totalSubServiceCost = allAppliedSubServices.reduce((sum, applied) => sum + applied.cost, 0);
                      const usedLength = allAppliedSubServices
                        .filter(applied => applied.calculationBase === 'length')
                        .reduce((sum, applied) => sum + applied.meter, 0);
                      const usedSquareMeters = allAppliedSubServices
                        .filter(applied => applied.calculationBase === 'squareMeters')
                        .reduce((sum, applied) => sum + applied.meter, 0);
                      
                      // Calculate base price without sub-services (preserve it)
                      const basePriceWithoutSubServices = currentProduct.totalPrice - (currentProduct.totalSubServiceCost || 0);
                      
                      // Update product with sub-services
                      const updatedProducts = [...wizardData.products];
                      updatedProducts[selectedSubServiceProductIndex] = {
                        ...currentProduct,
                        appliedSubServices: allAppliedSubServices,
                        totalSubServiceCost: totalSubServiceCost,
                        usedLengthForSubServices: usedLength,
                        usedSquareMetersForSubServices: usedSquareMeters,
                        totalPrice: basePriceWithoutSubServices + totalSubServiceCost // Base price + all sub-service costs
                      };
                      
                      updateWizardData({ products: updatedProducts });
                      
                      // Close modal
                      setShowSubServiceModal(false);
                      setSelectedSubServiceProductIndex(null);
                      setSelectedSubServices([]);
                      setSubServiceMeterValues({});
                      setSubServiceCalculationBases({});
                      setErrors({});
                    }}
                    className="px-6 py-2 bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white rounded-lg transition-all duration-200 font-medium"
                  >
                    اعمال ابزارها
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* New Modal Components */}
        <ProductConfigurationModal
          isOpen={showProductModal && !useStairFlowV2}
          onClose={() => {
            setShowProductModal(false);
            setSelectedProduct(null);
          }}
          product={selectedProduct}
          productType={wizardData.selectedProductTypeForAddition}
          onSave={(product: ContractProduct) => {
            updateWizardData({ products: [...wizardData.products, product] });
            setShowProductModal(false);
            setSelectedProduct(null);
          }}
          wizardData={wizardData}
          updateWizardData={updateWizardData}
          selectedProductIndexForEdit={editingProductIndex}
        />

        <StairSystemModal
          isOpen={showProductModal && useStairFlowV2 && (wizardData.selectedProductTypeForAddition === 'stair')}
          onClose={() => {
            setShowProductModal(false);
            setSelectedProduct(null);
          }}
          onSave={() => {
            // Handle stair system save
            setShowProductModal(false);
          }}
          wizardData={wizardData}
          updateWizardData={updateWizardData}
          draftTread={draftTread}
          draftRiser={draftRiser}
          draftLanding={draftLanding}
          stairActivePart={stairActivePart}
          setStairActivePart={setStairActivePartState}
        />

        <RemainingStoneModal
          isOpen={showRemainingStoneModal}
          onClose={() => {
            setShowRemainingStoneModal(false);
            setSelectedRemainingStone(null);
          }}
          remainingStone={selectedRemainingStone}
          onCreatePartitions={(partitions: any[]) => {
            // Handle partition creation
            setShowRemainingStoneModal(false);
            setSelectedRemainingStone(null);
          }}
          wizardData={wizardData}
        />

        <SubServiceModal
          isOpen={showSubServiceModal}
          onClose={() => {
            setShowSubServiceModal(false);
            setSelectedSubServiceProductIndex(null);
          }}
          productIndex={selectedSubServiceProductIndex || 0}
          onSave={(subServices: any[]) => {
            // Handle sub-service save
            setShowSubServiceModal(false);
            setSelectedSubServiceProductIndex(null);
          }}
          wizardData={wizardData}
          updateWizardData={updateWizardData}
        />
      </div>
    </div>
  );
}