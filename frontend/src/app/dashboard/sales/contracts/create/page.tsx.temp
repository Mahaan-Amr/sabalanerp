'use client';

import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { 
  FaArrowRight, 
  FaArrowLeft, 
  FaCheck,
  FaCalendarAlt,
  FaUser,
  FaBuilding,
  FaWarehouse,
  FaTruck,
  FaCreditCard,
  FaSignature,
  FaFileContract,
  FaPlus,
  FaTrash,
  FaSearch,
  FaTimes,
  FaEdit,
  FaLayerGroup,
  FaRuler,
  FaSquare,
  FaCubes,
  FaThLarge,
  FaChevronDown,
  FaChevronUp,
  FaTools
} from 'react-icons/fa';
import { salesAPI, crmAPI, dashboardAPI, servicesAPI } from '@/lib/api';
import PersianCalendar from '@/lib/persian-calendar';
import PersianCalendarComponent from '@/components/PersianCalendar';
import { formatDisplayNumber, formatPrice, formatPriceWithRial, formatDimensions, formatSquareMeters, formatQuantity, tomanToRial } from '@/lib/numberFormat';
import FormattedNumberInput from '@/components/FormattedNumberInput';
import StoneCanvas from '@/components/StoneCanvas';
import { StoneCADDesigner } from '@/components/stone-cad/StoneCADDesigner';

// Import new step components
import { Step1ContractDate } from '@/features/contract-creation/components/steps/Step1ContractDate';
import { Step2CustomerSelection } from '@/features/contract-creation/components/steps/Step2CustomerSelection';
import { Step3ProjectManagement } from '@/features/contract-creation/components/steps/Step3ProjectManagement';
import { Step4ProductTypeSelection } from '@/features/contract-creation/components/steps/Step4ProductTypeSelection';
import { Step5ProductSelection } from '@/features/contract-creation/components/steps/Step5ProductSelection';
import { Step6DeliverySchedule } from '@/features/contract-creation/components/steps/Step6DeliverySchedule';
import { Step7PaymentMethod } from '@/features/contract-creation/components/steps/Step7PaymentMethod';
import { Step8DigitalSignature } from '@/features/contract-creation/components/steps/Step8DigitalSignature';

// Import shared components
import { WizardProgressBar, type WizardStep } from '@/features/contract-creation/components/shared/WizardProgressBar';
import { WizardNavigation } from '@/features/contract-creation/components/shared/WizardNavigation';

// Import modal components
import { ProductConfigurationModal } from '@/features/contract-creation/components/modals/ProductConfigurationModal';
import { StairSystemModal } from '@/features/contract-creation/components/modals/StairSystemModal';
import { RemainingStoneModal } from '@/features/contract-creation/components/modals/RemainingStoneModal';
import { SubServiceModal } from '@/features/contract-creation/components/modals/SubServiceModal';

// Import hooks
import { useContractWizard } from '@/features/contract-creation/hooks/useContractWizard';
import { useProductModal } from '@/features/contract-creation/hooks/useProductModal';
import { useProductCalculations } from '@/features/contract-creation/hooks/useProductCalculations';
import { useRemainingStoneModal } from '@/features/contract-creation/hooks/useRemainingStoneModal';
import { useSubServiceModal } from '@/features/contract-creation/hooks/useSubServiceModal';
import { usePaymentHandlers } from '@/features/contract-creation/hooks/usePaymentHandlers';
import { useDigitalSignature } from '@/features/contract-creation/hooks/useDigitalSignature';
import { useStairSystemV2 } from '@/features/contract-creation/hooks/useStairSystemV2';
import { useDeliverySchedule } from '@/features/contract-creation/hooks/useDeliverySchedule';
import { useContractSubmission } from '@/features/contract-creation/hooks/useContractSubmission';

// Import constants
import { NOSING_TYPES, PRODUCT_TYPES, WIZARD_STEPS } from '@/features/contract-creation/constants/contract.constants';

// Import utilities
import { generateFullProductName, productSupportsContractType } from '@/features/contract-creation/utils/productUtils';
import { determineSlabLineCutPlan } from '@/features/contract-creation/utils/productCalculations';
import { calculateRemainingStoneDimensions, recalculateUsedRemainingDimensions } from '@/features/contract-creation/utils/dimensionUtils';
import { validatePartitions, calculateRemainingAreasAfterPartitions } from '@/features/contract-creation/services/stoneCuttingService';
import { calculatePartitionPositions } from '@/features/contract-creation/services/partitionPositioningService';

// Import all types from types file
import type {
  CrmCustomer,
  ProjectAddress,
  PhoneNumber,
  Product,
  StoneCut,
  RemainingStone,
  SlabStandardDimensionEntry,
  StonePartition,
  SubService,
  StoneFinishing,
  AppliedSubService,
  CuttingBreakdownEntry,
  ServiceEntry,
  StairPart,
  StairSystemConfig,
  ContractProduct,
  DeliveryProductItem,
  DeliverySchedule,
  PaymentEntry,
  PaymentMethod,
  PaymentInstallment,
  ContractWizardData,
  ContractUsageType,
  SlabLineCutPlan,
  WidthSlice,
  PartitionPositioningResult,
  PartitionValidationResult,
  StairStepperPart,
  UnitType,
  ToolSelectionV2,
  StairPartDraftV2,
  StairDraftFieldErrors,
  LayerTypeOption,
  LayerEdgeDemand
} from '@/features/contract-creation/types/contract.types';

// Types are now imported from contract.types.ts

// Constants, types, and utilities are now imported from feature modules

// Step definitions
// WIZARD_STEPS is now imported from constants file
// All utility functions are now imported from service files
// All calculation functions have been moved to service files - removed ~1400 lines of duplicate code

// All duplicate utility functions removed - they're imported from service files
// Removed ~1400 lines: calculateStoneCutting, calculateSlabCutting, calculatePartitionPositions,
// validatePartitions, calculateRemainingStoneDimensions, generateFullProductName,
// handleSmartCalculation, calculateStoneMetrics, calculateSlabMetrics, etc.

// All duplicate utility functions removed - they're imported from service files
// Removed ~1400 lines: calculateSlabCutting, calculatePartitionPositions,
// validatePartitions, calculateRemainingStoneDimensions, generateFullProductName,
// handleSmartCalculation, calculateStoneMetrics, calculateSlabMetrics, etc.

// calculatePartitionPositions has been extracted to services/partitionPositioningService.ts (143 lines)
// Now imported from the service above

// DUPLICATE FUNCTIONS REMOVED (lines 143-964, ~821 lines)
// All calculation functions are now accessed via useProductCalculations hook:
// - handleSmartCalculation
// - calculateStoneMetrics
// - calculateSlabMetrics
// - calculateSlabCutting
// - calculateSlabCuttingCostForEntry
// These are all imported from utils/productCalculations.ts and wrapped in the hook

export default function CreateContractWizard() {
  const router = useRouter();

  // Use contract wizard hook for step management
  const {
    currentStep,
    changedField,
    value,
    currentConfig: { length, width, squareMeters, quantity },
    lengthUnit,
    widthUnit
  });
  
  // Convert dimensions to cm for calculations
  const lengthInCm = length ? (lengthUnit === 'm' ? length * 100 : length) : 0;
  const widthInCm = width ? (widthUnit === 'm' ? width * 100 : width) : 0;
  
  let newLength = length;
  let newWidth = width;
  let newSquareMeters = squareMeters;
  
  // Update the changed field
  if (changedField === 'length') {
    newLength = value;
  } else if (changedField === 'width') {
    newWidth = value;
  } else if (changedField === 'squareMeters') {
    newSquareMeters = value;
  } else if (changedField === 'quantity') {
    // Quantity change affects square meters calculation
    if (lengthInCm && widthInCm) {
      newSquareMeters = (lengthInCm * widthInCm * actualQuantity) / 10000;
    }
  }
  
  // Smart calculation logic
  if (changedField === 'length' || changedField === 'width' || changedField === 'quantity') {
    // If we have both length and width, calculate square meters
    const updatedLengthInCm = changedField === 'length' ? (lengthUnit === 'm' ? value * 100 : value) : lengthInCm;
    const updatedWidthInCm = changedField === 'width' ? (widthUnit === 'm' ? value * 100 : value) : widthInCm;
    const updatedQuantity = changedField === 'quantity' ? actualQuantity : actualQuantity;
    
    console.log('ğŸ“ Dimension Calculation:', {
      updatedLengthInCm,
      updatedWidthInCm,
      updatedQuantity,
      actualQuantity,
      willCalculate: !!(updatedLengthInCm && updatedWidthInCm)
    });
    
    if (updatedLengthInCm && updatedWidthInCm) {
      newSquareMeters = (updatedLengthInCm * updatedWidthInCm * updatedQuantity) / 10000;
      console.log('âœ… Calculated Square Meters:', newSquareMeters);
    }
  } else if (changedField === 'squareMeters') {
    // If square meters is manually changed, recalculate length based on current width
    const updatedQuantity = actualQuantity;
    
    if (widthInCm) {
      // Calculate length from width and square meters (width takes priority)
      const calculatedLengthInCm = (value * 10000) / (widthInCm * updatedQuantity);
      newLength = lengthUnit === 'm' ? calculatedLengthInCm / 100 : calculatedLengthInCm;
      console.log('âœ… Calculated Length from Width and Square Meters:', newLength);
    } else if (lengthInCm) {
      // Calculate width from length and square meters (if no width available)
      const calculatedWidthInCm = (value * 10000) / (lengthInCm * updatedQuantity);
      newWidth = widthUnit === 'm' ? calculatedWidthInCm / 100 : calculatedWidthInCm;
      console.log('âœ… Calculated Width from Length and Square Meters:', newWidth);
    }
  }
  
  const result = {
    length: newLength,
    width: newWidth,
    squareMeters: newSquareMeters
  };
  
  console.log('ğŸ¯ Smart Calculation Result:', result);
  
  return result;
};
const calculateStoneMetrics = (data: {
  length?: number;
  width?: number;
  quantity?: number;
  squareMeters?: number;
  pricePerSquareMeter?: number;
  lengthUnit?: 'cm' | 'm';
  widthUnit?: 'cm' | 'm';
  isMandatory?: boolean;
  mandatoryPercentage?: number;
  isCut?: boolean;
  originalWidth?: number;
  cuttingCostPerMeter?: number;
}) => {
  const { length, width, quantity = 1, squareMeters, pricePerSquareMeter, lengthUnit = 'cm', widthUnit = 'cm', isMandatory = false, mandatoryPercentage = 20, isCut = false, originalWidth = 0, cuttingCostPerMeter = 0 } = data;
  
  let calculatedSquareMeters = 0;
  let calculatedLength = 0;
  let calculatedWidth = 0;
  let calculatedTotalPrice = 0;
  let originalTotalPrice = 0;
  
  // Convert dimensions to cm for calculations
  const lengthInCm = length ? (lengthUnit === 'm' ? length * 100 : length) : 0;
  const widthInCm = width ? (widthUnit === 'm' ? width * 100 : width) : 0;
  
  // Scenario 1: We have length and width, calculate square meters
  if (lengthInCm && widthInCm && !squareMeters) {
    calculatedSquareMeters = (lengthInCm * widthInCm * quantity) / 10000; // Convert cmÂ² to mÂ²
  }
  // Scenario 2: We have square meters and width, calculate length
  else if (squareMeters && widthInCm && !length) {
    calculatedLength = (squareMeters * 10000) / (widthInCm * quantity); // Convert mÂ² to cmÂ²
    // Convert back to original unit
    calculatedLength = lengthUnit === 'm' ? calculatedLength / 100 : calculatedLength;
  }
  // Scenario 3: We have square meters and length, calculate width
  else if (squareMeters && lengthInCm && !width) {
    calculatedWidth = (squareMeters * 10000) / (lengthInCm * quantity); // Convert mÂ² to cmÂ²
    // Convert back to original unit
    calculatedWidth = widthUnit === 'm' ? calculatedWidth / 100 : calculatedWidth;
  }
  // Scenario 4: We have all dimensions, use provided square meters
  else if (squareMeters) {
    calculatedSquareMeters = squareMeters;
  }
  
  // Calculate total price if we have price per square meter
  if (pricePerSquareMeter && calculatedSquareMeters) {
    console.log('ğŸ’° Starting price calculation:', {
      isCut,
      originalWidth,
      widthInCm,
      calculatedSquareMeters,
      pricePerSquareMeter
    });
    
    // ğŸ¯ CRITICAL FIX: Always use original width for pricing when available
    let pricingSquareMeters = calculatedSquareMeters;
    
    if (originalWidth > 0 && widthInCm > 0) {
      // Always calculate pricing based on ORIGINAL width when available
      const originalWidthInCm = typeof originalWidth === 'string' ? parseFloat(originalWidth) : originalWidth;
      const lengthInCmForPricing = lengthInCm;
      
      // Calculate square meters for pricing using ORIGINAL width
      pricingSquareMeters = (lengthInCmForPricing * originalWidthInCm * quantity) / 10000;
      
      console.log('ğŸ”§ Pricing with Original Width:', {
        userEnteredWidth: widthInCm,
        originalWidth: originalWidthInCm,
        length: lengthInCmForPricing,
        quantity,
        displaySquareMeters: calculatedSquareMeters, // For display (user-entered width)
        pricingSquareMeters: pricingSquareMeters, // For pricing (original width)
        pricePerSquareMeter,
        isCut,
        isMandatory
      });
    } else {
      console.log('ğŸ’° Regular pricing (no original width available):', {
        isCut,
        originalWidth,
        widthInCm,
        pricingSquareMeters: calculatedSquareMeters
      });
    }
    
    originalTotalPrice = pricingSquareMeters * pricePerSquareMeter;
    
    console.log('ğŸ’° Final Pricing Calculation:', {
      pricingSquareMeters,
      pricePerSquareMeter,
      originalTotalPrice,
      isMandatory,
      mandatoryPercentage
    });
    
    // Calculate cutting cost if stone is cut (but DON'T add it to totalPrice)
    // Cutting cost will be shown separately in Ø®Ù„Ø§ØµÙ‡ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ø´ only
    let cuttingCost = 0;
    if (isCut && originalWidth > 0 && cuttingCostPerMeter > 0) {
      const lengthInCm = lengthUnit === 'm' ? (length || 0) * 100 : (length || 0);
      cuttingCost = (lengthInCm / 100) * cuttingCostPerMeter * quantity; // Convert cm to meters and multiply by quantity
    }
    
    // Apply mandatory percentage increase if enabled
    // IMPORTANT: cuttingCost is NOT added to calculatedTotalPrice - it's shown separately
    if (isMandatory && mandatoryPercentage > 0) {
      calculatedTotalPrice = originalTotalPrice * (1 + mandatoryPercentage / 100);
    } else {
      calculatedTotalPrice = originalTotalPrice;
    }
  }
  
  return {
    squareMeters: calculatedSquareMeters, // This remains the cut piece square meters for display
    length: calculatedLength || length || 0,
    width: calculatedWidth || width || 0,
    totalPrice: calculatedTotalPrice, // This now uses original width for pricing
    originalTotalPrice: originalTotalPrice, // This now uses original width for pricing
    cuttingCost: isCut && originalWidth > 0 && cuttingCostPerMeter > 0 ? 
      ((lengthUnit === 'm' ? (length || 0) * 100 : (length || 0)) / 100) * cuttingCostPerMeter * quantity : 0
  };
};

// Helper function to calculate cutting cost for a single standard dimension entry
const calculateSlabCuttingCostForEntry = (data: {
  standardLengthCm: number;
  standardWidthCm: number;
  requestedLengthCm: number;
  requestedWidthCm: number;
  quantity: number;
  cuttingCostPerMeterLongitudinal: number;
  cuttingCostPerMeterCross: number;
  lineCutLongitudinalMeters?: number;
  lineCutCrossMeters?: number;
}): number => {
  const {
    standardLengthCm,
    standardWidthCm,
    requestedLengthCm,
    requestedWidthCm,
    quantity,
    cuttingCostPerMeterLongitudinal,
    cuttingCostPerMeterCross,
    lineCutLongitudinalMeters,
    lineCutCrossMeters
  } = data;
  
  let entryCuttingCost = 0;
  
  const needsLongitudinalCut = requestedWidthCm < standardWidthCm && requestedWidthCm > 0;
  const needsCrossCut = requestedLengthCm < standardLengthCm && requestedLengthCm > 0;
  
  if (needsLongitudinalCut && cuttingCostPerMeterLongitudinal > 0) {
    const longitudinalMeters = lineCutLongitudinalMeters ?? (requestedLengthCm / 100);
    entryCuttingCost += longitudinalMeters * cuttingCostPerMeterLongitudinal * quantity;
  }
  
  if (needsCrossCut && cuttingCostPerMeterCross > 0) {
    const crossMeters = lineCutCrossMeters ?? (requestedWidthCm / 100);
    entryCuttingCost += crossMeters * cuttingCostPerMeterCross * quantity;
  }
  
  return entryCuttingCost;
};

// Helper function to calculate slab cutting with remaining pieces and cut details
const calculateSlabCutting = (data: {
  originalLength: number;
  originalWidth: number;
  desiredLength: number;
  desiredWidth: number;
  lengthUnit: 'cm' | 'm';
  widthUnit: 'cm' | 'm';
  cuttingCostPerMeterLongitudinal: number;
  cuttingCostPerMeterCross: number;
  quantity: number;
  longitudinalCutLengthMeters?: number;
  crossCutLengthMeters?: number;
}): {
  needsLongitudinalCut: boolean;
  needsCrossCut: boolean;
  totalCuttingCost: number;
  remainingPieces: RemainingStone[];
  cutDetails: StoneCut[];
} => {
  const {
    originalLength,
    originalWidth,
    desiredLength,
    desiredWidth,
    lengthUnit,
    widthUnit,
    cuttingCostPerMeterLongitudinal,
    cuttingCostPerMeterCross,
    quantity,
    longitudinalCutLengthMeters,
    crossCutLengthMeters
  } = data;

  // Convert all dimensions to cm for calculations
  const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
  const originalWidthCm = widthUnit === 'm' ? originalWidth * 100 : originalWidth;
  const desiredLengthCm = lengthUnit === 'm' ? desiredLength * 100 : desiredLength;
  const desiredWidthCm = widthUnit === 'm' ? desiredWidth * 100 : desiredWidth;

  // Determine if cuts are needed
  const needsLongitudinalCut = desiredWidthCm < originalWidthCm && desiredWidthCm > 0;
  const needsCrossCut = desiredLengthCm < originalLengthCm && desiredLengthCm > 0;

  // Calculate cutting costs
  let longitudinalCuttingCost = 0;
  let crossCuttingCost = 0;

  const effectiveLongitudinalMeters = longitudinalCutLengthMeters ?? (desiredLengthCm / 100);
  const effectiveCrossMeters = crossCutLengthMeters ?? (desiredWidthCm / 100);

  if (needsLongitudinalCut && cuttingCostPerMeterLongitudinal > 0) {
    longitudinalCuttingCost = effectiveLongitudinalMeters * cuttingCostPerMeterLongitudinal * quantity;
  }

  if (needsCrossCut && cuttingCostPerMeterCross > 0) {
    crossCuttingCost = effectiveCrossMeters * cuttingCostPerMeterCross * quantity;
  }

  const totalCuttingCost = longitudinalCuttingCost + crossCuttingCost;

  // Generate cut IDs once for reuse in both cut details and remaining pieces
  const timestamp = Date.now();
  const longitudinalCutId = needsLongitudinalCut ? `cut_longitudinal_${timestamp}_${Math.random().toString(36).substr(2, 9)}` : '';
  const crossCutId = needsCrossCut ? `cut_cross_${timestamp}_${Math.random().toString(36).substr(2, 9)}` : '';

  // Calculate remaining pieces (can be multiple pieces for 2D cutting)
  const remainingPieces: RemainingStone[] = [];

  if (needsLongitudinalCut || needsCrossCut) {
    const remainingWidth = originalWidthCm - desiredWidthCm;
    const remainingLength = originalLengthCm - desiredLengthCm;

    // Piece 1: Remaining width piece (if longitudinal cut)
    if (remainingWidth > 0 && desiredLengthCm > 0) {
      const pieceId1 = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      remainingPieces.push({
        id: pieceId1,
        width: remainingWidth,
        length: desiredLengthCm / 100, // Convert to meters
        squareMeters: (remainingWidth * desiredLengthCm * quantity) / 10000,
        isAvailable: remainingWidth > 0,
        sourceCutId: longitudinalCutId || crossCutId || '',
        position: {
          startWidth: desiredWidthCm,
          startLength: 0
        }
      });
    }

    // Piece 2: Remaining length piece (if cross cut)
    if (remainingLength > 0 && desiredWidthCm > 0) {
      const pieceId2 = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      remainingPieces.push({
        id: pieceId2,
        width: desiredWidthCm,
        length: remainingLength / 100, // Convert to meters
        squareMeters: (desiredWidthCm * remainingLength * quantity) / 10000,
        isAvailable: remainingLength > 0,
        sourceCutId: crossCutId || longitudinalCutId || '',
        position: {
          startWidth: 0,
          startLength: desiredLengthCm / 100
        }
      });
    }

    // Piece 3: Corner piece (if both cuts)
    if (remainingWidth > 0 && remainingLength > 0) {
      const pieceId3 = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      remainingPieces.push({
        id: pieceId3,
        width: remainingWidth,
        length: remainingLength / 100, // Convert to meters
        squareMeters: (remainingWidth * remainingLength * quantity) / 10000,
        isAvailable: remainingWidth > 0 && remainingLength > 0,
        sourceCutId: crossCutId || longitudinalCutId || '',
        position: {
          startWidth: desiredWidthCm,
          startLength: desiredLengthCm / 100
        }
      });
    }
  }

  // Create cut details (using the IDs generated above)
  const cutDetails: StoneCut[] = [];

  if (needsLongitudinalCut && cuttingCostPerMeterLongitudinal > 0) {
    cutDetails.push({
      id: longitudinalCutId,
      originalWidth: originalWidthCm,
      cutWidth: desiredWidthCm,
      remainingWidth: originalWidthCm - desiredWidthCm,
      length: effectiveLongitudinalMeters * 100,
      cuttingCost: longitudinalCuttingCost,
      cuttingCostPerMeter: cuttingCostPerMeterLongitudinal
    });
  }

  if (needsCrossCut && cuttingCostPerMeterCross > 0) {
    cutDetails.push({
      id: crossCutId,
      originalWidth: originalLengthCm, // For cross cut, we use length as "width" conceptually
      cutWidth: desiredLengthCm,
      remainingWidth: originalLengthCm - desiredLengthCm,
      length: effectiveCrossMeters * 100,
      cuttingCost: crossCuttingCost,
      cuttingCostPerMeter: cuttingCostPerMeterCross
    });
  }

  return {
    needsLongitudinalCut,
    needsCrossCut,
    totalCuttingCost,
    remainingPieces,
    cutDetails
  };
};

// Helper function to calculate Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… (vertical/perpendicular edge cuts) cost for slab stones
const calculateSlabVerticalCutCost = (data: {
  requestedLengthCm: number;
  requestedWidthCm: number;
  quantity: number;
  verticalCutSides: {
    top: boolean;
    bottom: boolean;
    left: boolean;
    right: boolean;
  };
  verticalCutCostPerMeter: number;
}): number => {
  const {
    requestedLengthCm,
    requestedWidthCm,
    quantity,
    verticalCutSides,
    verticalCutCostPerMeter
  } = data;
  
  // If no cost per meter or no active sides, return 0
  if (verticalCutCostPerMeter <= 0) {
    return 0;
  }
  
  // Calculate total meters for active sides
  let totalMeters = 0;
  
  // Top and bottom sides use width
  if (verticalCutSides.top) {
    totalMeters += requestedWidthCm / 100; // Convert cm to meters
  }
  if (verticalCutSides.bottom) {
    totalMeters += requestedWidthCm / 100;
  }
  
  // Left and right sides use length
  if (verticalCutSides.left) {
    totalMeters += requestedLengthCm / 100; // Convert cm to meters
  }
  if (verticalCutSides.right) {
    totalMeters += requestedLengthCm / 100;
  }
  
  // Calculate total cost: total meters Ã— cost per meter Ã— quantity
  return totalMeters * verticalCutCostPerMeter * quantity;
};

// Slab stone metrics calculation (similar to calculateStoneMetrics but for 2D cutting)
// Now supports multiple standard dimensions
const calculateSlabMetrics = (data: {
  length?: number;
  width?: number;
  quantity?: number;
  squareMeters?: number;
  pricePerSquareMeter?: number;
  lengthUnit?: 'cm' | 'm';
  widthUnit?: 'cm' | 'm';
  isMandatory?: boolean;
  mandatoryPercentage?: number;
  originalLength?: number; // Ø·ÙˆÙ„ Ø§ØµÙ„ÛŒ Ø§Ø³Ù„Ø¨ (legacy single dimension)
  originalWidth?: number; // Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø§Ø³Ù„Ø¨ (legacy single dimension)
  standardDimensions?: SlabStandardDimensionEntry[]; // New: multiple standard dimensions
  cuttingCostPerMeterLongitudinal?: number;
  cuttingCostPerMeterCross?: number;
  slabCuttingMode?: 'perSquareMeter' | 'lineBased';
  slabCuttingPricePerSquareMeter?: number;
  lineCutLongitudinalMeters?: number;
  lineCutCrossMeters?: number;
}) => {
  const {
    length,
    width,
    quantity = 1,
    squareMeters,
    pricePerSquareMeter,
    lengthUnit = 'm',
    widthUnit = 'cm',
    isMandatory = false,
    mandatoryPercentage = 20,
    originalLength = 0,
    originalWidth = 0,
    standardDimensions = [],
    cuttingCostPerMeterLongitudinal = 0,
    cuttingCostPerMeterCross = 0,
    slabCuttingMode = 'lineBased',
    slabCuttingPricePerSquareMeter = 0,
    lineCutLongitudinalMeters,
    lineCutCrossMeters
  } = data;
  
  let calculatedSquareMeters = 0;
  let calculatedLength = 0;
  let calculatedWidth = 0;
  let calculatedTotalPrice = 0;
  let originalTotalPrice = 0;
  
  // Convert dimensions to cm for calculations
  const lengthInCm = length ? (lengthUnit === 'm' ? length * 100 : length) : 0;
  const widthInCm = width ? (widthUnit === 'm' ? width * 100 : width) : 0;
  
  // Scenario 1: We have length and width, calculate square meters
  if (lengthInCm && widthInCm && !squareMeters) {
    calculatedSquareMeters = (lengthInCm * widthInCm * quantity) / 10000; // Convert cmÂ² to mÂ²
  }
  // Scenario 2: We have square meters and width, calculate length
  else if (squareMeters && widthInCm && !length) {
    calculatedLength = (squareMeters * 10000) / (widthInCm * quantity); // Convert mÂ² to cmÂ²
    calculatedLength = lengthUnit === 'm' ? calculatedLength / 100 : calculatedLength;
  }
  // Scenario 3: We have square meters and length, calculate width
  else if (squareMeters && lengthInCm && !width) {
    calculatedWidth = (squareMeters * 10000) / (lengthInCm * quantity); // Convert mÂ² to cmÂ²
    calculatedWidth = widthUnit === 'm' ? calculatedWidth / 100 : calculatedWidth;
  }
  // Scenario 4: We have all dimensions, use provided square meters
  else if (squareMeters) {
    calculatedSquareMeters = squareMeters;
  }
  
  // Calculate total price if we have price per square meter
  if (pricePerSquareMeter && calculatedSquareMeters) {
    // For slabs, pricing is based on original dimensions (like longitudinal stones)
    let pricingSquareMeters = calculatedSquareMeters;
    
    // If we have multiple standard dimensions, calculate pricing for each entry
    if (standardDimensions.length > 0) {
      pricingSquareMeters = standardDimensions.reduce((total, entry) => {
        const entrySqm = (entry.standardLengthCm * entry.standardWidthCm * entry.quantity) / 10000;
        return total + entrySqm;
      }, 0);
    } else if (originalLength > 0 && originalWidth > 0 && lengthInCm > 0 && widthInCm > 0) {
      // Fallback to legacy single dimension calculation
      const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
      const originalWidthCm = widthUnit === 'm' ? originalWidth * 100 : originalWidth;
      pricingSquareMeters = (originalLengthCm * originalWidthCm * quantity) / 10000;
    }
    
    originalTotalPrice = pricingSquareMeters * pricePerSquareMeter;
    
    // Apply mandatory percentage increase if enabled
    if (isMandatory && mandatoryPercentage > 0) {
      calculatedTotalPrice = originalTotalPrice * (1 + mandatoryPercentage / 100);
    } else {
      calculatedTotalPrice = originalTotalPrice;
    }
  }
  
  // Calculate cutting costs (2D: longitudinal + cross)
  let totalCuttingCost = 0;
  if (slabCuttingMode === 'perSquareMeter' && slabCuttingPricePerSquareMeter > 0) {
    const targetSqm = calculatedSquareMeters || ((lengthInCm && widthInCm)
      ? (lengthInCm * widthInCm * quantity) / 10000
      : 0);
    totalCuttingCost = targetSqm * slabCuttingPricePerSquareMeter;
  } else if (lengthInCm > 0 && widthInCm > 0) {
    // If we have multiple standard dimensions, calculate cutting cost for each entry
    if (standardDimensions.length > 0) {
      totalCuttingCost = standardDimensions.reduce((total, entry) => {
        const entryCuttingCost = calculateSlabCuttingCostForEntry({
          standardLengthCm: entry.standardLengthCm,
          standardWidthCm: entry.standardWidthCm,
          requestedLengthCm: lengthInCm,
          requestedWidthCm: widthInCm,
          quantity: entry.quantity,
          cuttingCostPerMeterLongitudinal,
          cuttingCostPerMeterCross,
          lineCutLongitudinalMeters,
          lineCutCrossMeters
        });
        return total + entryCuttingCost;
      }, 0);
    } else if (originalLength > 0 && originalWidth > 0) {
      // Fallback to legacy single dimension calculation
    const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
    const originalWidthCm = widthUnit === 'm' ? originalWidth * 100 : originalWidth;
    
      const longitudinalMeters = lineCutLongitudinalMeters ?? (lengthInCm / 100);
      const crossMeters = lineCutCrossMeters ?? (widthInCm / 100);
      
    if (widthInCm < originalWidthCm && cuttingCostPerMeterLongitudinal > 0) {
        const longitudinalCost = longitudinalMeters * cuttingCostPerMeterLongitudinal * quantity;
      totalCuttingCost += longitudinalCost;
    }
    
    if (lengthInCm < originalLengthCm && cuttingCostPerMeterCross > 0) {
        const crossCost = crossMeters * cuttingCostPerMeterCross * quantity;
      totalCuttingCost += crossCost;
      }
    }
  }
  
  return {
    squareMeters: calculatedSquareMeters,
    length: calculatedLength || length || 0,
    width: calculatedWidth || width || 0,
    totalPrice: calculatedTotalPrice,
    originalTotalPrice: originalTotalPrice,
    cuttingCost: totalCuttingCost
  };
};

// Stair stone calculation utilities
const calculateStairStoneMetrics = (data: {
  treadWidth: number; // Ø·ÙˆÙ„ Ù¾Ù„Ù‡ (cm or m)
  treadWidthUnit: 'cm' | 'm';
  treadDepth: number; // Ø¹Ø±Ø¶ Ù¾Ù„Ù‡ (cm)
  numberOfSteps: number; // ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡
  numberOfLandings?: number; // ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø§Ú¯Ø±Ø¯
  landingWidth?: number; // Ø¹Ø±Ø¶ Ù¾Ø§Ú¯Ø±Ø¯ (cm)
  landingDepth?: number; // Ø¹Ù…Ù‚ Ù¾Ø§Ú¯Ø±Ø¯ (cm)
  numberOfStaircases?: number; // ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù† Ú©Ø§Ù…Ù„ (if quantityType === 'staircases')
  quantityType?: 'steps' | 'staircases';
}) => {
  const {
    treadWidth,
    treadWidthUnit,
    treadDepth,
    numberOfSteps,
    numberOfLandings = 0,
    landingWidth = 0,
    landingDepth = 0,
    numberOfStaircases = 1,
    quantityType = 'steps'
  } = data;
  
  // Convert tread width to cm
  const treadWidthInCm = treadWidthUnit === 'm' ? treadWidth * 100 : treadWidth;
  
  // Calculate area per step (tread width Ã— tread depth)
  const areaPerStep = (treadWidthInCm * treadDepth) / 10000; // Convert cmÂ² to mÂ²
  
  // Calculate total steps based on quantity type
  const totalSteps = quantityType === 'staircases' 
    ? numberOfSteps * numberOfStaircases 
    : numberOfSteps;
  
  // Calculate total area for steps
  const totalStepsArea = areaPerStep * totalSteps;
  
  // Calculate landing area if applicable
  const landingArea = numberOfLandings > 0 && landingWidth > 0 && landingDepth > 0
    ? ((landingWidth * landingDepth) / 10000) * numberOfLandings * (quantityType === 'staircases' ? numberOfStaircases : 1)
    : 0;
  
  // Total area (steps + landings)
  const totalArea = totalStepsArea + landingArea;
  
  // Calculate total linear length (tread width Ã— number of steps)
  const totalLinearLength = (treadWidthInCm / 100) * totalSteps; // Convert cm to meters
  
  return {
    areaPerStep, // Ù…ØªØ± Ù…Ø±Ø¨Ø¹ per step
    totalStepsArea, // Total area for all steps
    landingArea, // Total area for all landings
    totalArea, // Total area (steps + landings)
    totalLinearLength, // Total linear length in meters
    totalSteps // Total number of steps
  };
};

// Calculate nosing cutting cost
const calculateNosingCuttingCost = (data: {
  nosingType: string;
  treadWidth: number; // Ø·ÙˆÙ„ Ù¾Ù„Ù‡ (cm or m)
  treadWidthUnit: 'cm' | 'm';
  numberOfSteps: number;
  numberOfStaircases?: number;
  quantityType?: 'steps' | 'staircases';
}) => {
  const {
    nosingType,
    treadWidth,
    treadWidthUnit,
    numberOfSteps,
    numberOfStaircases = 1,
    quantityType = 'steps'
  } = data;
  
  // Find nosing type
  const nosing = NOSING_TYPES.find(n => n.id === nosingType);
  if (!nosing || nosingType === 'none' || !nosing.cuttingCostPerMeter) {
    return { cuttingCost: 0, cuttingCostPerMeter: 0 };
  }
  
  // Convert tread width to meters
  const treadWidthInMeters = treadWidthUnit === 'm' ? treadWidth : treadWidth / 100;
  
  // Calculate total steps
  const totalSteps = quantityType === 'staircases' 
    ? numberOfSteps * numberOfStaircases 
    : numberOfSteps;
  
  // Calculate total length for nosing (tread width Ã— number of steps)
  const totalLength = treadWidthInMeters * totalSteps;
  
  // Calculate cutting cost
  const cuttingCost = totalLength * nosing.cuttingCostPerMeter;
  
  return {
    cuttingCost,
    cuttingCostPerMeter: nosing.cuttingCostPerMeter
  };
};

// Calculate metrics for Tread (Ú©Ù Ù¾Ù„Ù‡)
const calculateTreadMetrics = (data: {
  treadWidth: number; // Ø·ÙˆÙ„ Ù¾Ù„Ù‡
  treadWidthUnit: 'cm' | 'm';
  treadDepth: number; // Ø¹Ø±Ø¶ Ù¾Ù„Ù‡ (cm)
  quantity: number; // ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡
  quantityType: 'steps' | 'staircases';
  numberOfStaircases?: number;
}) => {
  const { treadWidth, treadWidthUnit, treadDepth, quantity, quantityType, numberOfStaircases = 1 } = data;
  
  // Convert tread width to cm
  const treadWidthInCm = treadWidthUnit === 'm' ? treadWidth * 100 : treadWidth;
  
  // Calculate area per step (tread width Ã— tread depth) in mÂ²
  const areaPerStep = (treadWidthInCm * treadDepth) / 10000;
  
  // Calculate total quantity
  const totalQuantity = quantityType === 'staircases' ? quantity * numberOfStaircases : quantity;
  
  // Calculate total area
  const totalArea = areaPerStep * totalQuantity;
  
  // Calculate total linear length in meters
  const totalLinearLength = (treadWidthInCm / 100) * totalQuantity;
  
  return {
    areaPerStep,
    totalArea,
    totalLinearLength,
    totalQuantity
  };
};

// Calculate metrics for Riser (Ø®ÛŒØ² Ù¾Ù„Ù‡)
const calculateRiserMetrics = (data: {
  treadWidth: number; // Ø·ÙˆÙ„ Ù¾Ù„Ù‡ (for calculating riser area)
  treadWidthUnit: 'cm' | 'm';
  riserHeight: number; // Ø§Ø±ØªÙØ§Ø¹ Ù‚Ø§Ø¦Ù…Ù‡ (cm)
  quantity: number; // ØªØ¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¦Ù…Ù‡
  quantityType: 'steps' | 'staircases';
  numberOfStaircases?: number;
}) => {
  const { treadWidth, treadWidthUnit, riserHeight, quantity, quantityType, numberOfStaircases = 1 } = data;
  
  // Convert tread width to cm
  const treadWidthInCm = treadWidthUnit === 'm' ? treadWidth * 100 : treadWidth;
  
  // Calculate area per riser (tread width Ã— riser height) in mÂ²
  const areaPerRiser = (treadWidthInCm * riserHeight) / 10000;
  
  // Calculate total quantity
  const totalQuantity = quantityType === 'staircases' ? quantity * numberOfStaircases : quantity;
  
  // Calculate total area
  const totalArea = areaPerRiser * totalQuantity;
  
  return {
    areaPerRiser,
    totalArea,
    totalQuantity
  };
};

// Calculate metrics for Landing (Ù¾Ø§Ú¯Ø±Ø¯)
const calculateLandingMetrics = (data: {
  landingWidth: number; // Ø¹Ø±Ø¶ Ù¾Ø§Ú¯Ø±Ø¯ (cm)
  landingDepth: number; // Ø¹Ù…Ù‚ Ù¾Ø§Ú¯Ø±Ø¯ (cm)
  numberOfLandings: number; // ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø§Ú¯Ø±Ø¯
  quantityType: 'steps' | 'staircases';
  numberOfStaircases?: number;
}) => {
  const { landingWidth, landingDepth, numberOfLandings, quantityType, numberOfStaircases = 1 } = data;
  
  // Calculate area per landing in mÂ²
  const areaPerLanding = (landingWidth * landingDepth) / 10000;
  
  // Calculate total quantity
  const totalQuantity = quantityType === 'staircases' 
    ? numberOfLandings * numberOfStaircases 
    : numberOfLandings;
  
  // Calculate total area
  const totalArea = areaPerLanding * totalQuantity;
  
  return {
    areaPerLanding,
    totalArea,
    totalQuantity
  };
};
export default function CreateContractWizard() {
  const router = useRouter();
  
  // Use contract wizard hook for step management
  const {
    currentStep,
    setCurrentStep,
    wizardData,
    setWizardData,
    updateWizardData,
    errors: wizardErrors,
    setErrors: setWizardErrors,
    loading: wizardLoading,
    setLoading: setWizardLoading,
    customerSearchTerm,
    setCustomerSearchTerm,
    productSearchTerm,
    setProductSearchTerm,
    stateRestored,
    setStateRestored,
    restorationAttempted
  } = useContractWizard();
  
  // Use wizard state, but allow local overrides if needed
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  // Stair stepper v2 states are now provided by useStairSystemV2 hook
  const [useStairFlowV2, setUseStairFlowV2] = useState(true); // Feature flag - stays local
  const stairSystemV2 = useStairSystemV2({
    onError: (error) => setErrors({ stairSystem: error })
  });
  
  // Delivery step state is now provided by useDeliverySchedule hook
  const deliverySchedule = useDeliverySchedule(wizardData.products);
  
  // Digital Signature (Step 8) state is now provided by useDigitalSignature hook
  const digitalSignature = useDigitalSignature({
    onError: (error) => setErrors({ verificationCode: error }),
    onSuccess: (message) => console.log(message)
  });
  // All stair system state is now provided by useStairSystemV2 hook

  // getDraftByPart is now provided by useStairSystemV2 hook

  // syncLayerSessionItems is now provided by useStairSystemV2 hook - using local version temporarily for compatibility
  const syncLayerSessionItems_Local = useCallback((items: ContractProduct[]): ContractProduct[] => {
    if (!items.some(item => (item.meta as any)?.isLayer)) {
      return items;
    }

    let changed = false;
    const updated = items.map(item => {
      const isLayer = ((item.meta as any)?.isLayer) || false;
      if (!isLayer) {
        return item;
      }

      const layerInfo = (item.meta as any)?.layerInfo;
      const layerEdges = (item.meta as any)?.layerEdges;
      const parentPartType: StairStepperPart | undefined = layerInfo?.parentPartType;
      if (!layerInfo || !layerEdges || !parentPartType) {
        return item;
      }

      const parentDraft = stairSystemV2.getDraftByPart(parentPartType);
      if (!parentDraft || !parentDraft.quantity) {
        return item;
      }

      const numberOfLayersPerStair = layerInfo.numberOfLayersPerStair || 0;
      if (numberOfLayersPerStair <= 0) {
        return item;
      }

      const tempDraft: StairPartDraftV2 = {
        ...parentDraft,
        layerEdges,
        layerWidthCm: item.width,
        numberOfLayersPerStair,
        quantity: parentDraft.quantity
      };

      const newLayerSqm = computeLayerSqmV2(parentPartType, tempDraft);
      const totalLayers = (parentDraft.quantity || 0) * numberOfLayersPerStair;
      const layerTypeUnitPrice = item.layerTypePrice || 0;
      
      // ğŸ¯ FIX: Calculate layer type cost based on total length per stair Ã— number of stairs Ã— layer type price per meter
      const totalLayerLengthPerStairM = getTotalLayerLengthPerStairM(parentPartType, tempDraft);
      const totalLayerLengthM = totalLayerLengthPerStairM * (parentDraft.quantity || 0);
      const layerTypeCost = totalLayerLengthM * layerTypeUnitPrice;
      
      // ğŸ¯ FIX: Calculate stone area used for pricing (not layer square meters)
      // Get stone dimensions from item
      const stoneWidthCm = item.originalWidth || 0;
      const stoneWidthM = stoneWidthCm / 100;
      const stoneLengthM = getActualLengthMeters(parentDraft);
      const layerWidthCm = item.width || 0;
      
      // Calculate stone area used
      let stoneAreaUsedSqm = 0;
      if (stoneWidthCm > 0 && layerWidthCm > 0 && stoneLengthM > 0) {
        // Calculate how many layers can fit in one stone width
        const layersPerStoneWidth = Math.floor(stoneWidthCm / layerWidthCm);
        if (layersPerStoneWidth > 0) {
          // Calculate how many stones are needed
          const stonesNeeded = Math.ceil(totalLayers / layersPerStoneWidth);
          // Total stone area used
          stoneAreaUsedSqm = stonesNeeded * stoneLengthM * stoneWidthM;
        }
      }
      
      // Use stone area used for pricing, fallback to layer square meters if calculation fails
      const pricingAreaSqm = stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : newLayerSqm;
      const materialCost = pricingAreaSqm * (item.pricePerSquareMeter || 0);
      const newTotalPrice = materialCost + layerTypeCost + (item.cuttingCost || 0);
      const newLengthMeters = getActualLengthMeters(parentDraft);
      const newLengthUnit = parentDraft.lengthUnit || 'm';
      const newLengthValue = convertMetersToUnit(newLengthMeters, newLengthUnit);

      const currentSqm = item.squareMeters || 0;
      const currentTotal = typeof item.totalPrice === 'number' ? item.totalPrice : parseFloat(String(item.totalPrice || 0));

      if (Math.abs(newLayerSqm - currentSqm) < 0.0001 &&
          Math.abs(newTotalPrice - (currentTotal || 0)) < 0.5 &&
          Math.abs((item.length || 0) - newLengthValue) < 0.0001) {
        return item;
      }

      changed = true;
      return {
        ...item,
        squareMeters: newLayerSqm,
        totalPrice: newTotalPrice,
        originalTotalPrice: materialCost, // Use material cost based on stone area used
        quantity: totalLayers,
        length: newLengthValue,
        lengthUnit: newLengthUnit,
        meta: {
          ...item.meta,
          layerInfo: {
            ...layerInfo,
            lastSyncedAt: Date.now()
          },
          // Update stone area used in meta if calculated
          stoneAreaUsedSqm: stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : undefined
        } as any
      };
    });

    return changed ? updated : items;
  }, [stairSystemV2.getDraftByPart]);

  useEffect(() => {
    stairSystemV2.setStairSessionItems(prev => stairSystemV2.syncLayerSessionItems(prev));
  }, [stairSystemV2.syncLayerSessionItems]);

  const hasLayerEdgeSelection = (edges?: StairPartDraftV2['layerEdges']) =>
    !!(edges && (edges.front || edges.left || edges.right || edges.back || edges.perimeter));

  const deriveLayerEdgesFromTools = (
    draft: StairPartDraftV2,
    part: StairStepperPart
  ): StairPartDraftV2 => {
    if (!draft.tools || draft.tools.length === 0) return draft;

    const aggregated = draft.tools.reduce(
      (acc, tool) => ({
        front: acc.front || !!tool.front,
        left: acc.left || !!tool.left,
        right: acc.right || !!tool.right,
        back: acc.back || !!tool.back,
        perimeter: acc.perimeter || !!tool.perimeter
      }),
      { front: false, left: false, right: false, back: false, perimeter: false }
    );

    if (part !== 'landing') {
      aggregated.back = false;
      aggregated.perimeter = false;
    }

    const hasEdges =
      aggregated.front || aggregated.left || aggregated.right || aggregated.back || aggregated.perimeter;

    if (!hasEdges) return draft;

    const layerEdges = aggregated.perimeter
      ? { front: false, left: false, right: false, back: false, perimeter: true }
      : {
          front: aggregated.front,
          left: aggregated.left,
          right: aggregated.right,
          back: part === 'landing' ? aggregated.back : false,
          perimeter: false
        };

    return { ...draft, layerEdges };
  };

  // Layer types loading is now handled by useStairSystemV2 hook

  // Ensure stair drafts always use original product thickness (Ù‚Ø·Ø±)
  // Thickness sync effects are now handled by useStairSystemV2 hook

  // stairSystemV2.ensureStairSessionId is now provided by useStairSystemV2 hook

  const getActiveDraft = (): [StairPartDraftV2, (d: StairPartDraftV2) => void] => {
    if (stairSystemV2.stairActivePart === 'tread') return [stairSystemV2.draftTread, stairSystemV2.setDraftTread];
    if (stairSystemV2.stairActivePart === 'riser') return [stairSystemV2.draftRiser, stairSystemV2.setDraftRiser];
    return [stairSystemV2.draftLanding, stairSystemV2.setDraftLanding];
  };

  const getPartDisplayLabel = (part: StairStepperPart): string => {
    if (part === 'tread') return 'Ú©Ù Ù¾Ù„Ù‡';
    if (part === 'riser') return 'Ø®ÛŒØ² Ù¾Ù„Ù‡';
    return 'Ù¾Ø§Ú¯Ø±Ø¯';
  };

  const getProductCuttingCost = (product: ContractProduct): number => {
    if (product.cuttingBreakdown && product.cuttingBreakdown.length > 0) {
      return product.cuttingBreakdown.reduce((sum, entry) => sum + (entry.cost || 0), 0);
    }
    return product.isCut ? product.cuttingCost || 0 : 0;
  };

  const getProductServiceCost = (product: ContractProduct): number => {
    const toolCost = product.totalSubServiceCost || 0;
    const cuttingCost = getProductCuttingCost(product);
    return toolCost + cuttingCost;
  };

  // ğŸ¯ Comprehensive validation function for numeric inputs based on product data
  const validateDraftNumericFields = (part: StairStepperPart, draft: StairPartDraftV2, field: keyof StairDraftFieldErrors, value: number | null): string | null => {
    const partLabel = getPartDisplayLabel(part);
    const product = draft.stoneProduct;
    
    if (!product) {
      return null; // Product selection validation is handled separately
    }

    const originalWidthCm = product.widthValue || 0;
    const originalThicknessCm = product.thicknessValue || 0;

    switch (field) {
      case 'length': {
        const hasStandardLength = getDraftStandardLengthMeters(draft) > 0;
        if (value === null || value === undefined || value <= 0) {
          if (!hasStandardLength) {
            return `Ù„Ø·ÙØ§Ù‹ Ø·ÙˆÙ„ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ${partLabel} ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯`;
          }
          return null;
        }
        if (value > 1000) { // Reasonable max: 10 meters or 1000 cm
          const unit = draft.lengthUnit || 'm';
          const maxValue = unit === 'm' ? 10 : 1000;
          return `Ø·ÙˆÙ„ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ${maxValue} ${unit === 'm' ? 'Ù…ØªØ±' : 'Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±'} Ø¨Ø§Ø´Ø¯`;
        }
        return null;
      }

      case 'width':
        if (value === null || value === undefined) {
          return `Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ${partLabel} ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯`;
        }
        if (value <= 0) {
          return `Ø¹Ø±Ø¶ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯`;
        }
        if (originalWidthCm > 0 && value > originalWidthCm) {
          return `Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ (${formatDisplayNumber(value)}cm) Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø³Ù†Ú¯ (${formatDisplayNumber(originalWidthCm)}cm) Ø¨Ø§Ø´Ø¯`;
        }
        if (value < 1) {
          return `Ø¹Ø±Ø¶ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 1 Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± Ø¨Ø§Ø´Ø¯`;
        }
        return null;

      case 'quantity':
        if (value === null || value === undefined) {
          return `Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ${partLabel} ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯`;
        }
        if (value <= 0) {
          return `ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯`;
        }
        if (!Number.isInteger(value)) {
          return `ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­ Ø¨Ø§Ø´Ø¯`;
        }
        if (value > 10000) {
          return `ØªØ¹Ø¯Ø§Ø¯ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 10,000 Ø¹Ø¯Ø¯ Ø¨Ø§Ø´Ø¯`;
        }
        return null;

      case 'pricePerSquareMeter':
        if (value === null || value === undefined) {
          return `Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ${partLabel} ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯`;
        }
        if (value <= 0) {
          return `Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯`;
        }
        if (value > 100000000) { // Reasonable max: 100 million Toman per sqm
          return `Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 100,000,000 ØªÙˆÙ…Ø§Ù† Ø¨Ø§Ø´Ø¯`;
        }
        return null;

      case 'layerStonePrice':
        if (value === null || value === undefined) {
          return 'Ù„Ø·ÙØ§Ù‹ Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ù„Ø§ÛŒÙ‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯';
        }
        if (value <= 0) {
          return 'Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ù„Ø§ÛŒÙ‡ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯';
        }
        if (value > 100000000) {
          return 'Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ù„Ø§ÛŒÙ‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 100,000,000 ØªÙˆÙ…Ø§Ù† Ø¨Ø§Ø´Ø¯';
        }
        return null;

      case 'layerMandatoryPercentage':
        if (value === null || value === undefined) {
          return 'Ù„Ø·ÙØ§Ù‹ Ø¯Ø±ØµØ¯ Ø­Ú©Ù…ÛŒ Ù„Ø§ÛŒÙ‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯';
        }
        if (value < 0) {
          return 'Ø¯Ø±ØµØ¯ Ø­Ú©Ù…ÛŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ù…ØªØ± Ø§Ø² 0 Ø¨Ø§Ø´Ø¯';
        }
        if (value > 100) {
          return 'Ø¯Ø±ØµØ¯ Ø­Ú©Ù…ÛŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 100 Ø¨Ø§Ø´Ø¯';
        }
        return null;

      case 'mandatoryPercentage':
        if (value === null || value === undefined) {
          return `Ù„Ø·ÙØ§Ù‹ Ø¯Ø±ØµØ¯ Ø­Ú©Ù…ÛŒ ${partLabel} Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯`;
        }
        if (value < 0) {
          return 'Ø¯Ø±ØµØ¯ Ø­Ú©Ù…ÛŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ù…ØªØ± Ø§Ø² 0 Ø¨Ø§Ø´Ø¯';
        }
        if (value > 100) {
          return 'Ø¯Ø±ØµØ¯ Ø­Ú©Ù…ÛŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 100 Ø¨Ø§Ø´Ø¯';
        }
        return null;

      case 'thickness':
        // Thickness is auto-set from product, but validate it matches
        if (originalThicknessCm > 0) {
          const currentThickness = draft.thicknessCm ?? 0;
          if (Math.abs(currentThickness - originalThicknessCm) > 0.01) {
            return `Ù‚Ø·Ø± Ø¨Ø§ÛŒØ¯ Ø¨Ø§ Ù‚Ø·Ø± Ù…Ø­ØµÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ (${formatDisplayNumber(originalThicknessCm)}cm) Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯`;
          }
        }
        return null;

      default:
        return null;
    }
  };

  const validateDraftRequiredFields = (part: StairStepperPart, draft: StairPartDraftV2): StairDraftFieldErrors => {
    const partLabel = getPartDisplayLabel(part);
    const errors: StairDraftFieldErrors = {};

    if (!draft.stoneId || !draft.stoneProduct) {
      errors.thickness = `Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ù…Ø­ØµÙˆÙ„ ${partLabel} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯`;
      return errors; // Can't validate other fields without product
    }

    // Validate each field using the comprehensive validation function
    const lengthError = validateDraftNumericFields(part, draft, 'length', draft.lengthValue ?? null);
    if (lengthError) errors.length = lengthError;

    const widthError = validateDraftNumericFields(part, draft, 'width', draft.widthCm ?? null);
    if (widthError) errors.width = widthError;

    const quantityError = validateDraftNumericFields(part, draft, 'quantity', draft.quantity ?? null);
    if (quantityError) errors.quantity = quantityError;

    const priceError = validateDraftNumericFields(part, draft, 'pricePerSquareMeter', draft.pricePerSquareMeter ?? null);
    if (priceError) errors.pricePerSquareMeter = priceError;

    const thicknessError = validateDraftNumericFields(part, draft, 'thickness', draft.thicknessCm ?? null);
    if (thicknessError) errors.thickness = thicknessError;

    const mandatoryDefault = part === 'riser' || part === 'landing';
    const shouldValidateMandatory = draft.useMandatory ?? mandatoryDefault;
    if (shouldValidateMandatory) {
      const mandatoryError = validateDraftNumericFields(part, draft, 'mandatoryPercentage', draft.mandatoryPercentage ?? 20);
      if (mandatoryError) {
        errors.mandatoryPercentage = mandatoryError;
      }
    }

    if (draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && stairSystemV2.layerTypes.length > 0 && !draft.layerTypeId) {
      errors.layerType = 'Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯';
    }

    if (draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && draft.layerUseDifferentStone) {
      if (!draft.layerStoneProduct || !draft.layerStoneProductId) {
        errors.layerStone = 'Ù„Ø·ÙØ§Ù‹ Ø³Ù†Ú¯ Ù…ÙˆØ±Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯';
      }
      const layerPriceError = validateDraftNumericFields(part, draft, 'layerStonePrice', draft.layerPricePerSquareMeter ?? null);
      if (layerPriceError) {
        errors.layerStonePrice = layerPriceError;
      }
      if (draft.layerUseMandatory !== false) {
        const mandatoryError = validateDraftNumericFields(part, draft, 'layerMandatoryPercentage', draft.layerMandatoryPercentage ?? null);
        if (mandatoryError) {
          errors.layerMandatoryPercentage = mandatoryError;
        }
      }
    }

    return errors;
  };

  const clearDraftFieldError = (part: StairStepperPart, field: keyof StairDraftFieldErrors) => {
    stairSystemV2.setStairDraftErrors(prev => ({
      ...prev,
      [part]: {
        ...prev[part],
        [field]: undefined
      }
    }));
    setErrors(prev => {
      if (!prev.products) return prev;
      const { products, ...rest } = prev;
      return rest;
    });
  };

  const calculateStairStoneUsage = (draft: StairPartDraftV2) => {
    const originalWidthCm = draft.stoneProduct?.widthValue || 0;
    const userWidthCm = draft.widthCm || 0;
    const quantity = draft.quantity || 0;

    let piecesPerStone = 1;
    let leftoverWidthCm = 0;

    if (originalWidthCm > 0 && userWidthCm > 0) {
      piecesPerStone = Math.max(1, Math.floor(originalWidthCm / userWidthCm));
      leftoverWidthCm = Math.max(0, originalWidthCm - piecesPerStone * userWidthCm);
    }

    const baseStoneQuantity = piecesPerStone > 0 ? Math.ceil(quantity / piecesPerStone) : quantity;

    return {
      originalWidthCm,
      userWidthCm,
      quantity,
      piecesPerStone,
      leftoverWidthCm,
      baseStoneQuantity
    };
  };

  const toMeters = (value: number | null | undefined, unit: UnitType): number => {
    if (!value || value <= 0) return 0;
    return unit === 'm' ? value : value / 100;
  };

  const convertMetersToUnit = (value: number, unit: UnitType): number => {
    if (!value || value <= 0) return 0;
    return unit === 'm' ? value : value * 100;
  };

  const getDraftStandardLengthMeters = (draft: StairPartDraftV2): number => {
    const value = draft.standardLengthValue;
    if (value && value > 0) {
      const unit = draft.standardLengthUnit || draft.lengthUnit || 'm';
      return toMeters(value, unit);
    }
    return 0;
  };

  const getActualLengthMeters = (draft: StairPartDraftV2): number => {
    const manualLength = toMeters(draft.lengthValue || 0, draft.lengthUnit || 'cm');
    if (manualLength > 0) {
      return manualLength;
    }
    const standardLength = getDraftStandardLengthMeters(draft);
    return standardLength > 0 ? standardLength : 0;
  };

  const getPricingLengthMeters = (draft: StairPartDraftV2): number => {
    const standardLength = getDraftStandardLengthMeters(draft);
    const actualLength = getActualLengthMeters(draft);
    if (standardLength > 0) {
      if (actualLength > 0 && Math.abs(standardLength - actualLength) < 0.000001) {
        return actualLength;
      }
      return standardLength;
    }
    return actualLength;
  };

  const hasLengthMeasurement = (draft: StairPartDraftV2): boolean => {
    if (draft.lengthValue && draft.lengthValue > 0) return true;
    return getDraftStandardLengthMeters(draft) > 0;
  };

  const computeSqmV2 = (draft: StairPartDraftV2): number => {
    const lengthM = getActualLengthMeters(draft);
    const widthM = (draft.widthCm || 0) / 100;
    const qty = draft.quantity || 0;
    const sqm = lengthM * widthM * qty;
    return Number.isFinite(sqm) ? sqm : 0;
  };

const getLayerStoneProductForDraft = (draft: StairPartDraftV2, fallback: Product | null): Product | null => {
  if (draft.layerUseDifferentStone && draft.layerStoneProduct) {
    return draft.layerStoneProduct;
  }
  return fallback;
};

const getLayerBasePricePerSquareMeter = (draft: StairPartDraftV2): number => {
  if (draft.layerUseDifferentStone) {
    return draft.layerPricePerSquareMeter || 0;
  }
  return draft.pricePerSquareMeter || 0;
};

const getLayerEffectivePricePerSquareMeter = (draft: StairPartDraftV2): number => {
  const base = getLayerBasePricePerSquareMeter(draft);
  if (draft.layerUseDifferentStone && draft.layerUseMandatory && draft.layerMandatoryPercentage && draft.layerMandatoryPercentage > 0) {
    return base * (1 + draft.layerMandatoryPercentage / 100);
  }
  return base;
};

const normalizeLayerAltStoneSettings = (draft: StairPartDraftV2): StairPartDraftV2 => {
  if (!draft.layerUseDifferentStone) {
    return {
      ...draft,
      layerPricePerSquareMeter: draft.pricePerSquareMeter ?? draft.layerPricePerSquareMeter ?? null,
      layerUseMandatory: undefined,
      layerMandatoryPercentage: null
    };
  }
  const normalized = { ...draft };
  if (!normalized.layerPricePerSquareMeter || normalized.layerPricePerSquareMeter <= 0) {
    normalized.layerPricePerSquareMeter = draft.layerPricePerSquareMeter || draft.pricePerSquareMeter || 0;
  }
  normalized.layerUseMandatory = normalized.layerUseMandatory ?? true;
  normalized.layerMandatoryPercentage = normalized.layerMandatoryPercentage ?? 20;
  return normalized;
};

  const computeToolMetersForTool = (part: StairStepperPart, draft: StairPartDraftV2, tool: ToolSelectionV2): number => {
    const lengthM = getActualLengthMeters(draft);
    const widthM = (draft.widthCm || 0) / 100;
    const qty = draft.quantity || 0;
    let meters = 0;
    const t = tool;
    if (part === 'landing') {
      if (t.perimeter) meters += 2 * (lengthM + widthM);
      else {
        if (t.front) meters += widthM;
        if (t.back) meters += widthM;
        if (t.left) meters += lengthM;
        if (t.right) meters += lengthM;
      }
    } else {
      if (t.front) meters += widthM;
      if (t.left) meters += lengthM;
      if (t.right) meters += lengthM;
    }
    return meters * qty;
  };

  const computeToolsMetersV2 = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.tools || draft.tools.length === 0) return 0;
    return draft.tools.reduce((sum, tool) => sum + computeToolMetersForTool(part, draft, tool), 0);
  };

  // ğŸ¯ Calculate total layer length per stair (sum of all selected edge lengths)
  // This is used for layer type cost calculation: total length per stair Ã— number of stairs Ã— layer type price per meter
  // Example: front (0.26m) + left (1.22m) = 1.48m per stair
  const getTotalLayerLengthPerStairM = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.layerEdges || !draft.layerWidthCm) {
      return 0;
    }
    
    const stairLengthM = getActualLengthMeters(draft);
    const stairWidthM = (draft.widthCm || 0) / 100;
    const layerWidthCm = draft.layerWidthCm || 0;
    const layerWidthM = layerWidthCm / 100;
    const edges = draft.layerEdges;
    
    let totalLengthM = 0;
    
    if (part === 'landing') {
      if (edges.perimeter) {
        // Perimeter: 2 Ã— (length + width)
        totalLengthM = 2 * (stairLengthM + stairWidthM);
      } else {
        // ğŸ¯ Account for overlap when multiple edges are selected
        const hasFrontOrBack = edges.front || edges.back;
        const hasLeftOrRight = edges.left || edges.right;
        
        // Front/back layers: if left/right is also selected, reduce length by layerWidth
        const frontBackLengthM = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
        if (edges.front) totalLengthM += frontBackLengthM;
        if (edges.back) totalLengthM += frontBackLengthM;
        
        // Left/right layers: if front/back is also selected, reduce length by layerWidth
        const leftRightLengthM = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;
        if (edges.left) totalLengthM += leftRightLengthM;
        if (edges.right) totalLengthM += leftRightLengthM;
      }
    } else {
      if (edges.front) {
        totalLengthM += stairLengthM;
      }

      const sideLengthM = edges.front ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
      if (edges.left) totalLengthM += sideLengthM;
      if (edges.right) totalLengthM += sideLengthM;
    }
    
    return totalLengthM;
  };

  // ğŸ¯ Calculate maximum layer length needed based on selected edges
  // This is used for stone usage calculation to ensure we have enough stone for all layer types
  // Returns the maximum length among all selected edge types
  const getMaxLayerLengthM = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.layerEdges || !draft.layerWidthCm) {
      return 0;
    }
    
    const stairLengthM = getActualLengthMeters(draft);
    const stairWidthM = (draft.widthCm || 0) / 100;
    const layerWidthCm = draft.layerWidthCm || 0;
    const layerWidthM = layerWidthCm / 100;
    const edges = draft.layerEdges;
    
    let maxLengthM = 0;
    
    if (part === 'landing') {
      if (edges.perimeter) {
        // Perimeter uses both length and width, so max is the longer dimension
        maxLengthM = Math.max(stairLengthM, stairWidthM);
      } else {
        // Check front/back layers
        if (edges.front || edges.back) {
          const hasLeftOrRight = edges.left || edges.right;
          const frontBackLengthM = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
          maxLengthM = Math.max(maxLengthM, frontBackLengthM);
        }
        // Check left/right layers
        if (edges.left || edges.right) {
          const hasFrontOrBack = edges.front || edges.back;
          const leftRightLengthM = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;
          maxLengthM = Math.max(maxLengthM, leftRightLengthM);
        }
      }
    } else {
      if (edges.front) {
        maxLengthM = Math.max(maxLengthM, stairLengthM);
      }
      
      if (edges.left || edges.right) {
        const sideLengthM = edges.front ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
        maxLengthM = Math.max(maxLengthM, sideLengthM);
      }
    }
    
    return maxLengthM;
  };

  // ğŸ¯ Calculate layer square meters based on selected edges
  // ğŸ¯ FIX: Account for overlap when multiple edges are selected
  // When front and left/right are both selected, front layer length should be reduced by layerWidth
  // Example: stairWidth = 0.31m, layerWidth = 0.05m, stairLength = 1.22m
  // - Front layer: (0.31 - 0.05) Ã— 0.05 = 0.26 Ã— 0.05 (reduced because left layer overlaps)
  // - Left layer: 1.22 Ã— 0.05 (full length)
  const computeLayerSqmV2 = (part: StairStepperPart, draft: StairPartDraftV2): number => {
    if (!draft.layerEdges || !draft.layerWidthCm || !draft.numberOfLayersPerStair || !draft.quantity) {
      return 0;
    }
    
    const stairLengthM = getActualLengthMeters(draft);
    const stairWidthM = (draft.widthCm || 0) / 100;
    const layerWidthCm = draft.layerWidthCm || 0;
    const layerWidthM = layerWidthCm / 100;
    const edges = draft.layerEdges;
    
    // Calculate square meters for each selected edge
    let layerSqmPerStair = 0;
    
    if (part === 'landing') {
      if (edges.perimeter) {
        // Perimeter: 2 Ã— (length + width) Ã— layerWidth
        layerSqmPerStair = 2 * (stairLengthM + stairWidthM) * layerWidthM;
      } else {
        // ğŸ¯ FIX: Account for overlap when front/back and left/right are both selected
        const hasFrontOrBack = edges.front || edges.back;
        const hasLeftOrRight = edges.left || edges.right;
        
        // Front/back layers: if left/right is also selected, reduce length by layerWidth
        const frontBackLengthM = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
        if (edges.front) layerSqmPerStair += frontBackLengthM * layerWidthM;
        if (edges.back) layerSqmPerStair += frontBackLengthM * layerWidthM;
        
        // Left/right layers: if front/back is also selected, reduce length by layerWidth
        const leftRightLengthM = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;
        if (edges.left) layerSqmPerStair += leftRightLengthM * layerWidthM;
        if (edges.right) layerSqmPerStair += leftRightLengthM * layerWidthM;
      }
    } else {
      if (edges.front) {
        layerSqmPerStair += stairLengthM * layerWidthM;
      }

      const sideLengthM = edges.front ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
      if (edges.left) layerSqmPerStair += sideLengthM * layerWidthM;
      if (edges.right) layerSqmPerStair += sideLengthM * layerWidthM;
    }
    
    // Total square meters = per stair Ã— numberOfLayersPerStair Ã— quantity
    return layerSqmPerStair * draft.numberOfLayersPerStair * draft.quantity;
  };

type LayerEdgeDemand = {
  edge: 'front' | 'back' | 'left' | 'right' | 'perimeter';
  layersNeeded: number;
  lengthM: number;
};

const getLayerEdgeDemands = (part: StairStepperPart, draft: StairPartDraftV2): LayerEdgeDemand[] => {
  if (!draft.layerEdges || !draft.numberOfLayersPerStair || !draft.quantity || !draft.layerWidthCm) {
    return [];
  }

  const stairLengthM = getActualLengthMeters(draft);
  const stairWidthM = (draft.widthCm || 0) / 100;
  const layerWidthM = (draft.layerWidthCm || 0) / 100;
  if (stairLengthM <= 0 || stairWidthM <= 0 || layerWidthM <= 0) {
    return [];
  }

  const edges = draft.layerEdges;
  const baseLayersPerEdge = draft.quantity * draft.numberOfLayersPerStair;
  const demands: LayerEdgeDemand[] = [];

  if (part === 'landing') {
    if (edges.perimeter) {
      const perimeterLength = 2 * (stairLengthM + stairWidthM);
      if (perimeterLength > 0) {
        demands.push({
          edge: 'perimeter',
          layersNeeded: baseLayersPerEdge,
          lengthM: perimeterLength
        });
      }
      return demands;
    }

    const hasFrontOrBack = edges.front || edges.back;
    const hasLeftOrRight = edges.left || edges.right;
    const frontBackLength = hasLeftOrRight ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
    const leftRightLength = hasFrontOrBack ? Math.max(0, stairLengthM - layerWidthM) : stairLengthM;

    if (edges.front && frontBackLength > 0) {
      demands.push({ edge: 'front', layersNeeded: baseLayersPerEdge, lengthM: frontBackLength });
    }
    if (edges.back && frontBackLength > 0) {
      demands.push({ edge: 'back', layersNeeded: baseLayersPerEdge, lengthM: frontBackLength });
    }
    if (edges.left && leftRightLength > 0) {
      demands.push({ edge: 'left', layersNeeded: baseLayersPerEdge, lengthM: leftRightLength });
    }
    if (edges.right && leftRightLength > 0) {
      demands.push({ edge: 'right', layersNeeded: baseLayersPerEdge, lengthM: leftRightLength });
    }
    return demands;
  }

  if (edges.front && stairLengthM > 0) {
    demands.push({ edge: 'front', layersNeeded: baseLayersPerEdge, lengthM: stairLengthM });
  }
    const hasFront = edges.front;
    const sideLength = hasFront ? Math.max(0, stairWidthM - layerWidthM) : stairWidthM;
    if (edges.left && sideLength > 0) {
      demands.push({ edge: 'left', layersNeeded: baseLayersPerEdge, lengthM: sideLength });
    }
    if (edges.right && sideLength > 0) {
      demands.push({ edge: 'right', layersNeeded: baseLayersPerEdge, lengthM: sideLength });
    }

  return demands;
  };

  // ============================================================================
  // ğŸ¯ LAYER PRODUCT HELPER FUNCTIONS - Refactored for clarity and reliability
  // ============================================================================
  
  /**
   * Find an existing layer product with the same configuration
   * Same configuration = same parent part, same edges, same dimensions, same layers per stair
   */
  const findExistingLayerProduct = (
    sessionItems: ContractProduct[],
    draft: StairPartDraftV2,
    parentPartType: StairStepperPart
  ): ContractProduct | null => {
    if (!draft.layerEdges || !draft.layerWidthCm || !draft.numberOfLayersPerStair) {
      return null;
    }
    
    return sessionItems.find(item => {
      const itemIsLayer = ((item.meta as any)?.isLayer) || false;
      if (!itemIsLayer) return false;
      
      const itemLayerInfo = (item.meta as any)?.layerInfo;
      const itemLayerEdges = (item.meta as any)?.layerEdges;
      
      // Check if same parent part
      if (itemLayerInfo?.parentPartType !== parentPartType) return false;
      
      // Check if same edges configuration (exact match)
      const edgesMatch = 
        (itemLayerEdges?.front || false) === (draft.layerEdges?.front || false) &&
        (itemLayerEdges?.left || false) === (draft.layerEdges?.left || false) &&
        (itemLayerEdges?.right || false) === (draft.layerEdges?.right || false) &&
        (itemLayerEdges?.back || false) === (draft.layerEdges?.back || false) &&
        (itemLayerEdges?.perimeter || false) === (draft.layerEdges?.perimeter || false);
      
      if (!edgesMatch) return false;

      const itemLayerTypeId = ((item.meta as any)?.layerType)?.id || item.layerTypeId || null;
      const draftLayerTypeId = draft.layerTypeId || null;
      if ((itemLayerTypeId || null) !== (draftLayerTypeId || null)) return false;

      const itemAltStoneMeta = (item.meta as any)?.layerAltStone;
      const itemAltStoneId = item.layerUseDifferentStone ? (item.layerStoneProductId || itemAltStoneMeta?.id || item.productId) : null;
      const draftAltStoneId = draft.layerUseDifferentStone
        ? (draft.layerStoneProductId || draft.layerStoneProduct?.id || null)
        : null;
      if (!!item.layerUseDifferentStone !== !!draft.layerUseDifferentStone) return false;
      if (item.layerUseDifferentStone && itemAltStoneId !== draftAltStoneId) return false;
      const itemLayerBasePrice = item.layerUseDifferentStone
        ? (item.layerStoneBasePricePerSquareMeter || item.layerStonePricePerSquareMeter || 0)
        : (item.pricePerSquareMeter || 0);
      const draftLayerBasePrice = draft.layerUseDifferentStone
        ? (draft.layerPricePerSquareMeter || 0)
        : (draft.pricePerSquareMeter || 0);
      if (Math.abs(itemLayerBasePrice - draftLayerBasePrice) > 0.0001) return false;
      const itemMandatoryFlag = item.layerUseDifferentStone ? (item.layerUseMandatory ?? true) : false;
      const draftMandatoryFlag = draft.layerUseDifferentStone ? (draft.layerUseMandatory ?? true) : false;
      if (itemMandatoryFlag !== draftMandatoryFlag) return false;
      if (itemMandatoryFlag && draftMandatoryFlag) {
        const itemMandatoryPercent = item.layerMandatoryPercentage ?? 0;
        const draftMandatoryPercent = draft.layerMandatoryPercentage ?? 0;
        if (Math.abs(itemMandatoryPercent - draftMandatoryPercent) > 0.0001) return false;
      }
      
      // Check if same dimensions (with tolerance for floating point)
      const widthTolerance = 0.01; // 0.01cm tolerance
      if (Math.abs(item.width - (draft.layerWidthCm || 0)) > widthTolerance) return false;
      
      // Check length (convert to same unit for comparison)
      const itemLengthInDraftUnit = item.lengthUnit === draft.lengthUnit 
        ? item.length 
        : (item.lengthUnit === 'm' ? item.length * 100 : item.length / 100);
      const lengthTolerance = draft.lengthUnit === 'm' ? 0.001 : 0.1; // 0.001m or 0.1cm
      const draftLengthForComparison = convertMetersToUnit(getActualLengthMeters(draft), draft.lengthUnit || 'm');
      if (Math.abs(itemLengthInDraftUnit - draftLengthForComparison) > lengthTolerance) return false;
      
      // Check if same number of layers per stair
      if (itemLayerInfo?.numberOfLayersPerStair !== draft.numberOfLayersPerStair) return false;
      
      return true;
    }) || null;
  };
  
  /**
   * Collect all available remaining stones from all stair parts in session
   * Excludes already used remaining stones
   */
  const collectAvailableRemainingStones = (
    sessionItems: ContractProduct[],
    currentProductRemainingStones: RemainingStone[]
  ): RemainingStone[] => {
    const allAvailable: RemainingStone[] = [];
    
    // Collect from all non-layer stair parts in session
    sessionItems.forEach(item => {
      const itemIsLayer = ((item.meta as any)?.isLayer) || false;
      if (!itemIsLayer && item.remainingStones && item.remainingStones.length > 0) {
        // Get remaining stones that haven't been used yet
        const usedRemainingStones = item.usedRemainingStones || [];
        const usedRemainingStoneIds = new Set(usedRemainingStones.map(rs => rs.id));
        
        item.remainingStones.forEach(rs => {
          // Only include if not already used
          if (!usedRemainingStoneIds.has(rs.id)) {
            allAvailable.push(rs);
          }
        });
      }
    });
    
    // Also include remaining stones from the current stair part
    currentProductRemainingStones.forEach(rs => {
      allAvailable.push(rs);
    });
    
    return allAvailable;
  };
  
  /**
   * Calculate layer metrics: how many layers from remaining stones vs new stones,
   * cutting costs, and used remaining stones
   */
  const calculateLayerMetrics = (params: {
    totalLayers: number;
    layerWidthCm: number;
    layerLengthM: number;
    availableRemainingStones: RemainingStone[];
    cuttingCostPerMeter: number;
    edgeDemands?: LayerEdgeDemand[];
  }): {
    layersFromRemainingStones: number;
    layersFromNewStones: number;
    totalLayerCuttingCost: number;
    usedRemainingStonesForLayers: RemainingStone[];
    layerCutDetails: StoneCut[];
    layerRemainingPieces?: RemainingStone[];
    squareMetersFromRemaining?: number;
    squareMetersFromNew?: number;
    totalLayerDemand?: number;
    unfulfilledDemands?: Array<{ edge: LayerEdgeDemand['edge']; lengthM: number; quantity: number }>;
  } => {
    const {
      totalLayers,
      layerWidthCm,
      layerLengthM,
      availableRemainingStones,
      edgeDemands
    } = params;
    
    if (layerWidthCm <= 0) {
      return {
        layersFromRemainingStones: 0,
        layersFromNewStones: totalLayers,
        totalLayerCuttingCost: 0,
        usedRemainingStonesForLayers: [],
        layerCutDetails: [],
        layerRemainingPieces: [],
        squareMetersFromRemaining: 0,
        squareMetersFromNew: 0,
        totalLayerDemand: totalLayers
      };
    }

    const widthMeters = layerWidthCm / 100;
    const fallbackLength = layerLengthM > 0
      ? layerLengthM 
      : (availableRemainingStones[0]?.length || 0);

    const demands = (edgeDemands && edgeDemands.length)
      ? edgeDemands.filter(d => d.lengthM > 0 && d.layersNeeded > 0)
      : [{
          edge: 'front' as const,
          layersNeeded: Math.max(totalLayers, 0),
          lengthM: fallbackLength
        }];

    if (!demands.length) {
      return {
        layersFromRemainingStones: 0,
        layersFromNewStones: totalLayers,
        totalLayerCuttingCost: 0,
        usedRemainingStonesForLayers: [],
        layerCutDetails: [],
        layerRemainingPieces: [],
        squareMetersFromRemaining: 0,
        squareMetersFromNew: 0,
        totalLayerDemand: totalLayers
      };
    }

    const edgePriority: Record<LayerEdgeDemand['edge'], number> = {
      front: 0,
      back: 1,
      left: 2,
      right: 3,
      perimeter: 4
    };

    const sortedDemands = [...demands].sort(
      (a, b) => edgePriority[a.edge] - edgePriority[b.edge]
    );

    type LayerColumn = {
      id: string;
      source: RemainingStone;
      lengthRemaining: number;
      originalLength: number;
    };

    const columns: LayerColumn[] = [];
    const residualWidthPieces: RemainingStone[] = [];

    availableRemainingStones.forEach(stone => {
      const quantity = stone.quantity && stone.quantity > 0 ? stone.quantity : 1;
      const columnsPerStone = Math.floor(stone.width / layerWidthCm);
      const stoneLength = stone.length || 0;
      if (columnsPerStone <= 0 || stoneLength <= 0) {
        return;
      }

      for (let q = 0; q < quantity; q++) {
        for (let col = 0; col < columnsPerStone; col++) {
          columns.push({
            id: `${stone.id}_col_${q}_${col}`,
            source: stone,
            lengthRemaining: stoneLength,
            originalLength: stoneLength
          });
        }
      }

      const leftoverWidth = stone.width - (columnsPerStone * layerWidthCm);
      if (leftoverWidth > 0) {
        residualWidthPieces.push({
          id: `layer_width_leftover_${stone.id}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
          width: leftoverWidth,
          length: stoneLength,
          squareMeters: (leftoverWidth / 100) * stoneLength,
          isAvailable: true,
          sourceCutId: stone.sourceCutId || stone.id,
          quantity: quantity
        });
      }
    });

    if (columns.length === 0) {
      return {
        layersFromRemainingStones: 0,
        layersFromNewStones: demands.reduce((sum, d) => sum + d.layersNeeded, 0),
        totalLayerCuttingCost: 0,
        usedRemainingStonesForLayers: [],
        layerCutDetails: [],
        layerRemainingPieces: residualWidthPieces,
        squareMetersFromRemaining: 0,
        squareMetersFromNew: demands.reduce((sum, d) => sum + d.layersNeeded * d.lengthM * widthMeters, 0),
        totalLayerDemand: demands.reduce((sum, d) => sum + d.layersNeeded, 0)
      };
    }

    let layersFromRemainingStones = 0;
    let totalLayerDemand = 0;
    let squareMetersFromRemaining = 0;
    let squareMetersFromNew = 0;
    const usageEntries: { source: RemainingStone; lengthM: number; quantity: number }[] = [];
    const unfulfilledDemands: Array<{ edge: LayerEdgeDemand['edge']; lengthM: number; quantity: number }> = [];

    const canUseRemainingForEdge = (edge: LayerEdgeDemand['edge']) =>
      edge === 'front' || edge === 'back' || edge === 'perimeter';

    sortedDemands.forEach(demand => {
      let needed = demand.layersNeeded;
      totalLayerDemand += demand.layersNeeded;

      if (canUseRemainingForEdge(demand.edge)) {
        for (const column of columns) {
          if (needed <= 0) break;
          if (column.lengthRemaining + 1e-6 < demand.lengthM) continue;

          const stripsPossible = Math.floor(column.lengthRemaining / demand.lengthM);
          if (stripsPossible <= 0) continue;

          const used = Math.min(needed, stripsPossible);
          column.lengthRemaining = Math.max(0, column.lengthRemaining - used * demand.lengthM);
          needed -= used;
          layersFromRemainingStones += used;
          squareMetersFromRemaining += used * demand.lengthM * widthMeters;

          usageEntries.push({
            source: column.source,
            lengthM: demand.lengthM,
            quantity: used
          });
        }
      }

      if (needed > 0) {
        squareMetersFromNew += needed * demand.lengthM * widthMeters;
        unfulfilledDemands.push({ edge: demand.edge, lengthM: demand.lengthM, quantity: needed });
      }
    });

    const layersFromNewStones = Math.max(0, totalLayerDemand - layersFromRemainingStones);

    const usedRemainingStonesForLayers: RemainingStone[] = usageEntries.map((entry, index) => ({
      id: `used_layer_${entry.source.id}_${index}`,
      width: layerWidthCm,
      length: entry.lengthM,
      squareMeters: (layerWidthCm * entry.lengthM * entry.quantity) / 100,
      isAvailable: false,
      sourceCutId: entry.source.sourceCutId || entry.source.id,
      quantity: entry.quantity
    }));

    const layerRemainingPieces: RemainingStone[] = [
      ...columns
        .filter(column => column.lengthRemaining > 1e-6)
        .map(column => ({
          id: `layer_remaining_${column.id}`,
          width: layerWidthCm,
          length: column.lengthRemaining,
          squareMeters: (layerWidthCm * column.lengthRemaining) / 100,
          isAvailable: true,
          sourceCutId: column.source.sourceCutId || column.source.id,
          quantity: 1
        })),
      ...residualWidthPieces
    ];
    
    return {
      layersFromRemainingStones,
      layersFromNewStones,
      totalLayerCuttingCost: 0,
      usedRemainingStonesForLayers,
      layerCutDetails: [],
      layerRemainingPieces,
      squareMetersFromRemaining,
      squareMetersFromNew,
      totalLayerDemand,
      unfulfilledDemands
    };
  };
  
  /**
   * Create a new layer product
   */
const createLayerProduct = (params: {
  draft: StairPartDraftV2;
  stoneProduct: Product;
  stairSystemId: string;
  parentPartType: StairStepperPart;
  totalLayers: number;
  totalLayerSqm: number;
  layerMaterialPrice: number;
  layerTotalPrice: number;
  layerTypeCost: number;
  layersFromRemainingStones: number;
  layersFromNewStones: number;
  totalLayerCuttingCost: number;
  layerCutDetails: StoneCut[];
  layerRemainingPieces?: RemainingStone[];
  usedRemainingStonesForLayers: RemainingStone[];
  originalWidthCm: number;
  lengthM: number;
  layerCuttingCostPerMeter: number;
  parentProductIndexInSession: number;
  layerPricePerSquareMeter: number;
  layerStoneLabel?: string | null;
  layerUseDifferentStone?: boolean;
  layerStoneProductId?: string | null;
  layerStoneBasePricePerSquareMeter?: number | null;
  layerUseMandatory?: boolean;
  layerMandatoryPercentage?: number | null;
  stoneAreaUsedSqm?: number; // Ù…Ø³Ø§Ø­Øª Ø³Ù†Ú¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø´ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§
}): ContractProduct => {
    const {
      draft,
      stoneProduct,
      stairSystemId,
      parentPartType,
      totalLayers,
      totalLayerSqm,
      layerMaterialPrice,
      layerTotalPrice,
    layerTypeCost,
      layersFromRemainingStones,
      layersFromNewStones,
      totalLayerCuttingCost,
      layerCutDetails,
    layerRemainingPieces,
      usedRemainingStonesForLayers,
      originalWidthCm,
      lengthM,
      layerCuttingCostPerMeter,
    parentProductIndexInSession,
    layerPricePerSquareMeter,
    layerStoneLabel,
    layerUseDifferentStone,
    layerStoneProductId,
      layerStoneBasePricePerSquareMeter,
      layerUseMandatory,
      layerMandatoryPercentage,
      stoneAreaUsedSqm
    } = params;
    
  const layerStoneName = layerUseDifferentStone
    ? (layerStoneLabel || stoneProduct.namePersian || stoneProduct.name || '')
    : (draft.stoneLabel || stoneProduct.namePersian || stoneProduct.name || '');

    return {
    productId: layerUseDifferentStone ? (layerStoneProductId || stoneProduct.id) : (draft.stoneId || stoneProduct.id),
      product: stoneProduct,
      productType: 'stair',
      stairSystemId,
      stairPartType: parentPartType,
      stoneCode: stoneProduct.code,
    stoneName: `${layerStoneName} - Ù„Ø§ÛŒÙ‡ (${draft.numberOfLayersPerStair} Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡)`,
      diameterOrWidth: stoneProduct.thicknessValue ?? draft.thicknessCm ?? 0,
      // For layer products, length and width represent the layer dimensions
      // Length: use stair length as reference (layers go along edges)
      // Width: layer width (the thickness of the layer strip)
      length: convertMetersToUnit(getActualLengthMeters(draft), draft.lengthUnit || 'm'), // Use actual stair length (fallback to Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯)
      lengthUnit: draft.lengthUnit || 'm',
      width: draft.layerWidthCm!,
      widthUnit: 'cm',
      quantity: totalLayers,
      squareMeters: totalLayerSqm, // Total square meters (calculated from edges)
    pricePerSquareMeter: layerPricePerSquareMeter,
      // ğŸ¯ FIX: Ensure totalPrice is always a number (not string)
      totalPrice: typeof layerTotalPrice === 'number' ? Number(layerTotalPrice.toFixed(2)) : Number(parseFloat(String(layerTotalPrice || 0)).toFixed(2)),
      description: `Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ${getPartDisplayLabel(parentPartType)} - ${draft.numberOfLayersPerStair} Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡${layersFromRemainingStones > 0 ? ` (${layersFromRemainingStones} Ø§Ø² Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ØŒ ${layersFromNewStones} Ø§Ø² Ø³Ù†Ú¯ Ø¬Ø¯ÛŒØ¯)` : ''}${draft.layerTypeName ? ` | Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡: ${draft.layerTypeName}` : ''}`,
      currency: 'ØªÙˆÙ…Ø§Ù†',
      isMandatory: false,
      mandatoryPercentage: 0,
      originalTotalPrice: layerMaterialPrice, // Only material cost for new stones
      isCut:
        layersFromRemainingStones > 0 ||
        totalLayerCuttingCost > 0 ||
        (layerCutDetails && layerCutDetails.length > 0),
      cutType: totalLayerCuttingCost > 0 ? 'longitudinal' : null,
      // Use the same original dimensions as the main stair part for StoneCanvas consistency
      originalWidth: originalWidthCm,
      originalLength: lengthM,
      cuttingCost: totalLayerCuttingCost,
      cuttingCostPerMeter: layerCuttingCostPerMeter,
      cutDescription: layersFromRemainingStones > 0 
        ? `Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: ${layersFromRemainingStones} Ù„Ø§ÛŒÙ‡ØŒ Ø³Ù†Ú¯ Ø¬Ø¯ÛŒØ¯: ${layersFromNewStones} Ù„Ø§ÛŒÙ‡`
        : '',
      // ğŸ¯ FIX: Calculate remaining stones after cutting layers from remaining stones
      // For each cut detail, create a remaining stone piece for the leftover
      remainingStones: (() => {
        if (layerRemainingPieces && layerRemainingPieces.length) {
          return layerRemainingPieces;
        }
        const layerRemainingStones: RemainingStone[] = [];
        
        // ğŸ¯ FIX: Process cutDetails to create remaining stone pieces correctly
        // Similar to slab cutting - can have multiple remaining pieces (width, length, corner)
        layerCutDetails.forEach((cutDetail, index) => {
          // Get stored dimensions from cutDetail (added in calculateLayerMetrics)
          const cutDetailAny = cutDetail as any;
          const originalRemainingWidthCm = cutDetail.originalWidth;
          const originalRemainingLengthCm = cutDetail.length; // Already in cm (stored as original remaining stone length)
          const layerWidthCm = cutDetailAny._layerWidthCm || draft.layerWidthCm || 0;
          const layerLengthCm = cutDetailAny._layerLengthCm || (lengthM * 100);
          
          // Determine what cuts were made
          const needsWidthCut = layerWidthCm > 0 && layerWidthCm < originalRemainingWidthCm;
          const needsLengthCut = layerLengthCm > 0 && layerLengthCm < originalRemainingLengthCm;
          
          // Find the corresponding usedRemainingStone to get quantity
          const correspondingUsedStone = usedRemainingStonesForLayers.find((urs, idx) => {
            // Match by index or by checking if dimensions align
            const layerLengthM = layerLengthCm / 100;
            return idx === index || (Math.abs(urs.length - layerLengthM) < 0.001 && Math.abs(urs.width - layerWidthCm) < 0.01);
          });
          
          const quantity = correspondingUsedStone?.quantity || 1;
          
          // ğŸ¯ FIX: Calculate remaining pieces correctly when multiple layers are cut
          // Get stored values from cutDetail (calculated in calculateLayerMetrics)
          const actualUsedWidthCm = cutDetailAny._actualUsedWidthCm || layerWidthCm;
          const actualUsedLengthCm = cutDetailAny._actualUsedLengthCm || layerLengthCm;
          const actualRemainingWidthCm = cutDetailAny._actualRemainingWidthCm || Math.max(0, originalRemainingWidthCm - layerWidthCm);
          const actualRemainingLengthCm = cutDetailAny._actualRemainingLengthCm || Math.max(0, originalRemainingLengthCm - layerLengthCm);
          
          // ğŸ¯ Calculate remaining pieces (similar to slab cutting logic)
          if (needsWidthCut || needsLengthCut) {
            // ğŸ¯ FIX: Calculate remaining pieces correctly - avoid double-counting corner piece
            // When both width and length cuts are made, we get:
            // 1. Width leftover piece: remainingWidth Ã— FULL original length (includes corner)
            // 2. Length leftover piece: usedWidth Ã— remainingLength (does NOT include corner, it's separate)
            // The corner (remainingWidth Ã— remainingLength) is already included in Piece 1, so we DON'T add it separately
            
            // Piece 1: Remaining width piece (if width cut was made)
            // This is the piece that remains after cutting multiple layers width-wise
            // Example: 20cm original, cut 2 layers of 7cm each (14cm used), remaining = 6cm Ã— full length (1.2m)
            // NOTE: This piece includes the corner (6cm Ã— 0.2m) as part of the full length
            if (needsWidthCut && actualRemainingWidthCm > 0 && originalRemainingLengthCm > 0) {
              const remainingWidthPieceLengthM = originalRemainingLengthCm / 100; // Use FULL original length (1.2m)
              const remainingWidthSqm = (actualRemainingWidthCm * remainingWidthPieceLengthM * quantity) / 100;
              
              layerRemainingStones.push({
                id: `layer_remaining_width_${cutDetail.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                width: actualRemainingWidthCm, // 6cm (after cutting 2 layers of 7cm from 20cm)
                length: remainingWidthPieceLengthM, // Store in meters - FULL original length (1.2m) - includes corner!
                squareMeters: remainingWidthSqm,
                isAvailable: actualRemainingWidthCm > 0 && remainingWidthPieceLengthM > 0,
                sourceCutId: cutDetail.id,
                quantity: quantity,
                // Position: remaining piece is after the used width
                position: {
                  startWidth: actualUsedWidthCm, // Start after all layers width (14cm)
                  startLength: 0 // Same length start as original
                }
              });
            }
            
            // Piece 2: Remaining length piece (if length cut was made)
            // This is the piece that remains after cutting layers length-wise
            // Example: 1.2m original, cut 1 layer of 1m, remaining = used width (14cm) Ã— 0.2m
            // NOTE: This is separate from Piece 1, positioned below the used area
            if (needsLengthCut && actualRemainingLengthCm > 0 && actualUsedWidthCm > 0) {
              const remainingLengthPieceWidthCm = actualUsedWidthCm; // Use FULL width of used area (14cm when 2 layers)
              const remainingLengthPieceLengthM = actualRemainingLengthCm / 100; // Convert cm to meters (0.2m)
              const remainingLengthSqm = (remainingLengthPieceWidthCm * remainingLengthPieceLengthM * quantity) / 100;
              
              layerRemainingStones.push({
                id: `layer_remaining_length_${cutDetail.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                width: remainingLengthPieceWidthCm, // 14cm (full width of used area)
                length: remainingLengthPieceLengthM, // Store in meters (0.2m)
                squareMeters: remainingLengthSqm,
                isAvailable: remainingLengthPieceWidthCm > 0 && remainingLengthPieceLengthM > 0,
                sourceCutId: cutDetail.id,
                quantity: quantity,
                // Position: remaining piece is after the used length
                position: {
                  startWidth: 0, // Same width start as used area
                  startLength: actualUsedLengthCm / 100 // Start after all layers length (1m in meters)
                }
              });
            }
            
            // ğŸ¯ REMOVED: Corner piece is NOT needed separately
            // The corner (remainingWidth Ã— remainingLength) is already included in Piece 1 (width leftover piece)
            // Adding it separately would cause double-counting
            // Example: 6cm Ã— 0.2m corner is already part of 6cm Ã— 1.2m Piece 1
          }
        });
        
        return layerRemainingStones;
      })(),
      cutDetails: layerCutDetails,
      usedRemainingStones: usedRemainingStonesForLayers,
      totalUsedRemainingWidth: usedRemainingStonesForLayers.reduce((sum, rs) => sum + (rs.width || 0), 0),
      totalUsedRemainingLength: usedRemainingStonesForLayers.reduce((sum, rs) => sum + (rs.length || 0), 0),
      appliedSubServices: [],
      totalSubServiceCost: 0,
      usedLengthForSubServices: 0,
      usedSquareMetersForSubServices: 0,
      standardLengthValue: draft.standardLengthValue ?? null,
      standardLengthUnit: draft.standardLengthUnit || draft.lengthUnit || 'm',
      layerTypeId: draft.layerTypeId ?? null,
      layerTypeName: draft.layerTypeName ?? null,
      layerTypePrice: draft.layerTypePrice ?? null,
    layerUseDifferentStone: !!layerUseDifferentStone,
    layerStoneProductId: layerUseDifferentStone ? (layerStoneProductId || stoneProduct.id) : null,
    layerStoneName: layerUseDifferentStone ? layerStoneName : null,
    layerStonePricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : null,
    layerStoneBasePricePerSquareMeter: layerUseDifferentStone ? (layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter) : null,
    layerUseMandatory: layerUseDifferentStone ? (layerUseMandatory ?? true) : undefined,
    layerMandatoryPercentage: layerUseDifferentStone ? (layerMandatoryPercentage ?? null) : undefined,
      actualLengthMeters: getActualLengthMeters(draft) || null,
      // ğŸ¯ Set parentProductIndex to link layer to its parent stair part
      // This will be set correctly when adding to wizardData.products
      parentProductIndex: undefined, // Will be set after adding to wizardData
      meta: {
        stairStepperV2: true,
        isLayer: true,
        layerEdges: draft.layerEdges, // Store selected edges
        layerInfo: {
          numberOfLayersPerStair: draft.numberOfLayersPerStair,
          parentPartType,
          parentQuantity: draft.quantity,
          layersFromRemainingStones,
          layersFromNewStones,
          parentProductIndexInSession // Store for later reference
        },
        standardLength: draft.standardLengthValue ? {
          value: draft.standardLengthValue,
          unit: draft.standardLengthUnit || draft.lengthUnit || 'm',
          meters: getPricingLengthMeters(draft)
        } : undefined,
        layerType: draft.layerTypeId ? {
          id: draft.layerTypeId,
          name: draft.layerTypeName,
          pricePerLayer: draft.layerTypePrice || 0,
          totalCost: layerTypeCost
        } : undefined,
        layerAltStone: layerUseDifferentStone ? {
          id: layerStoneProductId || stoneProduct.id,
          name: layerStoneName,
          pricePerSquareMeter: layerPricePerSquareMeter,
          basePricePerSquareMeter: layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter,
          mandatoryPercentage: layerUseMandatory ? (layerMandatoryPercentage ?? 0) : 0
        } : undefined,
        // ğŸ¯ Store stone area used for layers (Ù…Ø³Ø§Ø­Øª Ø³Ù†Ú¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡)
        stoneAreaUsedSqm: stoneAreaUsedSqm && stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : undefined
      } as any
    };
  };
  
  /**
   * Merge an existing layer product with new layer data
   */
  const mergeLayerProduct = (
    existing: ContractProduct,
    newData: {
      draft: StairPartDraftV2;
      parentPartType: StairStepperPart;
      newLayersNeeded: number;
      newLayerSqm: number;
      layerMaterialPrice: number;
      layerTypeCost: number;
      totalLayerCuttingCost: number;
      layerCutDetails: StoneCut[];
      usedRemainingStonesForLayers: RemainingStone[];
      layersFromRemainingStones: number; // Add this parameter
    layersFromNewStones: number; // Add this parameter
    layerPricePerSquareMeter: number;
    layerStoneLabel?: string | null;
    layerUseDifferentStone?: boolean;
    layerStoneProductId?: string | null;
    layerStoneBasePricePerSquareMeter?: number | null;
    layerUseMandatory?: boolean;
    layerMandatoryPercentage?: number | null;
    stoneAreaUsedSqm?: number; // Ù…Ø³Ø§Ø­Øª Ø³Ù†Ú¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡
    }
  ): ContractProduct => {
    const {
      draft,
      parentPartType,
      newLayersNeeded,
      newLayerSqm,
      layerMaterialPrice,
      layerTypeCost,
      totalLayerCuttingCost,
      layerCutDetails,
      usedRemainingStonesForLayers,
      layersFromRemainingStones,
    layersFromNewStones,
    layerPricePerSquareMeter,
    layerStoneLabel,
    layerUseDifferentStone,
    layerStoneProductId,
      layerStoneBasePricePerSquareMeter,
      layerUseMandatory,
      layerMandatoryPercentage,
      stoneAreaUsedSqm
    } = newData;
    
    const existingLayerInfo = (existing.meta as any)?.layerInfo;
    const existingLayersFromRemaining = existingLayerInfo?.layersFromRemainingStones || 0;
    const existingLayersFromNew = existingLayerInfo?.layersFromNewStones || 0;
    
    // Merge layer counts
    const updatedLayersFromRemaining = existingLayersFromRemaining + layersFromRemainingStones;
    const updatedLayersFromNew = existingLayersFromNew + layersFromNewStones;
    const updatedTotalLayers = updatedLayersFromRemaining + updatedLayersFromNew;
    
    // Recalculate totals with merged quantities
    const existingLayerSqm = existing.squareMeters || 0;
    const updatedTotalSqm = existingLayerSqm + newLayerSqm;
    
    // ğŸ¯ Merge stone area used
    const existingStoneAreaUsed = (existing.meta as any)?.stoneAreaUsedSqm || 0;
    const updatedStoneAreaUsedSqm = stoneAreaUsedSqm && stoneAreaUsedSqm > 0
      ? (existingStoneAreaUsed + stoneAreaUsedSqm)
      : existingStoneAreaUsed;
    
    // Merge remaining stone usage
    const existingUsedRemainingStones = existing.usedRemainingStones || [];
    const mergedUsedRemainingStones = [...existingUsedRemainingStones, ...usedRemainingStonesForLayers];
    
    // Merge cut details
    const existingCutDetails = existing.cutDetails || [];
    const mergedCutDetails = [...existingCutDetails, ...layerCutDetails];
    
    // Recalculate pricing
    const existingLayerMaterialPrice = existing.originalTotalPrice || 0;
  const updatedLayerMaterialPrice = layerMaterialPrice + existingLayerMaterialPrice;
    // ğŸ¯ FIX: Ensure updatedLayerTotalPrice is always a number (not string) and properly rounded
    const updatedLayerTotalPrice = Number((updatedLayerMaterialPrice + (existing.cuttingCost || 0) + totalLayerCuttingCost).toFixed(2));
    
    const existingLayerTypeMeta = (existing.meta as any)?.layerType || {};
    return {
      ...existing,
      quantity: updatedTotalLayers,
      squareMeters: updatedTotalSqm,
      totalPrice: updatedLayerTotalPrice,
      originalTotalPrice: updatedLayerMaterialPrice,
      cuttingCost: (existing.cuttingCost || 0) + totalLayerCuttingCost,
      cutDetails: mergedCutDetails,
      usedRemainingStones: mergedUsedRemainingStones,
      totalUsedRemainingWidth: mergedUsedRemainingStones.reduce((sum, rs) => sum + (rs.width || 0), 0),
      totalUsedRemainingLength: mergedUsedRemainingStones.reduce((sum, rs) => sum + (rs.length || 0), 0),
    description: `Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ${getPartDisplayLabel(parentPartType)} - ${draft.numberOfLayersPerStair} Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡ (${updatedLayersFromRemaining} Ø§Ø² Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ØŒ ${updatedLayersFromNew} Ø§Ø² Ø³Ù†Ú¯ Ø¬Ø¯ÛŒØ¯)${draft.layerTypeName ? ` | Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡: ${draft.layerTypeName}` : ''}`,
      cutDescription: mergedUsedRemainingStones.length > 0 
        ? `Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: ${updatedLayersFromRemaining} Ù„Ø§ÛŒÙ‡ØŒ Ø³Ù†Ú¯ Ø¬Ø¯ÛŒØ¯: ${updatedLayersFromNew} Ù„Ø§ÛŒÙ‡`
        : '',
      layerTypeId: draft.layerTypeId ?? existing.layerTypeId ?? null,
      layerTypeName: draft.layerTypeName ?? existing.layerTypeName ?? null,
      layerTypePrice: draft.layerTypePrice ?? existing.layerTypePrice ?? null,
    pricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : existing.pricePerSquareMeter,
    layerUseDifferentStone: layerUseDifferentStone ?? existing.layerUseDifferentStone ?? false,
    layerStoneProductId: layerUseDifferentStone ? (layerStoneProductId || existing.layerStoneProductId || existing.productId) : existing.layerStoneProductId || null,
    layerStoneName: layerUseDifferentStone ? (layerStoneLabel || existing.layerStoneName || existing.stoneName) : existing.layerStoneName || null,
    layerStonePricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : existing.layerStonePricePerSquareMeter || null,
    layerStoneBasePricePerSquareMeter: layerUseDifferentStone
      ? (layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter)
      : existing.layerStoneBasePricePerSquareMeter || null,
    layerUseMandatory: layerUseDifferentStone
      ? (layerUseMandatory ?? existing.layerUseMandatory ?? true)
      : existing.layerUseMandatory,
    layerMandatoryPercentage: layerUseDifferentStone
      ? (layerMandatoryPercentage ?? existing.layerMandatoryPercentage ?? null)
      : existing.layerMandatoryPercentage,
      meta: {
        ...existing.meta,
        layerEdges: draft.layerEdges, // Update edges if changed
        layerInfo: {
          ...existingLayerInfo,
          layersFromRemainingStones: updatedLayersFromRemaining,
          layersFromNewStones: updatedLayersFromNew,
          parentQuantity: (existingLayerInfo?.parentQuantity || 0) + draft.quantity
        },
        standardLength: draft.standardLengthValue
          ? {
              value: draft.standardLengthValue,
              unit: draft.standardLengthUnit || draft.lengthUnit || 'm',
              meters: getPricingLengthMeters(draft)
            }
          : (existing.meta as any)?.standardLength,
        layerType: draft.layerTypeId
          ? {
              id: draft.layerTypeId,
              name: draft.layerTypeName,
              pricePerLayer: draft.layerTypePrice || existingLayerTypeMeta.pricePerLayer || 0,
              totalCost: (existingLayerTypeMeta.totalCost || 0) + layerTypeCost
            }
          : ((existing.meta as any)?.layerType),
        layerAltStone: (layerUseDifferentStone ?? existing.layerUseDifferentStone)
          ? {
              id: layerUseDifferentStone ? (layerStoneProductId || existing.layerStoneProductId || existing.productId) : (existing.layerStoneProductId || existing.productId),
              name: layerUseDifferentStone ? (layerStoneLabel || existing.layerStoneName || existing.stoneName) : (existing.layerStoneName || existing.stoneName),
              pricePerSquareMeter: layerUseDifferentStone ? layerPricePerSquareMeter : (existing.layerStonePricePerSquareMeter || layerPricePerSquareMeter || existing.pricePerSquareMeter),
              basePricePerSquareMeter: layerUseDifferentStone
                ? (layerStoneBasePricePerSquareMeter ?? layerPricePerSquareMeter)
                : (existing.layerStoneBasePricePerSquareMeter || layerStoneBasePricePerSquareMeter || existing.pricePerSquareMeter),
              mandatoryPercentage: layerUseDifferentStone
                ? (layerUseMandatory ? (layerMandatoryPercentage ?? 0) : 0)
                : (existing.layerUseMandatory ? (existing.layerMandatoryPercentage ?? 0) : 0)
            }
          : undefined,
        // ğŸ¯ Merge stone area used
        stoneAreaUsedSqm: updatedStoneAreaUsedSqm > 0 ? updatedStoneAreaUsedSqm : undefined
      } as any
    };
  };
  
  /**
   * Update remaining stone usage tracking in products
   * Returns a map of product index to updated product
   */
  const updateRemainingStoneUsage = (
    sessionItems: ContractProduct[],
    usedRemainingStones: RemainingStone[],
    mainStairPartIndex: number
  ): Map<number, ContractProduct> => {
    const updates = new Map<number, ContractProduct>();
    
    if (usedRemainingStones.length === 0) {
      return updates;
    }
    
    // Create a map of remaining stone IDs to their source product index
    const remainingStoneSourceMap = new Map<string, number>();
    sessionItems.forEach((item, idx) => {
      const itemIsLayer = ((item.meta as any)?.isLayer) || false;
      if (!itemIsLayer && item.remainingStones && item.remainingStones.length > 0) {
        item.remainingStones.forEach(rs => {
          remainingStoneSourceMap.set(rs.id, idx);
        });
      }
    });
    
    // Group used remaining stones by their source product
    const usedBySource = new Map<number, RemainingStone[]>();
    usedRemainingStones.forEach(usedRs => {
      const sourceIdx = remainingStoneSourceMap.get(usedRs.id);
      if (sourceIdx !== undefined) {
        if (!usedBySource.has(sourceIdx)) {
          usedBySource.set(sourceIdx, []);
        }
        usedBySource.get(sourceIdx)!.push(usedRs);
      }
    });
    
    // Also update the main stair part (the one we just added)
    if (mainStairPartIndex >= 0 && mainStairPartIndex < sessionItems.length) {
      const mainProduct = sessionItems[mainStairPartIndex];
      if (mainProduct && mainProduct.productType === 'stair' && !((mainProduct.meta as any)?.isLayer)) {
        const existingUsed = mainProduct.usedRemainingStones || [];
        const mergedUsed = [...existingUsed, ...usedRemainingStones];
        updates.set(mainStairPartIndex, {
          ...mainProduct,
          usedRemainingStones: mergedUsed,
          totalUsedRemainingWidth: mergedUsed.reduce((sum, rs) => sum + (rs.width || 0), 0),
          totalUsedRemainingLength: mergedUsed.reduce((sum, rs) => sum + (rs.length || 0), 0)
        });
      }
    }
    
    // Update each source product with its used remaining stones
    usedBySource.forEach((usedStones, sourceIdx) => {
      if (sourceIdx >= 0 && sourceIdx < sessionItems.length) {
        const sourceProduct = sessionItems[sourceIdx];
        if (sourceProduct && sourceProduct.productType === 'stair' && !((sourceProduct.meta as any)?.isLayer)) {
          const existingUsed = sourceProduct.usedRemainingStones || [];
          const mergedUsed = [...existingUsed, ...usedStones];
          updates.set(sourceIdx, {
            ...sourceProduct,
            usedRemainingStones: mergedUsed,
            totalUsedRemainingWidth: mergedUsed.reduce((sum, rs) => sum + (rs.width || 0), 0),
            totalUsedRemainingLength: mergedUsed.reduce((sum, rs) => sum + (rs.length || 0), 0)
          });
        }
      }
    });
    
    return updates;
  };

  const computeTotalsV2 = (
    part: StairStepperPart,
    draft: StairPartDraftV2
  ): {
    sqm: number;
    toolsTotal: number;
    partTotal: number;
    pricingSquareMeters: number;
    baseStoneQuantity: number;
    piecesPerStone: number;
    leftoverWidthCm: number;
    cuttingCost: number;
    cuttingCostPerMeter: number;
    cuttingCostLongitudinal: number;
    cuttingCostPerMeterLongitudinal: number;
    cuttingCostCross: number;
    cuttingCostPerMeterCross: number;
    baseMaterialPrice: number;
    billableCuttingCost: number;
    billableCuttingCostLongitudinal: number;
    billableCuttingCostCross: number;
    shouldChargeCuttingCost: boolean;
  } => {
    // Calculate display square meters using user-entered width (for display purposes)
    const sqm = computeSqmV2(draft);
    const toolsMeters = computeToolsMetersV2(part, draft);
    const pricePerSqm = draft.pricePerSquareMeter || 0;
    let toolsPrice = 0;
    if (draft.tools && draft.tools.length) {
      for (const t of draft.tools) {
        const meters = computeToolMetersForTool(part, draft, t);
        toolsPrice += meters * (t.pricePerMeter || 0);
      }
    }
    
    // ğŸ¯ CRITICAL: Use original width for pricing (like long stone products)
    // Display sqm uses user-entered width, but pricing uses original width
    const {
      originalWidthCm,
      userWidthCm,
      baseStoneQuantity,
      piecesPerStone,
      leftoverWidthCm
    } = calculateStairStoneUsage(draft);
    const actualLengthM = getActualLengthMeters(draft);
    const pricingLengthM = part === 'riser' ? actualLengthM : getPricingLengthMeters(draft);
    const stoneQuantityForPricing = baseStoneQuantity || 0;

    let pricingSquareMeters = sqm;
    if (originalWidthCm > 0 && userWidthCm > 0 && pricingLengthM > 0 && stoneQuantityForPricing > 0) {
      pricingSquareMeters = pricingLengthM * (originalWidthCm / 100) * stoneQuantityForPricing;
    }

    const baseMaterialPrice = pricingSquareMeters * pricePerSqm;
    const defaultMandatoryForPart = part === 'riser' || part === 'landing';
    const isMandatoryEnabled = draft.useMandatory ?? defaultMandatoryForPart;
    const mandatoryPercentageValue = draft.mandatoryPercentage ?? 20;
    const mandatoryAmount = isMandatoryEnabled && mandatoryPercentageValue > 0
      ? baseMaterialPrice * (mandatoryPercentageValue / 100)
      : 0;
    const materialPriceWithMandatory = baseMaterialPrice + mandatoryAmount;

    let cuttingCostPerMeter = 0;
    let cuttingCost = 0;
    let cuttingCostLongitudinal = 0;
    let cuttingCostPerMeterLongitudinal = 0;
    let cuttingCostCross = 0;
    let cuttingCostPerMeterCross = 0;
    const needsWidthCut =
      originalWidthCm > 0 && userWidthCm > 0 && userWidthCm < originalWidthCm && actualLengthM > 0;
    const needsLengthCut =
      pricingLengthM > 0 && actualLengthM > 0 && pricingLengthM - actualLengthM > 0.0001 && userWidthCm > 0;

    if (needsWidthCut && stoneQuantityForPricing > 0) {
      cuttingCostPerMeterLongitudinal =
        (draft.stoneProduct as any)?.cuttingCostPerMeter ??
        getCuttingTypePricePerMeter('LONG') ??
        0;
      if (cuttingCostPerMeterLongitudinal > 0) {
        cuttingCostLongitudinal = cuttingCostPerMeterLongitudinal * actualLengthM * stoneQuantityForPricing;
      }
    }

    if (needsLengthCut && stoneQuantityForPricing > 0) {
      const crossRateFromConfig =
        (draft.stoneProduct as any)?.crossCuttingCostPerMeter ??
        getCuttingTypePricePerMeter('CROSS') ??
        getCuttingTypePricePerMeter('LONG') ??
        0;
      cuttingCostPerMeterCross = crossRateFromConfig;
      if (cuttingCostPerMeterCross > 0) {
        const widthInMeters = userWidthCm / 100;
        cuttingCostCross = cuttingCostPerMeterCross * widthInMeters * stoneQuantityForPricing;
      }
    }

    cuttingCost = cuttingCostLongitudinal + cuttingCostCross;
    cuttingCostPerMeter = cuttingCostLongitudinal > 0
      ? cuttingCostPerMeterLongitudinal
      : (cuttingCostCross > 0 ? cuttingCostPerMeterCross : 0);

    const shouldChargeCuttingCost = !(isMandatoryEnabled && mandatoryPercentageValue > 0);
    const billableCuttingCostLongitudinal = shouldChargeCuttingCost ? cuttingCostLongitudinal : 0;
    const billableCuttingCostCross = shouldChargeCuttingCost ? cuttingCostCross : 0;
    const billableCuttingCost = billableCuttingCostLongitudinal + billableCuttingCostCross;

    const partTotal = materialPriceWithMandatory + toolsPrice + billableCuttingCost;
    return {
      sqm,
      toolsTotal: toolsPrice,
      partTotal,
      pricingSquareMeters,
      baseStoneQuantity: stoneQuantityForPricing,
      piecesPerStone,
      leftoverWidthCm,
      cuttingCost,
      cuttingCostPerMeter,
      cuttingCostLongitudinal,
      cuttingCostPerMeterLongitudinal,
      cuttingCostCross,
      cuttingCostPerMeterCross,
      baseMaterialPrice,
      billableCuttingCost,
      billableCuttingCostLongitudinal,
      billableCuttingCostCross,
      shouldChargeCuttingCost
    };
  };

  const computeFinishingCost = (
    draft: StairPartDraftV2,
    pricingSquareMeters: number
  ): number => {
    if (!draft.finishingEnabled || !draft.finishingId || !draft.finishingPricePerSquareMeter) {
      return 0;
    }
    if (pricingSquareMeters <= 0) return 0;
    return pricingSquareMeters * draft.finishingPricePerSquareMeter;
  };

  // Debounced stone search using products endpoint (acts as master data + price source)
  useEffect(() => {
    let active = true;
    const term = stairSystemV2.stoneSearchTerm?.trim();
    if (!useStairFlowV2) return;
    if (!term) {
      stairSystemV2.setStoneSearchResults([]);
      return;
    }
    stairSystemV2.setIsSearchingStones(true);
    const timeout = setTimeout(async () => {
      try {
        const res = await salesAPI.getProducts({ search: term, limit: 10, contractType: 'stair' });
        if (!active) return;
        const rawItems: Product[] = (res?.data?.items || res?.data?.data || []) as Product[];
        
        // Deduplicate products by ID first, then by code if IDs are missing/duplicate
        const seenIds = new Set<string>();
        const seenCodes = new Set<string>();
        const uniqueProducts = rawItems.filter((item) => {
          if (item.id) {
            if (seenIds.has(item.id)) {
              return false;
            }
            seenIds.add(item.id);
            return true;
          }
          if (item.code) {
            if (seenCodes.has(item.code)) {
              return false;
            }
            seenCodes.add(item.code);
            return true;
          }
          return true;
        });
        
        const stairEligibleProducts = uniqueProducts.filter(product =>
          productSupportsContractType(product, 'stair')
        );
        stairSystemV2.setStoneSearchResults(stairEligibleProducts);
      } catch (e) {
        console.error('Stone search failed', e);
        if (active) stairSystemV2.setStoneSearchResults([]);
      } finally {
        if (active) stairSystemV2.setIsSearchingStones(false);
      }
    }, 300);
    return () => { active = false; clearTimeout(timeout); };
  }, [stairSystemV2.stoneSearchTerm, useStairFlowV2]);

  useEffect(() => {
    let active = true;
    const term = stairSystemV2.layerStoneSearchTerm?.trim();
    if (!useStairFlowV2) return;
    if (!term) {
      stairSystemV2.setLayerStoneSearchResults([]);
      return;
    }
    stairSystemV2.setIsSearchingLayerStones(true);
    const timeout = setTimeout(async () => {
      try {
        const res = await salesAPI.getProducts({ search: term, limit: 10, contractType: 'stair' });
        if (!active) return;
        const items: Product[] = (res?.data?.items || res?.data?.data || []) as Product[];
        const stairEligible = items.filter(product => productSupportsContractType(product, 'stair'));
        stairSystemV2.setLayerStoneSearchResults(stairEligible);
      } catch (e) {
        console.error('Layer stone search failed', e);
        if (active) stairSystemV2.setLayerStoneSearchResults([]);
      } finally {
        if (active) stairSystemV2.setIsSearchingLayerStones(false);
      }
    }, 300);
    return () => {
      active = false;
      clearTimeout(timeout);
    };
  }, [stairSystemV2.layerStoneSearchTerm, useStairFlowV2]);

  // Debounced tools search
  useEffect(() => {
    let active = true;
    const term = stairSystemV2.toolsSearchTerm?.trim();
    if (!useStairFlowV2) return;
    // If no term, load top tools (initial list) instead of clearing
    stairSystemV2.setIsSearchingTools(true);
    const timeout = setTimeout(async () => {
      try {
        const params: any = { limit: 20 };
        if (term) params.search = term;
        const res = await servicesAPI.getSubServices(params);
        if (!active) return;
        const items = res?.data?.items || res?.data?.data || [];
        stairSystemV2.setToolsResults(items);
      } catch (e) {
        console.error('Tools search failed', e);
        if (active) stairSystemV2.setToolsResults([]);
      } finally {
        if (active) stairSystemV2.setIsSearchingTools(false);
      }
    }, 300);
    return () => { active = false; clearTimeout(timeout); };
  }, [stairSystemV2.toolsSearchTerm, useStairFlowV2]);

  // Preload tools list once when modal flow is used
  useEffect(() => {
    if (!useStairFlowV2) return;
    (async () => {
      try {
        const res = await servicesAPI.getSubServices({ limit: 20 });
        const items = res?.data?.items || res?.data?.data || [];
        stairSystemV2.setToolsResults(items);
      } catch (e) {
        console.error('Initial tools preload failed', e);
      }
    })();
  }, [useStairFlowV2]);
  
  // Product modal state is now managed by useProductModal hook (see above)
  
  // SubService modal state is now provided by useSubServiceModal hook
  // Data (loaded from API) - kept in main component
  const [subServices, setSubServices] = useState<SubService[]>([]);
  const [stoneFinishings, setStoneFinishings] = useState<StoneFinishing[]>([]);
  
  // Payment entry modal state is now provided by usePaymentHandlers hook
  
  // Stair stone specific state (old - keeping for backward compatibility during transition)
  const [treadWidthUnit, setTreadWidthUnit] = useState<'cm' | 'm'>('m'); // Default to meters for tread width
  
  // Product modal state (mandatory, quantity, touched fields, stair system) is now managed by useProductModal hook
  
  // Helper function to initialize stair system config
  const initializeStairSystemConfig = (defaultProduct: Product | null): StairSystemConfig => {
    return {
      numberOfSteps: 0,
      quantityType: 'steps',
      numberOfStaircases: 1,
      defaultProduct: defaultProduct,
      tread: {
        partType: 'tread',
        isSelected: false,
        productId: defaultProduct?.id || null,
        product: defaultProduct,
        treadWidth: 0,
        treadDepth: 30,
        quantity: 0,
        squareMeters: 0,
        pricePerSquareMeter: defaultProduct?.basePrice || 0,
        totalPrice: 0,
        nosingType: 'none',
        nosingOverhang: 30,
        nosingCuttingCost: 0,
        nosingCuttingCostPerMeter: 0,
        isMandatory: false,
        mandatoryPercentage: 20,
        originalTotalPrice: 0,
        description: '',
        currency: 'ØªÙˆÙ…Ø§Ù†',
        lengthUnit: 'm'
      },
      riser: {
        partType: 'riser',
        isSelected: false,
        productId: defaultProduct?.id || null,
        product: defaultProduct,
        riserHeight: 17,
        quantity: 0,
        squareMeters: 0,
        pricePerSquareMeter: defaultProduct?.basePrice || 0,
        totalPrice: 0,
        isMandatory: true,
        mandatoryPercentage: 20,
        originalTotalPrice: 0,
        description: '',
        currency: 'ØªÙˆÙ…Ø§Ù†'
      },
      landing: {
        partType: 'landing',
        isSelected: false,
        productId: defaultProduct?.id || null,
        product: defaultProduct,
        landingWidth: 0,
        landingDepth: 0,
        numberOfLandings: 0,
        quantity: 0,
        squareMeters: 0,
        pricePerSquareMeter: defaultProduct?.basePrice || 0,
        totalPrice: 0,
        isMandatory: true,
        mandatoryPercentage: 20,
        originalTotalPrice: 0,
        description: '',
        currency: 'ØªÙˆÙ…Ø§Ù†'
      }
    };
  };
  
  // Helper functions are now provided by useProductModal and useProductCalculations hooks
  // Remaining stone modal state is now provided by useRemainingStoneModal hook
  
  // Get current Persian date with fallback
  const getCurrentPersianDate = () => {
    try {
      const date = PersianCalendar.now('jYYYY/jMM/jDD');
      // Validate the date format (should be YYYY/MM/DD)
      if (date && date.match(/^\d{4}\/\d{2}\/\d{2}$/)) {
        return date;
      }
    } catch (error) {
      console.error('Error getting Persian date:', error);
    }
    // Fallback to a valid Persian date
    return '1403/01/01';
  };

  // Wizard data is now provided by useContractWizard hook

  const productsSummary = useMemo(() => {
    const summary = wizardData.products.reduce((acc, product) => {
      const totalPriceValue = typeof product.totalPrice === 'number'
        ? product.totalPrice
        : parseFloat(String(product.totalPrice || '0'));
      const squareMetersValue = typeof product.squareMeters === 'number'
        ? product.squareMeters
        : parseFloat(String(product.squareMeters || '0'));
      const quantityValue = typeof product.quantity === 'number'
        ? product.quantity
        : parseFloat(String(product.quantity || '0'));

      acc.totalPrice += isNaN(totalPriceValue) ? 0 : totalPriceValue;
      acc.totalSquareMeters += isNaN(squareMetersValue) ? 0 : squareMetersValue;
      acc.totalQuantity += isNaN(quantityValue) ? 0 : quantityValue;
      return acc;
    }, { totalPrice: 0, totalSquareMeters: 0, totalQuantity: 0 });

    return summary;
  }, [wizardData.products]);

  // Update totalContractAmount when products change
  useEffect(() => {
    if (wizardData.payment.totalContractAmount !== productsSummary.totalPrice) {
      setWizardData(prev => ({
        ...prev,
        payment: {
          ...prev.payment,
          totalContractAmount: productsSummary.totalPrice
        }
      }));
    }
  }, [productsSummary.totalPrice]);

  // Digital Signature (Step 8) - Get available phone numbers
  const availablePhones = useMemo(() => {
    if (!wizardData.customer?.phoneNumbers) return [];
    return wizardData.customer.phoneNumbers.filter(phone => phone.isActive);
  }, [wizardData.customer]);

  // Initialize signature state if needed
  useEffect(() => {
    if (currentStep === 8 && !wizardData.signature) {
      setWizardData(prev => ({
        ...prev,
        signature: {
          phoneNumber: availablePhones.find(p => p.isPrimary)?.number || availablePhones[0]?.number || null,
          verificationCode: '',
          codeSent: false,
          codeVerified: false,
          contractId: null
        }
      }));
    }
    // Also update phone number if signature exists but phoneNumber is null and phones are available
    if (currentStep === 8 && wizardData.signature && !wizardData.signature.phoneNumber && availablePhones.length > 0) {
      setWizardData(prev => ({
        ...prev,
        signature: {
          ...prev.signature!,
          phoneNumber: availablePhones.find(p => p.isPrimary)?.number || availablePhones[0]?.number || null
        }
      }));
    }
  }, [currentStep, availablePhones, wizardData.signature]);

  // Countdown timer is now managed by useDigitalSignature hook

  // Resend cooldown timer is now managed by useDigitalSignature hook

  // Re-fetch customer data in Step 8 if phoneNumbers are missing
  useEffect(() => {
    if (currentStep === 8 && wizardData.customerId) {
      const fetchCustomerData = async () => {
        // Check if phoneNumbers are missing or empty
        if (!wizardData.customer?.phoneNumbers || wizardData.customer.phoneNumbers.length === 0) {
          try {
            const customerResponse = await crmAPI.getCustomer(wizardData.customerId);
            if (customerResponse.data.success && customerResponse.data.data) {
              setWizardData(prev => ({
                ...prev,
                customer: customerResponse.data.data
              }));
            }
          } catch (error) {
            console.error('Error re-fetching customer data in Step 8:', error);
          }
        }
      };
      fetchCustomerData();
    }
  }, [currentStep, wizardData.customerId, wizardData.customer?.phoneNumbers]);

  // Fetch remaining time when code is sent
  useEffect(() => {
    if (currentStep === 8 && wizardData.signature?.codeSent && wizardData.signature?.contractId && wizardData.signature?.phoneNumber) {
      const fetchRemainingTime = async () => {
        try {
          const response = await salesAPI.getVerificationTime(
            wizardData.signature!.contractId!,
            wizardData.signature!.phoneNumber!
          );
          if (response.data.success && response.data.data?.remainingSeconds) {
            digitalSignature.startCountdown(response.data.data.remainingSeconds);
          }
        } catch (error) {
          console.error('Error fetching remaining time:', error);
        }
      };
      fetchRemainingTime();
      const interval = setInterval(fetchRemainingTime, 1000);
      return () => clearInterval(interval);
    }
  }, [currentStep, wizardData.signature?.codeSent, wizardData.signature?.contractId, wizardData.signature?.phoneNumber]);

  // Digital Signature handlers
  const handleSendVerificationCode = async () => {
    if (!wizardData.signature?.phoneNumber || !wizardData.signature?.contractId) {
      digitalSignature.setError('Ù„Ø·ÙØ§Ù‹ Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ† Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ Ùˆ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ Ø±Ø§ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯');
      return;
    }

    digitalSignature.setSendingCode(true);
    digitalSignature.clearError();
    digitalSignature.clearSuccess();
    digitalSignature.setSandboxVerificationCode(null); // Clear previous code when resending

    try {
      const response = await salesAPI.sendVerificationCode(
        wizardData.signature.contractId,
        wizardData.signature.phoneNumber
      );

      if (response.data.success) {
        setWizardData(prev => ({
          ...prev,
          signature: {
            ...prev.signature!,
            codeSent: true
          }
        }));
        
        // Store sandbox verification code if provided
        if (response.data.data?.isSandbox && response.data.data?.verificationCode) {
          digitalSignature.setSandboxVerificationCode(response.data.data.verificationCode);
        } else {
          digitalSignature.setSandboxVerificationCode(null);
        }
        
        digitalSignature.setSuccess('Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯');
        digitalSignature.startResendCooldown(60); // 60 second cooldown
        
        // Fetch remaining time
        if (response.data.data?.expiresAt) {
          const expiresAt = new Date(response.data.data.expiresAt);
          const remaining = Math.floor((expiresAt.getTime() - Date.now()) / 1000);
          digitalSignature.startCountdown(Math.max(0, remaining));
        }
      } else {
        digitalSignature.setError(response.data.error || 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯');
      }
    } catch (error: any) {
      console.error('Send verification code error:', error);
      digitalSignature.setError(error.response?.data?.error || 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯');
    } finally {
      digitalSignature.setSendingCode(false);
    }
  };

  const handleVerifyCode = async () => {
    if (!wizardData.signature?.verificationCode || wizardData.signature.verificationCode.length !== 6) {
      digitalSignature.setError('Ù„Ø·ÙØ§Ù‹ Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ 6 Ø±Ù‚Ù…ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯');
      return;
    }

    if (!wizardData.signature?.contractId || !wizardData.signature?.phoneNumber) {
      digitalSignature.setError('Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù†Ø§Ù‚Øµ Ø§Ø³Øª');
      return;
    }

    digitalSignature.setVerifyingCode(true);
    digitalSignature.clearError();

    try {
      const response = await salesAPI.verifyCode(
        wizardData.signature.contractId,
        wizardData.signature.verificationCode,
        wizardData.signature.phoneNumber
      );

      if (response.data.success && response.data.verified) {
        setWizardData(prev => ({
          ...prev,
          signature: {
            ...prev.signature!,
            codeVerified: true
          }
        }));
        digitalSignature.setSuccess('Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ùˆ Ø§Ù…Ø¶Ø§ Ø´Ø¯');
        
        // Redirect to contracts list after a short delay
        setTimeout(() => {
          router.push('/dashboard/sales/contracts');
        }, 2000);
      } else {
        digitalSignature.setError(response.data.error || 'Ú©Ø¯ ØªØ§ÛŒÛŒØ¯ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª');
      }
    } catch (error: any) {
      console.error('Verify code error:', error);
      digitalSignature.setError(error.response?.data?.error || 'Ø®Ø·Ø§ Ø¯Ø± ØªØ§ÛŒÛŒØ¯ Ú©Ø¯');
    } finally {
      digitalSignature.setVerifyingCode(false);
    }
  };

  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getPhoneTypeLabel = (type: string): string => {
    const labels: Record<string, string> = {
      mobile: 'Ù…ÙˆØ¨Ø§ÛŒÙ„',
      home: 'Ù…Ù†Ø²Ù„',
      work: 'Ù…Ø­Ù„ Ú©Ø§Ø±',
      other: 'Ø³Ø§ÛŒØ±'
    };
    return labels[type] || type;
  };

  // Payment entry management functions are now provided by usePaymentHandlers hook

  // Calculate payment sum
  const paymentSum = useMemo(() => {
    return wizardData.payment.payments.reduce((sum, p) => sum + p.amount, 0);
  }, [wizardData.payment.payments]);

  // Calculate remaining amount
  const remainingAmount = useMemo(() => {
    return wizardData.payment.totalContractAmount - paymentSum;
  }, [wizardData.payment.totalContractAmount, paymentSum]);

  // Check if payment sum matches contract total
  const paymentSumMatchesTotal = Math.abs(paymentSum - wizardData.payment.totalContractAmount) < 0.01;

  const serviceEntries = useMemo(() => {
    const entries: ServiceEntry[] = [];
    wizardData.products.forEach((product, productIndex) => {
      const productLabel = product.stoneName || product.product?.namePersian || product.product?.name || `Ù…Ø­ØµÙˆÙ„ ${productIndex + 1}`;

      if (product.appliedSubServices && product.appliedSubServices.length > 0) {
        product.appliedSubServices.forEach((applied, appliedIndex) => {
          const unitLabel = applied.calculationBase === 'squareMeters' ? 'Ù…ØªØ± Ù…Ø±Ø¨Ø¹' : 'Ù…ØªØ±';
          const amountLabel = `${formatDisplayNumber(applied.meter || 0)} ${unitLabel}`;
          entries.push({
            key: `tool-${productIndex}-${appliedIndex}-${applied.id}`,
            type: 'tool',
            productName: productLabel,
            description: applied.subService?.namePersian || applied.subService?.name || 'Ø§Ø¨Ø²Ø§Ø±',
            amountLabel,
            cost: applied.cost || 0,
            meta: {
              rateLabel: applied.subService?.pricePerMeter
                ? `${formatPrice(applied.subService.pricePerMeter, 'ØªÙˆÙ…Ø§Ù†')}/${unitLabel}`
                : undefined
            }
          });
        });
      }

      if (product.finishingId && product.finishingCost) {
        entries.push({
          key: `finishing-${productIndex}`,
          type: 'finishing',
          productName: productLabel,
          description: product.finishingName || 'Ù¾Ø±Ø¯Ø§Ø®Øª Ø³Ù†Ú¯',
          amountLabel: `${formatSquareMeters(product.finishingSquareMeters || product.squareMeters || 0)}`,
          cost: product.finishingCost || 0,
          meta: product.finishingPricePerSquareMeter
            ? {
                rateLabel: `${formatPrice(product.finishingPricePerSquareMeter, 'ØªÙˆÙ…Ø§Ù†')}/Ù…ØªØ± Ù…Ø±Ø¨Ø¹`
              }
            : undefined
        });
      }

      const isLayerProduct = Boolean((product.meta as any)?.isLayer);
      if (isLayerProduct) {
        const layerMeta = (product.meta as any) || {};
        const descriptionParts: string[] = [];
        if (layerMeta.layer?.numberOfLayersPerStair) {
          const parentPartType = (layerMeta.layer.parentPartType || 'tread') as StairStepperPart;
          descriptionParts.push(`${layerMeta.layer.numberOfLayersPerStair} Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± ${getPartDisplayLabel(parentPartType)}`);
        }
        if (layerMeta.layer?.layerTypeName) {
          descriptionParts.push(`Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡: ${layerMeta.layer.layerTypeName}`);
        }
        if (product.layerUseDifferentStone && product.layerStoneName) {
          descriptionParts.push(`Ø³Ù†Ú¯: ${product.layerStoneName}`);
        }
        entries.push({
          key: `layer-${productIndex}`,
          type: 'layer',
          productName: productLabel,
          description: descriptionParts.length ? descriptionParts.join(' | ') : 'Ù„Ø§ÛŒÙ‡ Ø§Ø¶Ø§ÙÙ‡',
          amountLabel: `${formatDisplayNumber(product.quantity || 0)} Ø¹Ø¯Ø¯ | ${formatSquareMeters(product.squareMeters || 0)}`,
          cost: typeof product.totalPrice === 'number' ? product.totalPrice : parseFloat(String(product.totalPrice || '0')) || 0,
          meta: product.layerUseDifferentStone && product.layerStonePricePerSquareMeter
            ? {
                rateLabel: `${formatPrice(product.layerStonePricePerSquareMeter, 'ØªÙˆÙ…Ø§Ù†')}/Ù…ØªØ± Ù…Ø±Ø¨Ø¹${
                  product.layerUseMandatory && product.layerMandatoryPercentage
                    ? ` (Ø­Ú©Ù…ÛŒ ${formatDisplayNumber(product.layerMandatoryPercentage)}%)`
                    : ''
                }`
              }
            : undefined
        });
      }

      if (product.isCut && (product.cuttingBreakdown?.length || product.cuttingCost)) {
        const breakdown = product.cuttingBreakdown && product.cuttingBreakdown.length > 0
          ? product.cuttingBreakdown
          : [{
              type: product.cutType || 'longitudinal',
              meters: (product.lengthUnit === 'm' ? product.length : (product.length || 0) / 100) * (product.quantity || 1),
              rate: product.cuttingCostPerMeter || 0,
              cost: product.cuttingCost || 0
            }];
        
        // Count cross cuts to determine if we should use "Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø±"
        const crossCuts = breakdown.filter(cut => cut.type === 'cross');
        const hasOnlyOneCrossCut = crossCuts.length === 1 && breakdown.length === 1;
        
        breakdown.forEach((cut, cutIndex) => {
          const metersLabel = `${formatDisplayNumber(cut.meters || 0)} Ù…ØªØ±`;
          // Use "Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø±" if there's only 1 cross cut, otherwise use "Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ"
          const cutDescription = cut.type === 'cross' 
            ? (hasOnlyOneCrossCut ? 'Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø±' : 'Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ')
            : 'Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ';
          entries.push({
            key: `cut-${productIndex}-${cutIndex}`,
            type: 'cut',
            productName: productLabel,
            description: cutDescription,
            amountLabel: metersLabel,
            cost: cut.cost || 0,
            meta: {
              rateLabel: cut.rate ? `${formatPrice(cut.rate, 'ØªÙˆÙ…Ø§Ù†')}/Ù…ØªØ±` : undefined
            }
          });
        });
      }

      const partitionCuts = (product.usedRemainingStones || []).filter(rs =>
        rs.position && rs.id.startsWith('partition_remaining_') && rs.cuttingCost && rs.cuttingCost > 0
      );
      partitionCuts.forEach((partition, partitionIndex) => {
        entries.push({
          key: `cut-partition-${productIndex}-${partitionIndex}`,
          type: 'cut',
          productName: `${productLabel} (Ù¾Ø§Ø±ØªÛŒØ´Ù†)`,
          description: partition.cutType === 'cross' ? 'Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡' : 'Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡',
          amountLabel: `${formatDisplayNumber(partition.length * (partition.quantity || 1))} Ù…ØªØ±`,
          cost: partition.cuttingCost || 0,
          meta: {
            rateLabel: partition.cuttingCostPerMeter ? `${formatPrice(partition.cuttingCostPerMeter, 'ØªÙˆÙ…Ø§Ù†')}/Ù…ØªØ±` : undefined
          }
        });
      });
    });
    return entries;
  }, [wizardData.products]);

  const serviceTotals = useMemo(() => {
    return serviceEntries.reduce((acc, entry) => {
      acc.total += entry.cost || 0;
      acc.counts[entry.type] = (acc.counts[entry.type] || 0) + 1;
      acc.amounts[entry.type] = (acc.amounts[entry.type] || 0) + (entry.cost || 0);
      return acc;
    }, {
      total: 0,
      counts: { tool: 0, layer: 0, cut: 0, finishing: 0 } as Record<'tool' | 'layer' | 'cut' | 'finishing', number>,
      amounts: { tool: 0, layer: 0, cut: 0, finishing: 0 } as Record<'tool' | 'layer' | 'cut' | 'finishing', number>
    });
  }, [serviceEntries]);

  const productPriceEntries = useMemo(() => {
    return wizardData.products.map((product, index) => {
      const isLayer = Boolean((product.meta as any)?.isLayer);
      let partLabel =
        product.productType === 'stair'
          ? (isLayer
              ? `Ù„Ø§ÛŒÙ‡ ${getPartDisplayLabel(product.stairPartType as StairStepperPart)}`
              : getPartDisplayLabel(product.stairPartType as StairStepperPart))
          : (product.productType === 'longitudinal'
              ? 'Ø·ÙˆÙ„ÛŒ'
              : product.productType === 'slab'
                ? 'Ø§Ø³Ù„Ø¨'
                : 'Ù…Ø­ØµÙˆÙ„');
      
      // Append "/Ø­Ú©Ù…ÛŒ" if mandatory option is activated
      if (product.isMandatory && product.mandatoryPercentage && product.mandatoryPercentage > 0) {
        partLabel = `${partLabel}/Ø­Ú©Ù…ÛŒ`;
      }
      const pricePerSqmValue = product.pricePerSquareMeter || null;
      const totalPriceValue = typeof product.totalPrice === 'number'
        ? product.totalPrice
        : parseFloat(String(product.totalPrice || '0')) || 0;
      // ğŸ¯ For layer products, get stone area used from meta
      const layerMeta = isLayer ? (product.meta as any) : null;
      const stoneAreaUsedSqm = layerMeta?.stoneAreaUsedSqm;
      return {
        key: `product-price-${index}-${product.productId}`,
        name: product.stoneName || product.product?.namePersian || product.product?.name || `Ù…Ø­ØµÙˆÙ„ ${index + 1}`,
        partLabel,
        quantity: product.quantity || 0,
        squareMeters: product.squareMeters || 0, // Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡
        stoneAreaUsedSqm: stoneAreaUsedSqm || null, // Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø§ØµÙ„ÛŒ (for layer products)
        isLayer,
        pricePerSquareMeter: pricePerSqmValue,
        totalPrice: totalPriceValue
      };
    });
  }, [wizardData.products]);

  const serviceTypeMeta: Record<'tool' | 'layer' | 'cut' | 'finishing', { label: string; badgeClass: string; chipClass: string }> = {
    tool: {
      label: 'Ø§Ø¨Ø²Ø§Ø±',
      badgeClass: 'bg-purple-100 text-purple-800 dark:bg-purple-900/40 dark:text-purple-200',
      chipClass: 'bg-purple-50 dark:bg-purple-900/20 text-purple-700 dark:text-purple-200 border border-purple-200 dark:border-purple-800'
    },
    layer: {
      label: 'Ù„Ø§ÛŒÙ‡',
      badgeClass: 'bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-200',
      chipClass: 'bg-amber-50 dark:bg-amber-900/20 text-amber-700 dark:text-amber-200 border border-amber-200 dark:border-amber-800'
    },
    cut: {
      label: 'Ø¨Ø±Ø´',
      badgeClass: 'bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-200',
      chipClass: 'bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-200 border border-blue-200 dark:border-blue-800'
    },
    finishing: {
      label: 'Ù¾Ø±Ø¯Ø§Ø®Øª',
      badgeClass: 'bg-teal-100 text-teal-800 dark:bg-teal-900/40 dark:text-teal-200',
      chipClass: 'bg-teal-50 dark:bg-teal-900/20 text-teal-700 dark:text-teal-200 border border-teal-200 dark:border-teal-700'
    }
  };

  const contractGrandTotal = productsSummary.totalPrice;
  const hasInvoiceData = wizardData.products.length > 0 || serviceEntries.length > 0;


  // Load data
  const [customers, setCustomers] = useState<CrmCustomer[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [departments, setDepartments] = useState<any[]>([]);
  const [userDepartment, setUserDepartment] = useState<string | null>(null);
  const [currentUser, setCurrentUser] = useState<{ firstName: string; lastName: string } | null>(null);
  const [cuttingTypes, setCuttingTypes] = useState<Array<{ code: string; pricePerMeter: number | null }>>([]);

  // Initialize product modal hook
  const productModal = useProductModal({
    useStairFlowV2,
    errors,
    setErrors
  });

  // Initialize product calculations hook with values from productModal
  const productCalculations = useProductCalculations({
    productConfig: productModal.productConfig,
    setProductConfig: productModal.setProductConfig,
    lengthUnit: productModal.lengthUnit,
    widthUnit: productModal.widthUnit,
    hasQuantityBeenInteracted: productModal.hasQuantityBeenInteracted,
    cuttingTypes,
    wizardData,
    selectedProduct: productModal.selectedProduct,
    isEditMode: productModal.isEditMode,
    isMandatory: productModal.isMandatory,
    mandatoryPercentage: productModal.mandatoryPercentage,
    errors,
    setErrors
  });

  // Initialize remaining stone modal hook
  const remainingStoneModal = useRemainingStoneModal({
    wizardData,
    updateWizardData,
    getCuttingTypePricePerMeter: productCalculations.getCuttingTypePricePerMeter,
    calculatePartitionPositions,
    setErrors,
    handleSmartCalculation: productCalculations.handleSmartCalculation,
    getEffectiveQuantity: productCalculations.getEffectiveQuantity
  });

  // Initialize sub-service modal hook
  const subServiceModal = useSubServiceModal({
    setErrors
  });

  // Initialize payment handlers hook
  const paymentHandlers = usePaymentHandlers({
    wizardData,
    updateWizardData,
    setErrors,
    getCurrentPersianDate
  });

  // Create aliases for easier refactoring (temporary - will remove after full migration)
  const selectedProduct = productModal.selectedProduct;
  const setSelectedProduct = productModal.setSelectedProduct;
  const productConfig = productModal.productConfig;
  const setProductConfig = productModal.setProductConfig;
  const lengthUnit = productModal.lengthUnit;
  const setLengthUnit = productModal.setLengthUnit;
  const widthUnit = productModal.widthUnit;
  const setWidthUnit = productModal.setWidthUnit;
  const isMandatory = productModal.isMandatory;
  const setIsMandatory = productModal.setIsMandatory;
  const mandatoryPercentage = productModal.mandatoryPercentage;
  const setMandatoryPercentage = productModal.setMandatoryPercentage;
  const isEditMode = productModal.isEditMode;
  const setIsEditMode = productModal.setIsEditMode;
  const editingProductIndex = productModal.editingProductIndex;
  const setEditingProductIndex = productModal.setEditingProductIndex;
  const touchedFields = productModal.touchedFields;
  const setTouchedFields = productModal.setTouchedFields;
  const stairSystemConfig = productModal.stairSystemConfig;
  const setStairSystemConfig = productModal.setStairSystemConfig;
  const quantityType = productModal.quantityType;
  const setQuantityType = productModal.setQuantityType;
  const treadExpanded = productModal.treadExpanded;
  const setTreadExpanded = productModal.setTreadExpanded;
  const riserExpanded = productModal.riserExpanded;
  const setRiserExpanded = productModal.setRiserExpanded;
  const landingExpanded = productModal.landingExpanded;
  const setLandingExpanded = productModal.setLandingExpanded;
  const showCADDesigner = productModal.showCADDesigner;
  const setShowCADDesigner = productModal.setShowCADDesigner;
  const showProductModal = productModal.showProductModal;
  const setShowProductModal = productModal.setShowProductModal;
  const hasQuantityBeenInteracted = productModal.hasQuantityBeenInteracted;
  const setHasQuantityBeenInteracted = productModal.setHasQuantityBeenInteracted;
  const treadProductSearchTerm = productModal.treadProductSearchTerm;
  const setTreadProductSearchTerm = productModal.setTreadProductSearchTerm;
  const riserProductSearchTerm = productModal.riserProductSearchTerm;
  const setRiserProductSearchTerm = productModal.setRiserProductSearchTerm;
  const landingProductSearchTerm = productModal.landingProductSearchTerm;
  const setLandingProductSearchTerm = productModal.setLandingProductSearchTerm;
  
  // Calculation handler aliases
  const getEffectiveQuantity = productCalculations.getEffectiveQuantity;
  const getQuantityDisplayValue = productCalculations.getQuantityDisplayValue;
  const getCuttingTypePricePerMeter = productCalculations.getCuttingTypePricePerMeter;
  const calculateAutoCuttingCost = productCalculations.calculateAutoCuttingCost;
  const handleSmartCalculation = productCalculations.handleSmartCalculation;
  const calculateStoneMetrics = productCalculations.calculateStoneMetrics;
  const calculateTreadMetrics = productCalculations.calculateTreadMetrics;
  const calculateRiserMetrics = productCalculations.calculateRiserMetrics;
  const calculateLandingMetrics = productCalculations.calculateLandingMetrics;
  const calculateNosingCuttingCost = productCalculations.calculateNosingCuttingCost;
  const getSlabStandardDimensions = productCalculations.getSlabStandardDimensions;
  const determineSlabLineCutPlan = productCalculations.determineSlabLineCutPlan;
  const generateFullProductName = productCalculations.generateFullProductName;
  const handleFieldFocus = productModal.handleFieldFocus;

  // Update productModal handlers to use calculation handlers
  // We need to create enhanced handlers that integrate smart calculation
  const handleLengthUnitChangeWithCalc = useCallback((newUnit: 'cm' | 'm') => {
    if (!productModal.productConfig.length) {
      productModal.setLengthUnit(newUnit);
      return;
    }
    
    const currentLength = productModal.productConfig.length;
    let convertedLength = currentLength;
    
    if (productModal.lengthUnit === 'cm' && newUnit === 'm') {
      convertedLength = currentLength / 100;
    } else if (productModal.lengthUnit === 'm' && newUnit === 'cm') {
      convertedLength = currentLength * 100;
    }
    
    productModal.setLengthUnit(newUnit);
    
    productModal.setProductConfig(prev => {
      const updatedConfig = { ...prev, length: convertedLength };
      const smartResult = productCalculations.handleSmartCalculation('length', convertedLength, updatedConfig, newUnit, productModal.widthUnit, productCalculations.getEffectiveQuantity());
      return {
        ...updatedConfig,
        width: smartResult.width,
        squareMeters: smartResult.squareMeters
      };
    });
  }, [productModal, productCalculations]);

  const handleWidthUnitChangeWithCalc = useCallback((newUnit: 'cm' | 'm') => {
    if (!productModal.productConfig.width) {
      productModal.setWidthUnit(newUnit);
      return;
    }
    
    const currentWidth = productModal.productConfig.width;
    let convertedWidth = currentWidth;
    
    if (productModal.widthUnit === 'cm' && newUnit === 'm') {
      convertedWidth = currentWidth / 100;
    } else if (productModal.widthUnit === 'm' && newUnit === 'cm') {
      convertedWidth = currentWidth * 100;
    }
    
    // Validate width after unit conversion
    if (productModal.selectedProduct) {
      const originalWidth = (productModal.isEditMode && productModal.productConfig.originalWidth) 
        ? productModal.productConfig.originalWidth 
        : (productModal.selectedProduct?.widthValue || 0);
      
      if (convertedWidth > 0 && originalWidth > 0) {
        const convertedWidthInCm = newUnit === 'm' ? convertedWidth * 100 : convertedWidth;
        if (convertedWidthInCm > originalWidth) {
          setErrors({ 
            products: `Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ (${convertedWidth}${newUnit === 'm' ? 'm' : 'cm'}) Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø³Ù†Ú¯ (${originalWidth}cm) Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ÛŒ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ Ø¨Ø§ ${originalWidth}cm ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.` 
          });
        } else {
          if (errors.products && errors.products.includes('Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡')) {
            setErrors({});
          }
        }
      }
    }
    
    productModal.setWidthUnit(newUnit);
    
    productModal.setProductConfig(prev => {
      const updatedConfig = { ...prev, width: convertedWidth };
      const smartResult = productCalculations.handleSmartCalculation('width', convertedWidth, updatedConfig, productModal.lengthUnit, newUnit, productCalculations.getEffectiveQuantity());
      return {
        ...updatedConfig,
        length: smartResult.length,
        squareMeters: smartResult.squareMeters
      };
    });
  }, [productModal, productCalculations, errors, setErrors]);

  // Filtered data based on search terms
  const filteredCustomers = useMemo(() => {
    if (!customerSearchTerm.trim()) {
      // Show only last 2 customers as preview when no search term
      return customers.slice(0, 2);
    }
    
    // Show full filtered list when searching
    const searchLower = customerSearchTerm.toLowerCase();
    return customers.filter(customer => 
      customer.firstName.toLowerCase().includes(searchLower) ||
      customer.lastName.toLowerCase().includes(searchLower) ||
      (customer.companyName && customer.companyName.toLowerCase().includes(searchLower)) ||
      (customer.nationalCode && customer.nationalCode.includes(searchLower)) ||
      (customer.homeNumber && customer.homeNumber.includes(searchLower)) ||
      (customer.workNumber && customer.workNumber.includes(searchLower)) ||
      (customer.phoneNumbers && customer.phoneNumbers.some(phone => 
        phone.number.includes(searchLower) || 
        phone.number.replace(/\s+/g, '').includes(searchLower.replace(/\s+/g, ''))
      ))
    );
  }, [customers, customerSearchTerm]);

  const filteredProducts = useMemo(() => {
    // Require search term to show products - no preview of latest products
    if (!productSearchTerm.trim()) {
      return [];
    }
    
    const selectedType = wizardData.selectedProductTypeForAddition as ContractUsageType | null;
    const eligibleProducts = selectedType
      ? products.filter(product => productSupportsContractType(product, selectedType))
      : products;
    
    const searchLower = productSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    
    return eligibleProducts.filter(product => {
      // Create a comprehensive search string that includes all searchable fields
      const searchableFields = [
        product.code,
        product.namePersian,
        product.name,
        product.cuttingDimensionNamePersian,
        product.stoneTypeNamePersian,
        product.widthName,
        product.thicknessName,
        product.mineNamePersian,
        product.finishNamePersian,
        product.colorNamePersian,
        product.qualityNamePersian,
        product.description,
        product.currency,
        // Include numeric values as strings for searching
        product.widthValue?.toString(),
        product.thicknessValue?.toString(),
        product.basePrice?.toString(),
        // Include dimension combinations
        `${product.widthValue}Ã—${product.thicknessValue}`,
        `Ø¹Ø±Ø¶ ${product.widthValue}Ã—Ø¶Ø®Ø§Ù…Øª ${product.thicknessValue}`,
        // Include full product name generation
        `${product.stoneTypeNamePersian} ${product.cuttingDimensionNamePersian} Ø¹Ø±Ø¶ ${product.widthValue}Ã—Ø¶Ø®Ø§Ù…Øª ${product.thicknessValue}cm ${product.mineNamePersian} ${product.finishNamePersian} ${product.colorNamePersian} ${product.qualityNamePersian}`
      ].filter(Boolean);
      
      // Create a single searchable text
      const searchableText = searchableFields.join(' ').toLowerCase();
      
      // If only one search term, use simple includes
      if (searchTerms.length === 1) {
        return searchableText.includes(searchTerms[0]);
      }
      
      // If multiple search terms, all must be found (AND logic)
      return searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, productSearchTerm, wizardData.selectedProductTypeForAddition]);
  
  // Filtered products for each stair part (independent product selection)
  const filteredTreadProducts = useMemo(() => {
    const stairEligibleProducts = products.filter(product => productSupportsContractType(product, 'stair'));
    if (!treadProductSearchTerm.trim()) {
      return stairEligibleProducts.slice(-3);
    }
    const searchLower = treadProductSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    return stairEligibleProducts.filter(product => {
      const searchableFields = [
        product.code, product.namePersian, product.name,
        product.cuttingDimensionNamePersian, product.stoneTypeNamePersian,
        product.widthName, product.thicknessName, product.mineNamePersian,
        product.finishNamePersian, product.colorNamePersian, product.qualityNamePersian,
        product.widthValue?.toString(), product.thicknessValue?.toString(),
        product.basePrice?.toString()
      ].filter(Boolean);
      const searchableText = searchableFields.join(' ').toLowerCase();
      return searchTerms.length === 1 
        ? searchableText.includes(searchTerms[0])
        : searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, treadProductSearchTerm]);
  
  const filteredRiserProducts = useMemo(() => {
    const stairEligibleProducts = products.filter(product => productSupportsContractType(product, 'stair'));
    if (!riserProductSearchTerm.trim()) {
      return stairEligibleProducts.slice(-3);
    }
    const searchLower = riserProductSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    return stairEligibleProducts.filter(product => {
      const searchableFields = [
        product.code, product.namePersian, product.name,
        product.cuttingDimensionNamePersian, product.stoneTypeNamePersian,
        product.widthName, product.thicknessName, product.mineNamePersian,
        product.finishNamePersian, product.colorNamePersian, product.qualityNamePersian,
        product.widthValue?.toString(), product.thicknessValue?.toString(),
        product.basePrice?.toString()
      ].filter(Boolean);
      const searchableText = searchableFields.join(' ').toLowerCase();
      return searchTerms.length === 1 
        ? searchableText.includes(searchTerms[0])
        : searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, riserProductSearchTerm]);
  
  const filteredLandingProducts = useMemo(() => {
    const stairEligibleProducts = products.filter(product => productSupportsContractType(product, 'stair'));
    if (!landingProductSearchTerm.trim()) {
      return stairEligibleProducts.slice(-3);
    }
    const searchLower = landingProductSearchTerm.toLowerCase().trim();
    const searchTerms = searchLower.split(/\s+/).filter(term => term.length > 0);
    return stairEligibleProducts.filter(product => {
      const searchableFields = [
        product.code, product.namePersian, product.name,
        product.cuttingDimensionNamePersian, product.stoneTypeNamePersian,
        product.widthName, product.thicknessName, product.mineNamePersian,
        product.finishNamePersian, product.colorNamePersian, product.qualityNamePersian,
        product.widthValue?.toString(), product.thicknessValue?.toString(),
        product.basePrice?.toString()
      ].filter(Boolean);
      const searchableText = searchableFields.join(' ').toLowerCase();
      return searchTerms.length === 1 
        ? searchableText.includes(searchTerms[0])
        : searchTerms.every(term => searchableText.includes(term));
    });
  }, [products, landingProductSearchTerm]);

  useEffect(() => {
    loadInitialData();
    
    // Check for return from quick create
    const urlParams = new URLSearchParams(window.location.search);
    const returnTo = urlParams.get('returnTo');
    const step = urlParams.get('step');
    
    console.log('ğŸ” Contract wizard useEffect triggered:', {
      returnTo,
      step,
      currentStep,
      stateRestored
    });
    
    if (returnTo === 'contract' && step && !restorationAttempted.current) {
      // Restore wizard state from localStorage
      const savedState = localStorage.getItem('contractWizardState');
      console.log('ğŸ’¾ Saved state from localStorage:', savedState);
      
      if (savedState) {
        try {
          const { currentStep: savedStep, wizardData: savedWizardData } = JSON.parse(savedState);
          console.log('ğŸ”„ Restoring wizard state:', {
            urlStep: step,
            savedStep,
            savedWizardData,
            currentStepBeforeRestore: currentStep
          });
          
          // Use the saved step instead of URL step parameter
          setCurrentStep(savedStep);
          setWizardData(savedWizardData);
          setStateRestored(true);
          restorationAttempted.current = true;
          
          // Clear the saved state after successful restoration
          localStorage.removeItem('contractWizardState');
          
          // Refresh data to show newly created entities
          console.log('ğŸ”„ Refreshing data after successful creation...');
          loadInitialData();
          
          console.log('âœ… Wizard state restored successfully to step:', savedStep);
        } catch (error) {
          console.error('âŒ Error restoring wizard state:', error);
          // If restoration fails, use URL step as fallback
          setCurrentStep(parseInt(step));
          setStateRestored(true);
          restorationAttempted.current = true;
          
          // Refresh data to show newly created entities
          console.log('ğŸ”„ Refreshing data after successful creation (fallback)...');
          loadInitialData();
        }
      } else {
        // If no saved state, use URL step as fallback
        console.log('âš ï¸ No saved state found, using URL step:', step);
        setCurrentStep(parseInt(step));
        setStateRestored(true);
        restorationAttempted.current = true;
        
        // Refresh data to show newly created entities
        console.log('ğŸ”„ Refreshing data after successful creation (no saved state)...');
        loadInitialData();
      }
    }
  }, []);


  // Debug effect to track currentStep changes
  useEffect(() => {
    console.log('ğŸ“Š currentStep changed to:', currentStep);
  }, [currentStep]);

  const loadInitialData = async () => {
    try {
      setLoading(true);
      
      // Load user profile to get department and user info
      const profileResponse = await dashboardAPI.getProfile();
      if (profileResponse.data.success) {
        const userData = profileResponse.data.data;
        setUserDepartment(userData.departmentId);
        setCurrentUser({
          firstName: userData.firstName || '',
          lastName: userData.lastName || ''
        });
        console.log('User department:', userData.departmentId);
        console.log('Current user:', userData.firstName, userData.lastName);
      }
      
      // Load customers from CRM
      const customersResponse = await crmAPI.getCustomers();
      if (customersResponse.data.success) {
        setCustomers(customersResponse.data.data);
      }
      
      // Load ALL products from Sales (no pagination for contract wizard)
      const productsResponse = await salesAPI.getProducts({ limit: 1000 });
      if (productsResponse.data.success) {
        setProducts(productsResponse.data.data);
        console.log('All products loaded for contract wizard:', productsResponse.data.data.length);
      }
      
      // Load departments
      const departmentsResponse = await salesAPI.getDepartments();
      console.log('Departments response:', departmentsResponse.data);
      if (departmentsResponse.data.success) {
        setDepartments(departmentsResponse.data.data);
        console.log('Departments loaded:', departmentsResponse.data.data);
      }
      
      // Load cutting types (for automatic cutting cost calculation)
      const cuttingTypesResponse = await servicesAPI.getCuttingTypes({ isActive: true });
      if (cuttingTypesResponse.data.success) {
        setCuttingTypes(cuttingTypesResponse.data.data);
        console.log('Cutting types loaded:', cuttingTypesResponse.data.data);
      }
      
  // Load sub-services (Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§) - load all active ones with high limit
      const subServicesResponse = await servicesAPI.getSubServices({ isActive: true, limit: 1000 });
      if (subServicesResponse.data.success) {
        setSubServices(subServicesResponse.data.data);
        console.log('Sub-services loaded:', subServicesResponse.data.data.length, 'items');
      } else {
        console.error('Failed to load sub-services:', subServicesResponse.data);
      }

      // Load stone finishings (Ù¾Ø±Ø¯Ø§Ø®Øªâ€ŒÙ‡Ø§)
      const finishingsResponse = await servicesAPI.getStoneFinishings({ isActive: true, limit: 1000 });
      if (finishingsResponse.data.success) {
        setStoneFinishings(finishingsResponse.data.data);
        console.log('Stone finishings loaded:', finishingsResponse.data.data.length, 'items');
      } else {
        console.error('Failed to load stone finishings:', finishingsResponse.data);
      }
      
      // Generate next contract number
      await generateContractNumber();
      
    } catch (error) {
      console.error('Error loading initial data:', error);
      setErrors({ general: 'Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡' });
    } finally {
      setLoading(false);
    }
  };

  const generateContractNumber = async () => {
    try {
      // Get next contract number from backend
      const response = await salesAPI.getNextContractNumber();
      if (response.data.success) {
        setWizardData(prev => ({
          ...prev,
          contractNumber: response.data.data.contractNumber
        }));
      }
    } catch (error) {
      console.error('Error generating contract number:', error);
      // Fallback to manual generation
      const contractCount = Math.floor(Math.random() * 1000) + 1000;
      setWizardData(prev => ({
        ...prev,
        contractNumber: String(contractCount)
      }));
    }
  };

  // updateWizardData is now provided by useContractWizard hook

  // Helper function to update stair system config
  const updateStairSystemConfig = (updates: Partial<StairSystemConfig> | ((prev: StairSystemConfig | null) => StairSystemConfig | null)) => {
    setStairSystemConfig(prev => {
      if (!prev) return prev;
      if (typeof updates === 'function') {
        return updates(prev);
      }
      return { ...prev, ...updates };
    });
  };
  
  // Helper function to update a specific stair part
  const updateStairPart = (partType: 'tread' | 'riser' | 'landing', updates: Partial<StairPart>) => {
    setStairSystemConfig(prev => {
      if (!prev) return prev;
      return {
        ...prev,
        [partType]: { ...prev[partType], ...updates }
      };
    });
  };
  
  const syncDraftWithProduct = (partType: 'tread' | 'riser' | 'landing', product: Product | null) => {
    const updater =
      partType === 'tread' ? stairSystemV2.setDraftTread :
      partType === 'riser' ? stairSystemV2.setDraftRiser :
      stairSystemV2.setDraftLanding;

    // ğŸ¯ Use generateFullProductName to show complete product name
    const productLabel = product ? generateFullProductName(product) : '';
    updater(prev => ({
      ...prev,
      stoneId: product ? product.id : null,
      stoneLabel: productLabel,
      stoneProduct: product,
      pricePerSquareMeter: product ? (product.basePrice || (product as any).pricePerSquareMeter || 0) : null,
      thicknessCm: product ? (product.thicknessValue ?? null) : null
    }));

    if (product) {
      stairSystemV2.setLastSelectedStoneProduct(product);
      stairSystemV2.setAutoFillOptOut(prev => ({ ...prev, [partType]: false }));
      stairSystemV2.setStairDraftErrors(prev => ({
        ...prev,
        [partType]: {
          ...prev[partType],
          thickness: undefined,
          pricePerSquareMeter: undefined
        }
      }));
    } else {
      stairSystemV2.setAutoFillOptOut(prev => ({ ...prev, [partType]: true }));
    }

    if (productLabel) {
      stairSystemV2.setLastSelectedStoneLabel(productLabel);
    }

    if (stairSystemV2.stairActivePart === partType) {
      stairSystemV2.setStoneSearchTerm(productLabel || stairSystemV2.lastSelectedStoneLabel);
    }
  };

  const setActivePart = (part: StairStepperPart) => {
    stairSystemV2.setStairActivePart(part);
    const currentDraft =
      part === 'tread' ? stairSystemV2.draftTread :
      part === 'riser' ? stairSystemV2.draftRiser :
      stairSystemV2.draftLanding;
    if (!currentDraft.stoneId && stairSystemV2.lastSelectedStoneProduct && !stairSystemV2.autoFillOptOut[part]) {
      selectProductForStairPart(part, stairSystemV2.lastSelectedStoneProduct);
    }
    // Note: Search term will be synced via useEffect below to ensure we read latest state
  };

  // Sync search term when active part changes - ensures we read latest draft state
  // This ensures each part maintains its own product selection independently
  useEffect(() => {
    // Get the draft for the currently active part
    const draft = 
      stairSystemV2.stairActivePart === 'tread' ? stairSystemV2.draftTread :
      stairSystemV2.stairActivePart === 'riser' ? stairSystemV2.draftRiser :
      stairSystemV2.draftLanding;
    
    // Extract the product label from the draft
    // Priority: stoneLabel (explicitly set with full name) > generateFullProductName from stoneProduct > fallback
    const label = draft.stoneLabel || 
                  (draft.stoneProduct ? generateFullProductName(draft.stoneProduct) : '') ||
                  draft.stoneProduct?.namePersian || 
                  draft.stoneProduct?.name || '';
    
    // Update search term to reflect the active part's product selection
    // This ensures when switching parts, the search term shows the product for that part
    stairSystemV2.setStoneSearchTerm(label);
  }, [
    stairSystemV2.stairActivePart,
    // Track all draft changes - React will optimize, but we need to react to any part's changes
    // when switching to that part, we want the latest state
    stairSystemV2.draftTread.stoneProduct?.id,
    stairSystemV2.draftTread.stoneLabel,
    stairSystemV2.draftRiser.stoneProduct?.id,
    stairSystemV2.draftRiser.stoneLabel,
    stairSystemV2.draftLanding.stoneProduct?.id,
    stairSystemV2.draftLanding.stoneLabel
  ]);

  // Helper function to select a product for a specific stair part
  const selectProductForStairPart = (partType: 'tread' | 'riser' | 'landing', product: Product) => {
    updateStairPart(partType, {
      productId: product.id,
      product: product,
      pricePerSquareMeter: product.basePrice || 0
    });
    syncDraftWithProduct(partType, product);
  };
  
  // Handle product selection and open configuration modal
  const handleProductSelection = (product: Product) => {
    console.log('ğŸ¯ Product Selected:', {
      id: product.id,
      name: product.namePersian,
      widthValue: product.widthValue,
      code: product.code,
      basePrice: product.basePrice,
      productType: wizardData.selectedProductTypeForAddition
    });
    
    setSelectedProduct(product);
    
    const selectedProductType = wizardData.selectedProductTypeForAddition;
    
    // Initialize product configuration based on product type
    if (selectedProductType === 'stair') {
      // Check if using new V2 flow
      if (useStairFlowV2) {
        // NEW V2 FLOW: Pre-fill the selected product in the active draft
        const [currentDraft, setCurrentDraft] = getActiveDraft();
        const productLabel = product.namePersian || product.name || '';
        
        // Pre-fill the active draft with selected product
        setCurrentDraft({
          ...currentDraft,
          stoneId: product.id,
          stoneLabel: productLabel,
          stoneProduct: product,
          pricePerSquareMeter: product.basePrice || 0,
          thicknessCm: product.thicknessValue || null // Ù‚Ø·Ø± = Ø¶Ø®Ø§Ù…Øª (thickness), not Ø¹Ø±Ø¶ (width)
        });
        
        // Pre-fill search term to show the selected product
        stairSystemV2.setStoneSearchTerm(productLabel);
        
        // Set product config for modal type detection
        setProductConfig({
          productId: product.id,
          product: product,
          productType: 'stair'
        });
      } else {
        // OLD FLOW: Initialize for stair system (Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡)
        const stairConfig = initializeStairSystemConfig(product);
        setStairSystemConfig(stairConfig);
        
        // Also set old config for backward compatibility (will be removed later)
        const defaultConfig: Partial<ContractProduct> = {
          productId: product.id,
          product: product,
          productType: 'stair',
          stoneCode: product.code,
          stoneName: product.namePersian,
          diameterOrWidth: product.widthValue,
          length: 0,
          width: 0,
          quantity: 1,
          squareMeters: 0,
          pricePerSquareMeter: product.basePrice || 0,
          totalPrice: 0,
          description: '',
          currency: 'ØªÙˆÙ…Ø§Ù†',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: false,
          mandatoryPercentage: 20,
          originalTotalPrice: 0,
          isCut: false,
          cutType: null,
          originalWidth: product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0
        };
        setProductConfig(defaultConfig);
        setTreadWidthUnit('m');
        setQuantityType('steps');
        // Reset collapsible sections
        setTreadExpanded(true);
        setRiserExpanded(true);
        setLandingExpanded(false);
        // Reset product search terms
        setTreadProductSearchTerm('');
        setRiserProductSearchTerm('');
        setLandingProductSearchTerm('');
      }
    } else if (selectedProductType === 'slab') {
      // Initialize for slab stone
      const defaultStandardWidthCm = product.widthValue || 0;
      const defaultStandardLengthCm = (product as any)?.lengthValue || 300;
      const defaultOriginalLength = lengthUnit === 'm'
        ? defaultStandardLengthCm / 100
        : defaultStandardLengthCm;
      const defaultConfig: Partial<ContractProduct> = {
        productId: product.id,
        product: product,
        productType: 'slab',
        stoneCode: product.code,
        stoneName: product.namePersian,
        diameterOrWidth: product.widthValue, // Use product's width as constant
        length: 0,
        width: 0, // No default value - user must input
        quantity: 1,
        squareMeters: 0,
        pricePerSquareMeter: product.basePrice || 0,
        totalPrice: 0,
        description: '',
        currency: 'ØªÙˆÙ…Ø§Ù†',
        // Initialize stone cutting fields for 2D cutting
        isCut: false,
        originalWidth: defaultStandardWidthCm,
        originalLength: defaultOriginalLength,
        cuttingCost: 0,
        cuttingCostPerMeter: 0,
        remainingStones: [],
        cutDetails: [],
        // Legacy single standard dimension fields (kept for backward compatibility)
        slabStandardLengthCm: defaultStandardLengthCm,
        slabStandardWidthCm: defaultStandardWidthCm,
        // New multiple standard dimensions support
        slabStandardDimensions: [],
        slabCuttingMode: 'lineBased',
        slabCuttingPricePerSquareMeter: 0,
        slabLineCuttingStrategy: 'length',
        slabLineCuttingLongitudinalMeters: null,
        slabLineCuttingCrossMeters: null,
        // Initialize Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… (vertical edge cuts) - all 4 sides active by default
        slabVerticalCutSides: {
          top: true,
          bottom: true,
          left: true,
          right: true
        },
        slabVerticalCutCost: 0,
        slabVerticalCutCostPerMeter: 0,
        // Initialize remaining stone tracking
        usedRemainingStones: [],
        totalUsedRemainingWidth: 0,
        totalUsedRemainingLength: 0,
        // Initialize SubService tracking
        appliedSubServices: [],
        totalSubServiceCost: 0,
        usedLengthForSubServices: 0,
        usedSquareMetersForSubServices: 0
      };
      
      setProductConfig(defaultConfig);
      setLengthUnit('m');
      setWidthUnit('cm');
    } else {
      // Initialize for longitudinal stone (existing logic)
      const defaultConfig: Partial<ContractProduct> = {
        productId: product.id,
        product: product,
        productType: 'longitudinal',
        stoneCode: product.code,
        stoneName: product.namePersian,
        diameterOrWidth: product.widthValue, // Use product's width as constant
        length: 0,
        width: 0, // No default value - user must input
        quantity: 1,
        squareMeters: 0,
        pricePerSquareMeter: product.basePrice || 0,
        totalPrice: 0,
        description: '',
        currency: 'ØªÙˆÙ…Ø§Ù†', // Change from Rial to Toman
        // Initialize stone cutting fields
        isCut: false,
        originalWidth: product.widthValue,
        originalLength: 0, // Will be set when user enters length
        cuttingCost: 0,
        cuttingCostPerMeter: 0,
        remainingStones: [],
        cutDetails: [],
        // Initialize remaining stone tracking
        usedRemainingStones: [],
        totalUsedRemainingWidth: 0,
        totalUsedRemainingLength: 0,
        // Initialize SubService tracking
        appliedSubServices: [],
        totalSubServiceCost: 0,
        usedLengthForSubServices: 0,
        usedSquareMetersForSubServices: 0
      };
      
      setProductConfig(defaultConfig);
      setLengthUnit('m');
      setWidthUnit('cm');
    }
    
    setIsEditMode(false);
    setEditingProductIndex(null);
    setHasQuantityBeenInteracted(false); // Reset quantity interaction tracking
    setTouchedFields(new Set()); // Reset touched fields for new product
    setErrors({}); // Clear errors when opening modal
    setShowProductModal(true);
    
    console.log('ğŸ¯ Modal State Initialized:', {
      productType: selectedProductType,
      pricePerSquareMeter: productConfig.pricePerSquareMeter
    });
  };

  // Handle unit conversion for length
  const handleLengthUnitChange = (newUnit: 'cm' | 'm') => {
    if (!productConfig.length) return;
    
    const currentLength = productConfig.length;
    let convertedLength = currentLength;
    
    if (lengthUnit === 'cm' && newUnit === 'm') {
      // Convert cm to m
      convertedLength = currentLength / 100;
    } else if (lengthUnit === 'm' && newUnit === 'cm') {
      // Convert m to cm
      convertedLength = currentLength * 100;
    }
    
    console.log('ğŸ”„ Length Unit Conversion:', {
      from: lengthUnit,
      to: newUnit,
      original: currentLength,
      converted: convertedLength
    });
    
    setLengthUnit(newUnit);
    setProductConfig(prev => {
      const updatedConfig = { ...prev, length: convertedLength };
      // Trigger smart calculation with new unit
      const smartResult = handleSmartCalculation('length', convertedLength, updatedConfig, newUnit, widthUnit, getEffectiveQuantity());
      console.log('ğŸ”„ Length Unit Change Result:', {
        originalLength: currentLength,
        convertedLength,
        newUnit,
        smartResult,
        finalSquareMeters: smartResult.squareMeters
      });
      return {
        ...updatedConfig,
        width: smartResult.width,
        squareMeters: smartResult.squareMeters
      };
    });
  };

  // Handle unit conversion for width
  const handleWidthUnitChange = (newUnit: 'cm' | 'm') => {
    if (!productConfig.width) return;
    
    const currentWidth = productConfig.width;
    let convertedWidth = currentWidth;
    
    if (widthUnit === 'cm' && newUnit === 'm') {
      // Convert cm to m
      convertedWidth = currentWidth / 100;
    } else if (widthUnit === 'm' && newUnit === 'cm') {
      // Convert m to cm
      convertedWidth = currentWidth * 100;
    }
    
    console.log('ğŸ”„ Width Unit Conversion:', {
      from: widthUnit,
      to: newUnit,
      original: currentWidth,
      converted: convertedWidth
    });
    
    // Validate width after unit conversion
    const originalWidth = (isEditMode && productConfig.originalWidth) 
      ? productConfig.originalWidth 
      : (selectedProduct?.widthValue || 0);
    
    if (convertedWidth > 0 && originalWidth > 0) {
      const convertedWidthInCm = newUnit === 'm' ? convertedWidth * 100 : convertedWidth;
      if (convertedWidthInCm > originalWidth) {
        // Show error message
        setErrors({ 
          products: `Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ (${convertedWidth}${newUnit === 'm' ? 'm' : 'cm'}) Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø³Ù†Ú¯ (${originalWidth}cm) Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ÛŒ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ Ø¨Ø§ ${originalWidth}cm ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.` 
        });
      } else {
        // Clear error if width is valid after unit conversion
        if (errors.products && errors.products.includes('Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡')) {
          setErrors({});
        }
      }
    }
    
    setWidthUnit(newUnit);
    setProductConfig(prev => {
      const updatedConfig = { ...prev, width: convertedWidth };
      // Trigger smart calculation with new unit
      const smartResult = handleSmartCalculation('width', convertedWidth, updatedConfig, lengthUnit, newUnit, getEffectiveQuantity());
      console.log('ğŸ”„ Width Unit Change Result:', {
        originalWidth: currentWidth,
        convertedWidth,
        newUnit,
        smartResult,
        finalSquareMeters: smartResult.squareMeters
      });
      return {
        ...updatedConfig,
        length: smartResult.length,
        squareMeters: smartResult.squareMeters
      };
    });
    
    // Log stone cutting eligibility after unit change
    console.log('ğŸ“ Width Unit Changed:', {
      userWidth: convertedWidth,
      userWidthUnit: newUnit,
      userWidthInCm: newUnit === 'm' ? convertedWidth * 100 : convertedWidth
    });
  };

  // Remaining stone handlers are now provided by useRemainingStoneModal hook
  // Handle editing an existing product
  const handleEditProduct = (index: number) => {
    console.log('ğŸ”µ handleEditProduct called:', { index, totalProducts: wizardData.products.length });
    const product = wizardData.products[index];
    if (!product) {
      console.error('âŒ Product not found at index:', index);
      return;
    }
    console.log('ğŸ”µ Product found:', { productType: product.productType, stairSystemId: product.stairSystemId });
    
    // Check if this is a stair system product
    if (product.productType === 'stair' && product.stairSystemId) {
      // Handle stair system editing
      // Find all products with the same stairSystemId
      const stairSystemProducts = wizardData.products.filter(p => 
        p.productType === 'stair' && 
        p.stairSystemId === product.stairSystemId
      );
      
      // Find tread, riser, and landing products (exclude layer products)
      const treadProduct = stairSystemProducts.find(p => 
        p.stairPartType === 'tread' && !((p.meta as any)?.isLayer)
      );
      const riserProduct = stairSystemProducts.find(p => 
        p.stairPartType === 'riser' && !((p.meta as any)?.isLayer)
      );
      const landingProduct = stairSystemProducts.find(p => 
        p.stairPartType === 'landing' && !((p.meta as any)?.isLayer)
      );
      
      // Check if using new V2 flow
      if (useStairFlowV2) {
        // NEW V2 FLOW: Reconstruct session items and drafts
        // Set session ID to existing stairSystemId
        stairSystemV2.setStairSessionId(product.stairSystemId);
        
        // Reconstruct session items from existing products
        stairSystemV2.setStairSessionItems([...stairSystemProducts]);
        
        // Helper function to convert ContractProduct to StairPartDraftV2
        const productToDraft = (p: ContractProduct, partType: StairStepperPart): StairPartDraftV2 => {
          const tools = (p.meta as any)?.tools || [];
          const layerInfo = (p.meta as any)?.layerInfo || null;
          // For layer products, extract layer info from meta
          // For regular products, layer info should be null
          const isLayer = (p.meta as any)?.isLayer || false;
          
          return {
            stoneId: p.productId,
            stoneLabel: p.stoneName,
            stoneProduct: p.product,
            pricePerSquareMeter: p.pricePerSquareMeter,
            useMandatory: typeof p.isMandatory === 'boolean' ? p.isMandatory : undefined,
            mandatoryPercentage: p.isMandatory
              ? (p.mandatoryPercentage || 20)
              : (p.mandatoryPercentage ?? null),
            thicknessCm: p.diameterOrWidth,
            lengthValue: p.length,
            lengthUnit: p.lengthUnit || 'm', // Default to meters for length
            widthCm: p.width,
            quantity: p.quantity,
            squareMeters: p.squareMeters,
            tools: tools.map((t: any) => ({
              toolId: t.toolId,
              name: t.name,
              pricePerMeter: t.pricePerMeter,
              front: t.edges?.front || false,
              left: t.edges?.left || false,
              right: t.edges?.right || false,
              back: t.edges?.back || false,
              perimeter: t.edges?.perimeter || false,
              computedMeters: t.computedMeters,
              totalPrice: t.totalPrice
            })),
            totalPrice: p.totalPrice,
            // Load layer fields if this is a layer product or if layer info exists
            // Note: layerPricePerSquareMeter is not needed - layers use the same price as the main stair part
            numberOfLayersPerStair: isLayer && layerInfo ? layerInfo.numberOfLayersPerStair : null,
            layerWidthCm: isLayer ? p.width : null,
            standardLengthValue: partType === 'riser'
              ? null
              : p.standardLengthValue ?? (p.meta as any)?.stair?.standardLength?.value ?? null,
            standardLengthUnit: partType === 'riser'
              ? (p.lengthUnit || 'm')
              : (p.standardLengthUnit as UnitType) ?? (p.meta as any)?.stair?.standardLength?.unit ?? (p.lengthUnit || 'm'),
            finishingEnabled: !!p.finishingId,
            finishingId: p.finishingId || null,
            finishingLabel: p.finishingName || null,
            finishingPricePerSquareMeter: p.finishingPricePerSquareMeter || null
          };
        };
        
        // Helper function to find and merge layer info into draft
        const mergeLayerInfo = (draft: StairPartDraftV2, partType: 'tread' | 'riser' | 'landing'): StairPartDraftV2 => {
          // Find layer product for this part type
          const layerProduct = stairSystemProducts.find(p => 
            (p.meta as any)?.isLayer && 
            (p.meta as any)?.layerInfo?.parentPartType === partType
          );
          
          if (layerProduct) {
            const layerInfo = (layerProduct.meta as any)?.layerInfo;
            const layerTypeMeta = (layerProduct.meta as any)?.layerType;
            const layerAltStoneMeta = (layerProduct.meta as any)?.layerAltStone;
            return {
              ...draft,
              numberOfLayersPerStair: layerInfo?.numberOfLayersPerStair || null,
              layerWidthCm: layerProduct.width || null,
              layerEdges: ((layerProduct.meta as any)?.layerEdges) || undefined,
              layerTypeId: layerProduct.layerTypeId ?? layerTypeMeta?.id ?? null,
              layerTypeName: layerProduct.layerTypeName ?? layerTypeMeta?.name ?? null,
              layerTypePrice: layerProduct.layerTypePrice ?? layerTypeMeta?.pricePerLayer ?? null,
              layerUseDifferentStone: layerProduct.layerUseDifferentStone || !!layerAltStoneMeta,
              layerStoneProductId: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerStoneProductId || layerAltStoneMeta?.id || layerProduct.productId)
                : null,
              layerStoneProduct: layerProduct.layerUseDifferentStone ? layerProduct.product : null,
              layerStoneLabel: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerStoneName || layerAltStoneMeta?.name || layerProduct.stoneName)
                : null,
              layerPricePerSquareMeter: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerStoneBasePricePerSquareMeter || layerAltStoneMeta?.basePricePerSquareMeter || layerProduct.layerStonePricePerSquareMeter || layerProduct.pricePerSquareMeter)
                : draft.pricePerSquareMeter,
              layerUseMandatory: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerUseMandatory ?? ((layerAltStoneMeta?.mandatoryPercentage ?? 0) > 0))
                : undefined,
              layerMandatoryPercentage: layerProduct.layerUseDifferentStone
                ? (layerProduct.layerMandatoryPercentage ?? layerAltStoneMeta?.mandatoryPercentage ?? 20)
                : null
            };
          }
          return draft;
        };
        
        // Load each part into its respective draft and merge layer info
        if (treadProduct) {
          const baseDraft = productToDraft(treadProduct, 'tread');
          stairSystemV2.setDraftTread(normalizeLayerAltStoneSettings(mergeLayerInfo(baseDraft, 'tread')));
        }
        if (riserProduct) {
          const baseDraft = productToDraft(riserProduct, 'riser');
          stairSystemV2.setDraftRiser(normalizeLayerAltStoneSettings(mergeLayerInfo(baseDraft, 'riser')));
        }
        if (landingProduct) {
          const baseDraft = productToDraft(landingProduct, 'landing');
          stairSystemV2.setDraftLanding(normalizeLayerAltStoneSettings(mergeLayerInfo(baseDraft, 'landing')));
        }
        
        // Set active part to the first available part
        if (treadProduct) {
          setActivePart('tread');
        } else if (riserProduct) {
          setActivePart('riser');
        } else if (landingProduct) {
          setActivePart('landing');
        }
        
        // Set product config for modal type detection
        setProductConfig({
          productId: product.productId,
          product: product.product,
          productType: 'stair'
        });
        
        // Set product type for wizard
        updateWizardData({ selectedProductTypeForAddition: 'stair' });
        
        setIsEditMode(true);
        setEditingProductIndex(index);
        setTouchedFields(new Set());
        setErrors({});
        setShowProductModal(true);
        
        console.log('âœ… Stair V2 edit initialized:', {
          stairSystemId: product.stairSystemId,
          sessionItems: stairSystemProducts.length,
          partsFound: {
            tread: !!treadProduct,
            riser: !!riserProduct,
            landing: !!landingProduct
          }
        });
        
        return;
      }
      
      // OLD FLOW: Continue with existing logic
      
      // Get common stair system info from first product
      const firstProduct = stairSystemProducts[0] || product;
      const numberOfSteps = firstProduct.numberOfSteps || 0;
      const quantityType = firstProduct.quantityType || 'steps';
      // numberOfStaircases is stored in the product, but we'll default to 1 if not found
      // This is a common field across all parts of the same stair system
      const numberOfStaircases = quantityType === 'staircases' ? Math.max(1, Math.floor(numberOfSteps / Math.max(1, (treadProduct?.quantity || numberOfSteps)))) : 1;
      
      // Reconstruct stair system config
      const editedStairConfig: StairSystemConfig = {
        numberOfSteps: numberOfSteps,
        quantityType: quantityType as 'steps' | 'staircases',
        numberOfStaircases: numberOfStaircases,
        defaultProduct: null,
        tread: {
          partType: 'tread',
          isSelected: !!treadProduct,
          productId: treadProduct?.productId || null,
          product: treadProduct?.product || null,
          treadWidth: treadProduct?.treadWidth || 0,
          treadDepth: treadProduct?.treadDepth || 30,
          quantity: treadProduct?.quantity || numberOfSteps || 0,
          squareMeters: treadProduct?.squareMeters || 0,
          pricePerSquareMeter: treadProduct?.pricePerSquareMeter || 0,
          totalPrice: treadProduct?.totalPrice || 0,
          nosingType: treadProduct?.nosingType || 'none',
          nosingOverhang: treadProduct?.nosingOverhang || 30,
          nosingCuttingCost: treadProduct?.nosingCuttingCost || 0,
          nosingCuttingCostPerMeter: treadProduct?.nosingCuttingCostPerMeter || 0,
          isMandatory: treadProduct?.isMandatory || false,
          mandatoryPercentage: treadProduct?.mandatoryPercentage || 20,
          originalTotalPrice: treadProduct?.originalTotalPrice || 0,
          description: treadProduct?.description || '',
          currency: treadProduct?.currency || 'ØªÙˆÙ…Ø§Ù†',
          lengthUnit: treadProduct?.lengthUnit || 'm'
        },
        riser: {
          partType: 'riser',
          isSelected: !!riserProduct,
          productId: riserProduct?.productId || null,
          product: riserProduct?.product || null,
          riserHeight: riserProduct?.riserHeight || 17,
          quantity: riserProduct?.quantity || numberOfSteps || 0,
          squareMeters: riserProduct?.squareMeters || 0,
          pricePerSquareMeter: riserProduct?.pricePerSquareMeter || 0,
          totalPrice: riserProduct?.totalPrice || 0,
          isMandatory: riserProduct?.isMandatory || false,
          mandatoryPercentage: riserProduct?.mandatoryPercentage || 20,
          originalTotalPrice: riserProduct?.originalTotalPrice || 0,
          description: riserProduct?.description || '',
          currency: riserProduct?.currency || 'ØªÙˆÙ…Ø§Ù†'
        },
        landing: {
          partType: 'landing',
          isSelected: !!landingProduct,
          productId: landingProduct?.productId || null,
          product: landingProduct?.product || null,
          landingWidth: landingProduct?.landingWidth || 0,
          landingDepth: landingProduct?.landingDepth || 0,
          numberOfLandings: landingProduct?.numberOfLandings || 0,
          quantity: landingProduct?.quantity || 0,
          squareMeters: landingProduct?.squareMeters || 0,
          pricePerSquareMeter: landingProduct?.pricePerSquareMeter || 0,
          totalPrice: landingProduct?.totalPrice || 0,
          isMandatory: landingProduct?.isMandatory || false,
          mandatoryPercentage: landingProduct?.mandatoryPercentage || 20,
          originalTotalPrice: landingProduct?.originalTotalPrice || 0,
          description: landingProduct?.description || '',
          currency: landingProduct?.currency || 'ØªÙˆÙ…Ø§Ù†'
        }
      };
      
      // Set stair system config
      setStairSystemConfig(editedStairConfig);
      
      // Set product config for modal (needed for modal type detection)
      setProductConfig({
        ...product,
        productType: 'stair'
      });
      
      // IMPORTANT: Set selectedProduct to enable modal rendering (modal requires selectedProduct && showProductModal)
      // Use the first available product from the stair system, or the current product as fallback
      const defaultProductForModal = treadProduct?.product || riserProduct?.product || landingProduct?.product || product.product;
      setSelectedProduct(defaultProductForModal);
      
      // Set product type for wizard
      updateWizardData({ selectedProductTypeForAddition: 'stair' });
      
      // Reset product search terms
      setTreadProductSearchTerm('');
      setRiserProductSearchTerm('');
      setLandingProductSearchTerm('');
      
      // Expand all sections
      setTreadExpanded(true);
      setRiserExpanded(true);
      setLandingExpanded(true);
      
      setIsEditMode(true);
      setEditingProductIndex(index); // Store the index of the first product in the stair system
      setTouchedFields(new Set());
      setErrors({}); // Clear errors when opening edit modal
      setShowProductModal(true);
      
      console.log('âœ… Stair system edit initialized:', {
        stairSystemId: product.stairSystemId,
        numberOfSteps,
        quantityType,
        partsFound: {
          tread: !!treadProduct,
          riser: !!riserProduct,
          landing: !!landingProduct
        },
        config: editedStairConfig
      });
      
      return;
    }
    
    // Handle longitudinal product editing (existing logic)
    setSelectedProduct(product.product);
    
    // Set unit information for proper display
    setLengthUnit(product.lengthUnit || 'm');
    setWidthUnit(product.widthUnit || 'cm');
    
    // Set mandatory pricing state
    setIsMandatory(product.isMandatory || false);
    setMandatoryPercentage(product.mandatoryPercentage || 20);
    
    // Set quantity interaction tracking - if quantity > 1, it has been interacted with
    setHasQuantityBeenInteracted((product.quantity || 0) > 1);
    
    // Set product config with all fields including remaining stone tracking
    // For slab products, ensure slabStandardDimensions is properly loaded
    let slabStandardDimensions = product.slabStandardDimensions || [];
    
    // Backward compatibility: if slabStandardDimensions is empty but legacy fields exist, create an entry
    if (product.productType === 'slab' && slabStandardDimensions.length === 0) {
      if (product.slabStandardLengthCm && product.slabStandardWidthCm) {
        slabStandardDimensions = [{
          id: `std_legacy_${Date.now()}`,
          standardLengthCm: product.slabStandardLengthCm,
          standardWidthCm: product.slabStandardWidthCm,
          quantity: product.quantity || 1
        }];
      }
    }
    
    setProductConfig({
      ...product,
      // For slab products, ensure slabStandardDimensions is set
      ...(product.productType === 'slab' && { slabStandardDimensions }),
      // For slab products, ensure slabVerticalCutSides is set (default to all 4 sides active if not present)
      ...(product.productType === 'slab' && {
        slabVerticalCutSides: product.slabVerticalCutSides || {
          top: true,
          bottom: true,
          left: true,
          right: true
        }
      }),
      // Preserve remaining stone tracking
      usedRemainingStones: product.usedRemainingStones || [],
      totalUsedRemainingWidth: product.totalUsedRemainingWidth || 0,
      totalUsedRemainingLength: product.totalUsedRemainingLength || 0,
      // Preserve remaining stones and cut details
      remainingStones: product.remainingStones || [],
      cutDetails: product.cutDetails || [],
      // Preserve SubService tracking
      appliedSubServices: product.appliedSubServices || [],
      totalSubServiceCost: product.totalSubServiceCost || 0,
      usedLengthForSubServices: product.usedLengthForSubServices || 0,
      usedSquareMetersForSubServices: product.usedSquareMetersForSubServices || 0,
      // Preserve CAD Design if available
      cadDesign: product.cadDesign || null
    });
    
    // Set product type for wizard
    updateWizardData({ selectedProductTypeForAddition: product.productType || 'longitudinal' });
    
    setIsEditMode(true);
    setEditingProductIndex(index);
    setTouchedFields(new Set()); // Reset touched fields for edit session
    setErrors({}); // Clear errors when opening edit modal
    setShowProductModal(true);
  };

  // Handle creating product from remaining stone
  const handleCreateFromRemainingStone = (remainingStone: RemainingStone, sourceProduct: ContractProduct) => {
    console.log('ğŸ¯ handleCreateFromRemainingStone called!');
    console.log('ğŸ” Source Product Debug:', {
      sourceProduct: sourceProduct,
      pricePerSquareMeter: sourceProduct.pricePerSquareMeter,
      isMandatory: sourceProduct.isMandatory,
      mandatoryPercentage: sourceProduct.mandatoryPercentage
    });
    
    remainingStoneModal.setSelectedRemainingStone(remainingStone);
    remainingStoneModal.setSelectedRemainingStoneSourceProduct(sourceProduct); // Store source product for later use
    
    // Find parent product index in wizardData.products for explicit parent-child relationship
    const parentProductIndex = wizardData.products.findIndex(
      p => p.stoneCode === sourceProduct.stoneCode && p.productId === sourceProduct.productId
    );
    
    // Initialize configuration with remaining stone data
    // Use source product's quantity as default (represents remaining pieces available)
    // IMPORTANT: The child's stoneCode is parent's stoneCode + "-R" + last 4 chars of remainingStone.id
    // This creates a unique code for each child product (for backward compatibility)
    const childStoneCode = `${sourceProduct.stoneCode}-R${remainingStone.id.slice(-4)}`;
    const defaultConfig: Partial<ContractProduct> = {
      productId: sourceProduct.productId,
      product: sourceProduct.product,
      productType: sourceProduct.productType, // NEW: Inherit product type from source
      stoneCode: childStoneCode, // Add remaining stone identifier
      stoneName: `${sourceProduct.stoneName} (Ø§Ø² Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡)`,
      diameterOrWidth: remainingStone.width,
      length: remainingStone.length, // Initialize with remaining stone length
      width: remainingStone.width, // Initialize with remaining stone width, but allow editing
      quantity: sourceProduct.quantity || 1, // Use source product's remaining quantity
      squareMeters: remainingStone.squareMeters, // Initialize with remaining stone square meters (already includes quantity)
      pricePerSquareMeter: 0, // No pricing for remaining stone
      totalPrice: 0,
      description: `Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø§Ø² Ø³Ù†Ú¯ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ (${remainingStone.width}cm Ø¹Ø±Ø¶)`,
      currency: sourceProduct.currency,
      // Unit information for proper display
      lengthUnit: sourceProduct.lengthUnit || 'm',
      widthUnit: sourceProduct.widthUnit || 'cm',
      // Inherit from source product
      isMandatory: sourceProduct.isMandatory,
      mandatoryPercentage: sourceProduct.mandatoryPercentage,
      originalTotalPrice: 0,
      // Stone cutting fields - inherit cutting cost per meter from source product
      isCut: false,
      originalWidth: remainingStone.width,
      originalLength: remainingStone.length, // Store the original remaining length
      cuttingCost: 0,
      cuttingCostPerMeter: sourceProduct.cuttingCostPerMeter || 0, // Inherit from source product
      remainingStones: [],
      cutDetails: [],
      // Initialize SubService tracking
      appliedSubServices: [],
      totalSubServiceCost: 0,
      usedLengthForSubServices: 0,
      usedSquareMetersForSubServices: 0,
      // Set explicit parent reference (if parent found)
      parentProductIndex: parentProductIndex >= 0 ? parentProductIndex : undefined
    };
    
    console.log('ğŸ” Default Config Created:', {
      defaultConfig: defaultConfig,
      pricePerSquareMeter: defaultConfig.pricePerSquareMeter
    });
    
    remainingStoneModal.setRemainingStoneConfig(defaultConfig);
    // Inherit unit information from source product
    remainingStoneModal.setRemainingStoneLengthUnit(sourceProduct.lengthUnit || 'm');
    remainingStoneModal.setRemainingStoneWidthUnit(sourceProduct.widthUnit || 'cm');
    remainingStoneModal.setRemainingStoneIsMandatory(sourceProduct.isMandatory || false);
    remainingStoneModal.setRemainingStoneMandatoryPercentage(sourceProduct.mandatoryPercentage || 20);
    
    // Initialize partitions array (start with one empty partition)
    remainingStoneModal.setPartitions([{
      id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      width: 0,
      length: 0,
      squareMeters: 0
    }]);
    remainingStoneModal.setPartitionLengthUnit(sourceProduct.lengthUnit || 'm');
    remainingStoneModal.setPartitionWidthUnit(sourceProduct.widthUnit || 'cm');
    
    remainingStoneModal.setShowRemainingStoneModal(true);
  };
  // Handle product configuration and add to contract
  const handleAddProductToContract = () => {
    console.log('ğŸš€ handleAddProductToContract called!');
    console.log('ğŸ” Main Product Validation Debug:', {
      selectedProduct: selectedProduct,
      productConfig: productConfig,
      productType: wizardData.selectedProductTypeForAddition,
      hasLength: !!productConfig.length,
      hasWidth: !!productConfig.width,
      hasSquareMeters: !!productConfig.squareMeters,
      hasQuantity: !!productConfig.quantity,
      hasPricePerSquareMeter: !!productConfig.pricePerSquareMeter
    });
    
    if (!selectedProduct || !productConfig) {
      console.log('âŒ Missing selectedProduct or productConfig');
      return;
    }
    
    // Get product type from wizard data (required)
    const productType = wizardData.selectedProductTypeForAddition;
    if (!productType) {
      console.error('âŒ Product type not selected');
      setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
      return;
    }
    
    // Handle different product types
    if (productType === 'stair') {
      // STAIR SYSTEM (Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡) VALIDATION AND CREATION
      if (!stairSystemConfig) {
        setErrors({ products: 'Ø®Ø·Ø§ Ø¯Ø± Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ø³ÛŒØ³ØªÙ… Ù¾Ù„Ù‡' });
        return;
      }
      
      // Validate that at least one part is selected
      const hasSelectedPart = stairSystemConfig.tread.isSelected || 
                              stairSystemConfig.riser.isSelected || 
                              stairSystemConfig.landing.isSelected;
      
      if (!hasSelectedPart) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ©ÛŒ Ø§Ø² Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ù¾Ù„Ù‡ (Ú©Ù Ù¾Ù„Ù‡ØŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ØŒ ÛŒØ§ Ù¾Ø§Ú¯Ø±Ø¯) Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
        return;
      }
      
      // Validate common configuration
      if (!stairSystemConfig.numberOfSteps || stairSystemConfig.numberOfSteps <= 0) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
        return;
      }
      
      if (stairSystemConfig.quantityType === 'staircases' && 
          (!stairSystemConfig.numberOfStaircases || stairSystemConfig.numberOfStaircases <= 0)) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù† Ú©Ø§Ù…Ù„ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
        return;
      }
      
      // Generate unique stair system ID (only for new systems, preserve for edits)
      let stairSystemId: string;
      if (isEditMode && editingProductIndex !== null) {
        // Preserve existing stairSystemId when editing
        const editingProduct = wizardData.products[editingProductIndex];
        stairSystemId = editingProduct?.stairSystemId || `stair_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      } else {
        stairSystemId = `stair_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }
      
      const productsToAdd: ContractProduct[] = [];
      
      // Process Tread (Ú©Ù Ù¾Ù„Ù‡)
      if (stairSystemConfig.tread.isSelected) {
        const tread = stairSystemConfig.tread;
        
        if (!tread.product || !tread.productId) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ù…Ø­ØµÙˆÙ„ Ø¨Ø±Ø§ÛŒ Ú©Ù Ù¾Ù„Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!tread.treadWidth || tread.treadWidth <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø·ÙˆÙ„ Ù¾Ù„Ù‡ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!tread.treadDepth || tread.treadDepth <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ Ù¾Ù„Ù‡ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!tread.quantity || tread.quantity <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!tread.pricePerSquareMeter || tread.pricePerSquareMeter <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        // Calculate tread metrics
        const treadMetrics = calculateTreadMetrics({
          treadWidth: tread.treadWidth,
          treadWidthUnit: tread.lengthUnit || 'm',
          treadDepth: tread.treadDepth,
          quantity: tread.quantity,
          quantityType: stairSystemConfig.quantityType,
          numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
        });
        
        // Calculate nosing cost (only for tread)
        const nosingCost = calculateNosingCuttingCost({
          nosingType: tread.nosingType || 'none',
          treadWidth: tread.treadWidth,
          treadWidthUnit: tread.lengthUnit || 'm',
          numberOfSteps: tread.quantity,
          numberOfStaircases: stairSystemConfig.quantityType === 'staircases' ? (stairSystemConfig.numberOfStaircases || 1) : 1,
          quantityType: stairSystemConfig.quantityType
        });
        
        // Calculate pricing
        const basePrice = treadMetrics.totalArea * tread.pricePerSquareMeter;
        const mandatoryPrice = tread.isMandatory && tread.mandatoryPercentage
          ? basePrice * (tread.mandatoryPercentage / 100)
          : 0;
        const totalPrice = basePrice + mandatoryPrice + nosingCost.cuttingCost;
        
        productsToAdd.push({
          productId: tread.productId,
          product: tread.product,
          productType: 'stair',
          stairSystemId: stairSystemId,
          stairPartType: 'tread',
          stoneCode: tread.product.code,
          stoneName: tread.product.namePersian,
          diameterOrWidth: tread.product.widthValue,
          length: 0,
          width: 0,
          quantity: treadMetrics.totalQuantity,
          squareMeters: treadMetrics.totalArea,
          pricePerSquareMeter: tread.pricePerSquareMeter,
          totalPrice: totalPrice,
          description: tread.description || `Ú©Ù Ù¾Ù„Ù‡ - Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡`,
          currency: 'ØªÙˆÙ…Ø§Ù†',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: tread.isMandatory,
          mandatoryPercentage: tread.mandatoryPercentage,
          originalTotalPrice: basePrice,
          isCut: false,
          cutType: null,
          originalWidth: tread.product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0,
          // Stair-specific fields
          treadWidth: tread.treadWidth,
          treadDepth: tread.treadDepth,
          numberOfSteps: stairSystemConfig.numberOfSteps,
          quantityType: stairSystemConfig.quantityType,
          nosingType: tread.nosingType,
          nosingOverhang: tread.nosingOverhang,
          nosingCuttingCost: nosingCost.cuttingCost,
          nosingCuttingCostPerMeter: nosingCost.cuttingCostPerMeter
        });
      }
      
      // Process Riser (Ø®ÛŒØ² Ù¾Ù„Ù‡)
      if (stairSystemConfig.riser.isSelected) {
        const riser = stairSystemConfig.riser;
        
        if (!riser.product || !riser.productId) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ù…Ø­ØµÙˆÙ„ Ø¨Ø±Ø§ÛŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!riser.riserHeight || riser.riserHeight <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø§Ø±ØªÙØ§Ø¹ Ù‚Ø§Ø¦Ù…Ù‡ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!riser.quantity || riser.quantity <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!riser.pricePerSquareMeter || riser.pricePerSquareMeter <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        // Get tread width for riser calculation (from tread part if available, otherwise use default)
        // CRITICAL: Riser calculation depends on tread width, so we need to validate it
        const treadWidth = stairSystemConfig.tread.treadWidth;
        const treadWidthUnit = stairSystemConfig.tread.lengthUnit || 'm';
        
        // Validate that tread width is available if riser is selected
        // If tread is not selected, we can't calculate riser area accurately
        if (!treadWidth || treadWidth <= 0) {
          // If tread is not selected, we can't use its width
          if (!stairSystemConfig.tread.isSelected) {
            setErrors({ products: 'Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø®ÛŒØ² Ù¾Ù„Ù‡ØŒ Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ú©Ù Ù¾Ù„Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡ Ùˆ Ø·ÙˆÙ„ Ù¾Ù„Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
            return;
          }
          // If tread is selected but width is not set
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø·ÙˆÙ„ Ù¾Ù„Ù‡ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ú©Ù Ù¾Ù„Ù‡ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ØªØ§ Ø¨ØªÙˆØ§Ù† Ø®ÛŒØ² Ù¾Ù„Ù‡ Ø±Ø§ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ú©Ø±Ø¯' });
          return;
        }
        
        // Calculate riser metrics
        const riserMetrics = calculateRiserMetrics({
          treadWidth: treadWidth,
          treadWidthUnit: treadWidthUnit,
          riserHeight: riser.riserHeight,
          quantity: riser.quantity,
          quantityType: stairSystemConfig.quantityType,
          numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
        });
        
        // Calculate pricing
        const basePrice = riserMetrics.totalArea * riser.pricePerSquareMeter;
        const mandatoryPrice = riser.isMandatory && riser.mandatoryPercentage
          ? basePrice * (riser.mandatoryPercentage / 100)
          : 0;
        const totalPrice = basePrice + mandatoryPrice;
        
        productsToAdd.push({
          productId: riser.productId,
          product: riser.product,
          productType: 'stair',
          stairSystemId: stairSystemId,
          stairPartType: 'riser',
          stoneCode: riser.product.code,
          stoneName: riser.product.namePersian,
          diameterOrWidth: riser.product.widthValue,
          length: 0,
          width: 0,
          quantity: riserMetrics.totalQuantity,
          squareMeters: riserMetrics.totalArea,
          pricePerSquareMeter: riser.pricePerSquareMeter,
          totalPrice: totalPrice,
          description: riser.description || `Ø®ÛŒØ² Ù¾Ù„Ù‡ - Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡`,
          currency: 'ØªÙˆÙ…Ø§Ù†',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: riser.isMandatory,
          mandatoryPercentage: riser.mandatoryPercentage,
          originalTotalPrice: basePrice,
          isCut: false,
          cutType: null,
          originalWidth: riser.product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0,
          // Stair-specific fields
          riserHeight: riser.riserHeight,
          numberOfSteps: stairSystemConfig.numberOfSteps,
          quantityType: stairSystemConfig.quantityType
        });
      }
      
      // Process Landing (Ù¾Ø§Ú¯Ø±Ø¯)
      if (stairSystemConfig.landing.isSelected) {
        const landing = stairSystemConfig.landing;
        
        if (!landing.product || !landing.productId) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ù…Ø­ØµÙˆÙ„ Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ú¯Ø±Ø¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!landing.numberOfLandings || landing.numberOfLandings <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø§Ú¯Ø±Ø¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!landing.landingWidth || landing.landingWidth <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ Ù¾Ø§Ú¯Ø±Ø¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!landing.landingDepth || landing.landingDepth <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø¹Ù…Ù‚ Ù¾Ø§Ú¯Ø±Ø¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        if (!landing.pricePerSquareMeter || landing.pricePerSquareMeter <= 0) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ú¯Ø±Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
          return;
        }
        
        // Calculate landing metrics
        const landingMetrics = calculateLandingMetrics({
          landingWidth: landing.landingWidth,
          landingDepth: landing.landingDepth,
          numberOfLandings: landing.numberOfLandings,
          quantityType: stairSystemConfig.quantityType,
          numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
        });
        
        // Calculate pricing
        const basePrice = landingMetrics.totalArea * landing.pricePerSquareMeter;
        const mandatoryPrice = landing.isMandatory && landing.mandatoryPercentage
          ? basePrice * (landing.mandatoryPercentage / 100)
          : 0;
        const totalPrice = basePrice + mandatoryPrice;
        
        productsToAdd.push({
          productId: landing.productId,
          product: landing.product,
          productType: 'stair',
          stairSystemId: stairSystemId,
          stairPartType: 'landing',
          stoneCode: landing.product.code,
          stoneName: landing.product.namePersian,
          diameterOrWidth: landing.product.widthValue,
          length: 0,
          width: 0,
          quantity: landingMetrics.totalQuantity,
          squareMeters: landingMetrics.totalArea,
          pricePerSquareMeter: landing.pricePerSquareMeter,
          totalPrice: totalPrice,
          description: landing.description || `Ù¾Ø§Ú¯Ø±Ø¯ - Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡`,
          currency: 'ØªÙˆÙ…Ø§Ù†',
          lengthUnit: 'm',
          widthUnit: 'cm',
          isMandatory: landing.isMandatory,
          mandatoryPercentage: landing.mandatoryPercentage,
          originalTotalPrice: basePrice,
          isCut: false,
          cutType: null,
          originalWidth: landing.product.widthValue,
          originalLength: 0,
          cuttingCost: 0,
          cuttingCostPerMeter: 0,
          cutDescription: '',
          remainingStones: [],
          cutDetails: [],
          usedRemainingStones: [],
          totalUsedRemainingWidth: 0,
          totalUsedRemainingLength: 0,
          appliedSubServices: [],
          totalSubServiceCost: 0,
          usedLengthForSubServices: 0,
          usedSquareMetersForSubServices: 0,
          // Stair-specific fields
          landingWidth: landing.landingWidth,
          landingDepth: landing.landingDepth,
          numberOfLandings: landing.numberOfLandings,
          quantityType: stairSystemConfig.quantityType
        });
      }
      
      // Handle editing vs adding
      if (isEditMode && editingProductIndex !== null) {
        // Editing mode: Remove old stair system products and add new ones
        const editingProduct = wizardData.products[editingProductIndex];
        const oldStairSystemId = editingProduct?.stairSystemId;
        
        // Remove all products with the same stairSystemId
        const updatedProducts = wizardData.products.filter(p => 
          !(p.productType === 'stair' && p.stairSystemId === oldStairSystemId)
        );
        
        // Add updated products with the same stairSystemId (preserve ID for grouping)
        productsToAdd.forEach(p => {
          p.stairSystemId = oldStairSystemId; // Preserve the original stairSystemId
        });
        
        updateWizardData({
          products: [...updatedProducts, ...productsToAdd]
        });
        
        console.log('âœ… Successfully updated stair system in contract!', {
          stairSystemId: oldStairSystemId,
          partsUpdated: productsToAdd.length,
          parts: productsToAdd.map(p => p.stairPartType)
        });
      } else {
        // Adding new stair system
        updateWizardData({
          products: [...wizardData.products, ...productsToAdd]
        });
        
        console.log('âœ… Successfully added stair system to contract!', {
          stairSystemId,
          partsAdded: productsToAdd.length,
          parts: productsToAdd.map(p => p.stairPartType)
        });
      }
      
      // Close modal and reset state
      setShowProductModal(false);
      setSelectedProduct(null);
      setProductConfig({});
      setStairSystemConfig(null);
      setTreadWidthUnit('m');
      setQuantityType('steps');
      setIsMandatory(false);
      setMandatoryPercentage(20);
      setIsEditMode(false);
      setEditingProductIndex(null);
      setTouchedFields(new Set());
      setErrors({});
      
      return;
    }
    
    // SLAB STONE VALIDATION AND CALCULATION
    if (productConfig.productType === 'slab') {
      // Validate required fields - at least one of length/width or squareMeters must be provided
      const hasDimensions = (productConfig.length && productConfig.width) || productConfig.squareMeters;
      const hasRequiredFields = productConfig.quantity && productConfig.pricePerSquareMeter;
      
      if (!hasDimensions) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø·ÙˆÙ„ Ùˆ Ø¹Ø±Ø¶ ÛŒØ§ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
        return;
      }
      
      if (!hasRequiredFields) {
        if (!productConfig.quantity) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
        } else if (!productConfig.pricePerSquareMeter) {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
        } else {
          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ùˆ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
        }
        return;
      }
      
      // Validate standard dimensions
      const standardDimensions = productConfig.slabStandardDimensions || [];
      const wantedQuantity = productConfig.quantity || 0;
      const totalStandardQuantity = standardDimensions.reduce((sum, entry) => sum + (entry.quantity || 0), 0);
      
      if (standardDimensions.length === 0) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯' });
          return;
      }
      
      if (totalStandardQuantity !== wantedQuantity) {
          setErrors({ 
          products: `Ù…Ø¬Ù…ÙˆØ¹ ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (${totalStandardQuantity}) Ø¨Ø§ÛŒØ¯ Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ (${wantedQuantity}) Ø¨Ø§Ø´Ø¯` 
          });
          return;
      }
      
      // Validate that standard dimensions are >= wanted dimensions
      const userWidthInCm = productConfig.width 
        ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width)
        : 0;
      const userLengthInCm = productConfig.length 
        ? (lengthUnit === 'm' ? productConfig.length * 100 : productConfig.length)
        : 0;
      
      for (const entry of standardDimensions) {
        if (userLengthInCm > 0 && entry.standardLengthCm < userLengthInCm) {
          setErrors({ 
            products: `Ø·ÙˆÙ„ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (${entry.standardLengthCm}cm) Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ù…ØªØ± Ø§Ø² Ø·ÙˆÙ„ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ (${userLengthInCm}cm) Ø¨Ø§Ø´Ø¯` 
          });
          return;
        }
        if (userWidthInCm > 0 && entry.standardWidthCm < userWidthInCm) {
          setErrors({ 
            products: `Ø¹Ø±Ø¶ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (${entry.standardWidthCm}cm) Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ù…ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ (${userWidthInCm}cm) Ø¨Ø§Ø´Ø¯` 
          });
          return;
        }
        if (entry.quantity <= 0) {
          setErrors({ products: 'ØªØ¹Ø¯Ø§Ø¯ Ù‡Ø± Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯' });
          return;
        }
      }
      
      // For backward compatibility, use first entry as default if needed
      const { standardLengthCm, standardWidthCm } = getSlabStandardDimensions();
      const originalWidthCm = standardWidthCm || selectedProduct.widthValue || 0;
      const originalLengthCm = standardLengthCm || (selectedProduct as any)?.lengthValue || 300;
      const originalWidthInCurrentUnit = widthUnit === 'm' ? originalWidthCm / 100 : originalWidthCm;
      const originalLengthInCurrentUnit = lengthUnit === 'm' ? originalLengthCm / 100 : originalLengthCm;
      
      // Determine if cuts are needed (2D: longitudinal + cross)
      
      const needsLongitudinalCut = userWidthInCm > 0 && userWidthInCm < originalWidthCm && originalWidthCm > 0;
      const needsCrossCut = userLengthInCm > 0 && userLengthInCm < originalLengthCm && originalLengthCm > 0;
      
      // Automatically fetch cutting costs if cuts should be applied
      let cuttingCostPerMeterLongitudinal = 0;
      let cuttingCostPerMeterCross = 0;
      
      if (needsLongitudinalCut) {
        cuttingCostPerMeterLongitudinal = getCuttingTypePricePerMeter('LONG') || 0;
      }
      if (needsCrossCut) {
        cuttingCostPerMeterCross = getCuttingTypePricePerMeter('CROSS') || getCuttingTypePricePerMeter('LONG') || 0;
      }
      
      const slabCuttingMode = productConfig.slabCuttingMode || 'lineBased';
      const slabCuttingPricePerSquareMeter = productConfig.slabCuttingPricePerSquareMeter || 0;
      
      // Calculate metrics - use effective quantity
      const effectiveQuantity = getEffectiveQuantity();
      
      // For line-based cutting, we need to calculate line plan for each standard dimension entry
      // For now, use the first entry for line plan calculation (can be enhanced later)
      const firstStandardEntry = standardDimensions[0];
      const linePlanStandardLengthCm = firstStandardEntry?.standardLengthCm || originalLengthCm;
      const linePlanStandardWidthCm = firstStandardEntry?.standardWidthCm || originalWidthCm;
      const linePlan = determineSlabLineCutPlan({
        requestedLengthCm: userLengthInCm,
        requestedWidthCm: userWidthInCm,
        standardLengthCm: linePlanStandardLengthCm,
        standardWidthCm: linePlanStandardWidthCm
      });
      
      const calculated = calculateSlabMetrics({
        length: productConfig.length,
        width: productConfig.width,
        quantity: effectiveQuantity,
        squareMeters: productConfig.squareMeters,
        pricePerSquareMeter: productConfig.pricePerSquareMeter,
        lengthUnit: lengthUnit,
        widthUnit: widthUnit,
        isMandatory: false, // Slab stones don't use mandatory pricing
        mandatoryPercentage: 0, // Slab stones don't use mandatory pricing
        originalLength: originalLengthInCurrentUnit,
        originalWidth: originalWidthInCurrentUnit,
        standardDimensions: standardDimensions,
        cuttingCostPerMeterLongitudinal: cuttingCostPerMeterLongitudinal,
        cuttingCostPerMeterCross: cuttingCostPerMeterCross,
        slabCuttingMode,
        slabCuttingPricePerSquareMeter,
        lineCutLongitudinalMeters: linePlan.longitudinalMeters,
        lineCutCrossMeters: linePlan.crossMeters
      });
      
      // Calculate Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… (vertical edge cuts) cost
      // IMPORTANT: Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… is calculated for each standard dimension entry using its own dimensions and quantity
      // This is because Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… happens on the standard stones BEFORE they are cut to desired dimensions
      const verticalCutSides = productConfig.slabVerticalCutSides || {
        top: true,
        bottom: true,
        left: true,
        right: true
      };
      const verticalCutCostPerMeter = getCuttingTypePricePerMeter('VERTICAL') || getCuttingTypePricePerMeter('LONG') || 0;
      
      // Calculate vertical cut cost for each standard dimension entry
      let totalVerticalCutCost = 0;
      if (verticalCutCostPerMeter > 0 && standardDimensions.length > 0) {
        for (const entry of standardDimensions) {
          // Calculate Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… for this entry using its standard dimensions
          const entryVerticalCutCost = calculateSlabVerticalCutCost({
            requestedLengthCm: entry.standardLengthCm, // Use standard length, not requested
            requestedWidthCm: entry.standardWidthCm, // Use standard width, not requested
            quantity: entry.quantity, // Use entry's quantity
            verticalCutSides: verticalCutSides,
            verticalCutCostPerMeter: verticalCutCostPerMeter
          });
          totalVerticalCutCost += entryVerticalCutCost;
        }
      }
      
      // Calculate slab cutting details for all standard dimension entries
      // This will generate remaining stones for each entry
      const allRemainingPieces: RemainingStone[] = [];
      const allCutDetails: StoneCut[] = [];
      let totalCuttingCost = 0;
      let hasAnyCut = false;
      
      for (const entry of standardDimensions) {
        const entryOriginalLengthInCurrentUnit = lengthUnit === 'm' ? entry.standardLengthCm / 100 : entry.standardLengthCm;
        const entryOriginalWidthInCurrentUnit = widthUnit === 'm' ? entry.standardWidthCm / 100 : entry.standardWidthCm;
        
        const entryLinePlan = determineSlabLineCutPlan({
          requestedLengthCm: userLengthInCm,
          requestedWidthCm: userWidthInCm,
          standardLengthCm: entry.standardLengthCm,
          standardWidthCm: entry.standardWidthCm
        });
        
        const entrySlabCutting = calculateSlabCutting({
          originalLength: entryOriginalLengthInCurrentUnit,
          originalWidth: entryOriginalWidthInCurrentUnit,
        desiredLength: productConfig.length || 0,
        desiredWidth: productConfig.width || 0,
        lengthUnit: lengthUnit,
        widthUnit: widthUnit,
          cuttingCostPerMeterLongitudinal: slabCuttingMode === 'lineBased' ? cuttingCostPerMeterLongitudinal : 0,
          cuttingCostPerMeterCross: slabCuttingMode === 'lineBased' ? cuttingCostPerMeterCross : 0,
          quantity: entry.quantity,
          longitudinalCutLengthMeters: entryLinePlan.longitudinalMeters,
          crossCutLengthMeters: entryLinePlan.crossMeters
        });
        
        if (entrySlabCutting.needsLongitudinalCut || entrySlabCutting.needsCrossCut) {
          hasAnyCut = true;
        }
        
        totalCuttingCost += entrySlabCutting.totalCuttingCost || 0;
        allRemainingPieces.push(...(entrySlabCutting.remainingPieces || []));
        allCutDetails.push(...(entrySlabCutting.cutDetails || []));
      }
      
      // Add Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… cost to total cutting cost
      const finalTotalCuttingCost = totalCuttingCost + totalVerticalCutCost;
      
      // Create a combined slab cutting result
      const slabCutting = {
        needsLongitudinalCut: hasAnyCut && userWidthInCm > 0 && standardDimensions.some(e => userWidthInCm < e.standardWidthCm),
        needsCrossCut: hasAnyCut && userLengthInCm > 0 && standardDimensions.some(e => userLengthInCm < e.standardLengthCm),
        remainingPieces: allRemainingPieces,
        cutDetails: allCutDetails,
        cuttingCost: finalTotalCuttingCost // Include vertical cut cost
      };
      
      const lineBasedDescription = slabCutting.needsLongitudinalCut && slabCutting.needsCrossCut
        ? `Ø¨Ø±Ø´ Ø¯Ùˆ Ø¨Ø¹Ø¯ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± (Ø·ÙˆÙ„: ${originalLengthCm}cm â†’ ${userLengthInCm}cmØŒ Ø¹Ø±Ø¶: ${originalWidthCm}cm â†’ ${userWidthInCm}cm)`
        : (slabCutting.needsLongitudinalCut 
          ? `Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± (${originalWidthCm}cm â†’ ${userWidthInCm}cm)`
          : (slabCutting.needsCrossCut 
            ? `Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø± Ø®ÙˆØ¯Ú©Ø§Ø± (${originalLengthCm}cm â†’ ${userLengthInCm}cm)`
            : ''));
      const perSquareMeterDescription = slabCuttingMode === 'perSquareMeter' && slabCuttingPricePerSquareMeter > 0
        ? `Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (${formatSquareMeters(calculated.squareMeters || 0)} Ã— ${formatPrice(slabCuttingPricePerSquareMeter, 'ØªÙˆÙ…Ø§Ù†')})`
        : 'Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ØªØ± Ù…Ø±Ø¨Ø¹';
      
      // Create final product configuration for slab stone
      const finalProduct: ContractProduct = {
        productId: selectedProduct.id,
        product: selectedProduct,
        productType: 'slab',
        stoneCode: productConfig.stoneCode || selectedProduct.code,
        stoneName: productConfig.stoneName || selectedProduct.namePersian,
        diameterOrWidth: productConfig.diameterOrWidth || selectedProduct.widthValue,
        length: calculated.length,
        width: calculated.width,
        quantity: effectiveQuantity,
        squareMeters: calculated.squareMeters,
        pricePerSquareMeter: productConfig.pricePerSquareMeter || 0,
        totalPrice: calculated.totalPrice,
        description: productConfig.description || '',
        currency: 'ØªÙˆÙ…Ø§Ù†',
        lengthUnit: lengthUnit,
        widthUnit: widthUnit,
        isMandatory: false, // Slab stones don't use mandatory pricing
        mandatoryPercentage: 0, // Slab stones don't use mandatory pricing
        originalTotalPrice: calculated.originalTotalPrice,
        // Slab cutting fields (2D)
        isCut: hasAnyCut,
        cutType: slabCutting.needsLongitudinalCut && slabCutting.needsCrossCut ? 'cross' : (slabCutting.needsLongitudinalCut ? 'longitudinal' : null),
        originalWidth: originalWidthCm,
        originalLength: originalLengthInCurrentUnit,
        cuttingCost: slabCutting.cuttingCost || calculated.cuttingCost, // Use calculated cutting cost from all entries (includes Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù…)
        cuttingCostPerMeter: slabCuttingMode === 'lineBased'
          ? (cuttingCostPerMeterLongitudinal || cuttingCostPerMeterCross || 0)
          : 0,
        cutDescription: slabCuttingMode === 'lineBased' ? lineBasedDescription : perSquareMeterDescription,
        // Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… fields
        slabVerticalCutSides: verticalCutSides,
        slabVerticalCutCost: totalVerticalCutCost,
        slabVerticalCutCostPerMeter: verticalCutCostPerMeter,
        remainingStones: (isEditMode && productConfig.remainingStones) ? productConfig.remainingStones : slabCutting.remainingPieces,
        cutDetails: (isEditMode && productConfig.cutDetails) ? productConfig.cutDetails : slabCutting.cutDetails,
        usedRemainingStones: (isEditMode && productConfig.usedRemainingStones) ? productConfig.usedRemainingStones : [],
        totalUsedRemainingWidth: (isEditMode && productConfig.totalUsedRemainingWidth) ? productConfig.totalUsedRemainingWidth : 0,
        totalUsedRemainingLength: (isEditMode && productConfig.totalUsedRemainingLength) ? productConfig.totalUsedRemainingLength : 0,
        appliedSubServices: (isEditMode && productConfig.appliedSubServices) ? productConfig.appliedSubServices : [],
        totalSubServiceCost: (isEditMode && productConfig.totalSubServiceCost !== undefined) ? productConfig.totalSubServiceCost : 0,
        usedLengthForSubServices: (isEditMode && productConfig.usedLengthForSubServices !== undefined) ? productConfig.usedLengthForSubServices : 0,
        usedSquareMetersForSubServices: (isEditMode && productConfig.usedSquareMetersForSubServices !== undefined) ? productConfig.usedSquareMetersForSubServices : 0,
        // Legacy single standard dimension fields (for backward compatibility)
        slabStandardLengthCm: originalLengthCm,
        slabStandardWidthCm: originalWidthCm,
        // New multiple standard dimensions support
        slabStandardDimensions: standardDimensions,
        slabCuttingMode,
        slabCuttingPricePerSquareMeter: slabCuttingMode === 'perSquareMeter' ? slabCuttingPricePerSquareMeter : null,
        slabLineCuttingStrategy: linePlan.axisUsingStandard,
        slabLineCuttingLongitudinalMeters: linePlan.longitudinalMeters,
        slabLineCuttingCrossMeters: linePlan.crossMeters,
        // CAD Design (if available)
        cadDesign: productConfig.cadDesign || null
      };
      
      // Add SubService costs to totalPrice if they exist
      const existingSubServiceCost = (isEditMode && productConfig.totalSubServiceCost) ? productConfig.totalSubServiceCost : 0;
      finalProduct.totalPrice = calculated.totalPrice + existingSubServiceCost;
      
      // Add to contract or update existing product
      if (isEditMode && editingProductIndex !== null) {
        const updatedProducts = [...wizardData.products];
        updatedProducts[editingProductIndex] = finalProduct;
        updateWizardData({ products: updatedProducts });
      } else {
        updateWizardData({ products: [...wizardData.products, finalProduct] });
      }
      
      console.log('âœ… Successfully added slab product to contract!', { finalProduct });
      
      // Close modal and reset state
      setShowProductModal(false);
      setSelectedProduct(null);
      setProductConfig({});
      setLengthUnit('m');
      setWidthUnit('cm');
      setIsMandatory(false);
      setMandatoryPercentage(20);
      setIsEditMode(false);
      setEditingProductIndex(null);
      setTouchedFields(new Set());
      setErrors({});
      
      return;
    }
    
    // LONGITUDINAL STONE VALIDATION AND CALCULATION (existing logic)
    // Validate required fields - at least one of length/width or squareMeters must be provided
    const hasDimensions = (productConfig.length && productConfig.width) || productConfig.squareMeters;
    const hasRequiredFields = productConfig.quantity && productConfig.pricePerSquareMeter;
    
    console.log('ğŸ” Main Product Validation Results:', {
      hasDimensions,
      hasRequiredFields,
      length: productConfig.length,
      width: productConfig.width,
      squareMeters: productConfig.squareMeters,
      quantity: productConfig.quantity,
      pricePerSquareMeter: productConfig.pricePerSquareMeter
    });
    
    if (!hasDimensions) {
      console.log('âŒ Missing dimensions');
      setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø·ÙˆÙ„ Ùˆ Ø¹Ø±Ø¶ ÛŒØ§ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
      return;
    }
    
    if (!hasRequiredFields) {
      console.log('âŒ Missing required fields - quantity:', productConfig.quantity, 'pricePerSquareMeter:', productConfig.pricePerSquareMeter);
      
      // Provide more specific error messages
      if (!productConfig.quantity) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
      } else if (!productConfig.pricePerSquareMeter) {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
      } else {
        setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ ØªØ¹Ø¯Ø§Ø¯ Ùˆ ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯' });
      }
      return;
    }
    
    // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
    const originalWidthForCalculation = (isEditMode && productConfig.originalWidth) 
      ? productConfig.originalWidth 
      : selectedProduct.widthValue;
    
    // Validate width: cannot exceed original width
    if (productConfig.width && originalWidthForCalculation > 0) {
      const userWidthInCm = widthUnit === 'm' ? productConfig.width * 100 : productConfig.width;
      if (userWidthInCm > originalWidthForCalculation) {
        setErrors({ 
          products: `Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ (${productConfig.width}${widthUnit === 'm' ? 'm' : 'cm'}) Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø³Ù†Ú¯ (${originalWidthForCalculation}cm) Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ÛŒ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ Ø¨Ø§ ${originalWidthForCalculation}cm ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.` 
        });
        return;
      }
    }
    
    // Determine if longitudinal cut should be automatically selected (before calculating metrics)
    // Convert width to cm for comparison
    const userWidthForComparison = productConfig.width 
      ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width)
      : 0;
    const shouldAutoSelectLongitudinalCut = userWidthForComparison > 0 && userWidthForComparison < originalWidthForCalculation && originalWidthForCalculation > 0;
    
    // Automatically fetch cutting cost per meter if cut should be applied
    let cuttingCostPerMeterForCalc = productConfig.cuttingCostPerMeter || 0;
    if (shouldAutoSelectLongitudinalCut && !cuttingCostPerMeterForCalc) {
      // Fetch price from cutting types for "LONG" (Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ)
      cuttingCostPerMeterForCalc = getCuttingTypePricePerMeter('LONG') || 0;
      console.log('ğŸ”§ Auto-fetched cutting cost per meter before calculation:', cuttingCostPerMeterForCalc);
    }
    
    // Calculate metrics - use effective quantity (default to 1 if not interacted)
    const effectiveQuantity = getEffectiveQuantity();
    const calculated = calculateStoneMetrics({
      length: productConfig.length,
      width: productConfig.width,
      quantity: effectiveQuantity,
      squareMeters: productConfig.squareMeters,
      pricePerSquareMeter: productConfig.pricePerSquareMeter,
      lengthUnit: lengthUnit,
      widthUnit: widthUnit,
      isMandatory: isMandatory,
      mandatoryPercentage: mandatoryPercentage,
      isCut: productConfig.isCut || shouldAutoSelectLongitudinalCut, // Use auto-selection result
      originalWidth: originalWidthForCalculation,
      cuttingCostPerMeter: cuttingCostPerMeterForCalc // Use fetched value if available
    });
    
    // Get final width for display/logging
    const userEnteredWidth = calculated.width;
    const originalWidth = originalWidthForCalculation;
    const userEnteredWidthInCm = widthUnit === 'm' ? userEnteredWidth * 100 : userEnteredWidth;
    
    console.log('ğŸ” Auto Cut Selection Logic:', {
      userEnteredWidth,
      originalWidth,
      userEnteredWidthInCm,
      shouldAutoSelectLongitudinalCut,
      comparison: `${userEnteredWidthInCm} < ${originalWidth} = ${userEnteredWidthInCm < originalWidth}`,
      cuttingCostPerMeterForCalc,
      calculatedCuttingCost: calculated.cuttingCost
    });
    
    // Use cutting cost from calculated result (which already includes the auto-fetched price if applicable)
    const finalCuttingCost = calculated.cuttingCost || 0;
    const finalCuttingCostPerMeter = cuttingCostPerMeterForCalc;
    
    // Create final product configuration for longitudinal stone
    const finalProduct: ContractProduct = {
      productId: selectedProduct.id,
      product: selectedProduct,
      productType: 'longitudinal',
      stoneCode: productConfig.stoneCode || selectedProduct.code,
      stoneName: productConfig.stoneName || selectedProduct.namePersian,
      diameterOrWidth: productConfig.diameterOrWidth || selectedProduct.widthValue,
      length: calculated.length,
      width: calculated.width,
      quantity: effectiveQuantity,
      squareMeters: calculated.squareMeters,
      pricePerSquareMeter: productConfig.pricePerSquareMeter || 0,
      totalPrice: calculated.totalPrice,
      description: productConfig.description || '',
      currency: 'ØªÙˆÙ…Ø§Ù†', // Use Toman currency
      // Unit information for proper display
      lengthUnit: lengthUnit,
      widthUnit: widthUnit,
      // Mandatory pricing fields
      isMandatory: isMandatory,
      mandatoryPercentage: mandatoryPercentage,
      originalTotalPrice: calculated.originalTotalPrice,
      // Stone cutting fields - Use data from productConfig if available, or auto-select if width < original
      // Only mark as cut if we have a valid cutting cost per meter, otherwise the summary won't show
      isCut: (productConfig.isCut || shouldAutoSelectLongitudinalCut) && finalCuttingCostPerMeter > 0,
      cutType: productConfig.cutType || (shouldAutoSelectLongitudinalCut && finalCuttingCostPerMeter > 0 ? 'longitudinal' : null),
      // Preserve originalWidth if editing, otherwise use selectedProduct.widthValue
      originalWidth: (isEditMode && productConfig.originalWidth) ? productConfig.originalWidth : selectedProduct.widthValue,
      // Store originalLength when product is first created (when not from remaining stone)
      // For products created from remaining stone, originalLength is set in handleCreateFromRemainingStone
      originalLength: (isEditMode && productConfig.originalLength !== undefined) 
        ? productConfig.originalLength 
        : (lengthUnit === 'm' ? calculated.length : (calculated.length / 100)),
      cuttingCost: finalCuttingCost,
      cuttingCostPerMeter: finalCuttingCostPerMeter,
      cutDescription: productConfig.cutDescription || (shouldAutoSelectLongitudinalCut ? `Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± (${originalWidth}cm â†’ ${userEnteredWidthInCm.toFixed(2)}cm)` : ''),
      // Preserve remaining stones and cut details when editing, otherwise initialize empty
      remainingStones: (isEditMode && productConfig.remainingStones) ? productConfig.remainingStones : [],
      cutDetails: (isEditMode && productConfig.cutDetails) ? productConfig.cutDetails : [],
      // Preserve remaining stone usage tracking when editing
      usedRemainingStones: (isEditMode && productConfig.usedRemainingStones) ? productConfig.usedRemainingStones : [],
      totalUsedRemainingWidth: (isEditMode && productConfig.totalUsedRemainingWidth) ? productConfig.totalUsedRemainingWidth : 0,
      totalUsedRemainingLength: (isEditMode && productConfig.totalUsedRemainingLength) ? productConfig.totalUsedRemainingLength : 0,
      // SubService tracking - preserve when editing
      appliedSubServices: (isEditMode && productConfig.appliedSubServices) ? productConfig.appliedSubServices : [],
      totalSubServiceCost: (isEditMode && productConfig.totalSubServiceCost !== undefined) ? productConfig.totalSubServiceCost : 0,
      usedLengthForSubServices: (isEditMode && productConfig.usedLengthForSubServices !== undefined) ? productConfig.usedLengthForSubServices : 0,
      usedSquareMetersForSubServices: (isEditMode && productConfig.usedSquareMetersForSubServices !== undefined) ? productConfig.usedSquareMetersForSubServices : 0
    };
    
    // Add SubService costs to totalPrice if they exist
    const existingSubServiceCost = (isEditMode && productConfig.totalSubServiceCost) ? productConfig.totalSubServiceCost : 0;
    finalProduct.totalPrice = calculated.totalPrice + existingSubServiceCost;
    
    // Add to contract or update existing product
    if (isEditMode && editingProductIndex !== null) {
      // Update existing product
      const updatedProducts = [...wizardData.products];
      updatedProducts[editingProductIndex] = finalProduct;
      updateWizardData({
        products: updatedProducts
      });
    } else {
      // Add new product
      updateWizardData({
        products: [...wizardData.products, finalProduct]
      });
    }
    
    console.log('âœ… Successfully added main product to contract!', {
      finalProduct: finalProduct,
      isEditMode: isEditMode,
      editingProductIndex: editingProductIndex,
      totalProducts: isEditMode ? wizardData.products.length : wizardData.products.length + 1
    });
    
    // Close modal and reset state
    setShowProductModal(false);
    setSelectedProduct(null);
    setProductConfig({});
    setLengthUnit('m');
    setWidthUnit('cm');
    setIsMandatory(false);
    setMandatoryPercentage(20);
    setIsEditMode(false);
    setEditingProductIndex(null);
    setTouchedFields(new Set()); // Reset touched fields
    setErrors({});
  };

  // Partition handlers are now provided by useRemainingStoneModal hook
  // The handleAddRemainingStoneToContract function is now provided by remainingStoneModal.handleAddRemainingStoneToContract

  const validateCurrentStep = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    switch (currentStep) {
      case 1:
        if (!wizardData.contractDate) {
          newErrors.contractDate = 'ØªØ§Ø±ÛŒØ® Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
        }
        break;
      case 2:
        if (!wizardData.customerId) {
          newErrors.customerId = 'Ø§Ù†ØªØ®Ø§Ø¨ Ù…Ø´ØªØ±ÛŒ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
        }
        break;
      case 3:
        if (!wizardData.projectId) {
          newErrors.projectId = 'Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø±ÙˆÚ˜Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
        }
        break;
      case 4: // NEW: Product Type Selection
        if (!wizardData.selectedProductTypeForAddition) {
          newErrors.productType = 'Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
        }
        break;
      case 5: // Updated: Product Selection (was 4)
        if (wizardData.products.length === 0) {
          newErrors.products = 'Ø§Ù†ØªØ®Ø§Ø¨ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
        }
        break;
      case 6: // Updated: Delivery Schedule (was 5)
        if (wizardData.deliveries.length === 0) {
          newErrors.deliveries = 'ØªØ¹ÛŒÛŒÙ† Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ØªØ­ÙˆÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
        } else {
          // Validate each delivery
          wizardData.deliveries.forEach((delivery, index) => {
            if (!delivery.deliveryDate) {
              newErrors[`delivery_${index}_date`] = 'ØªØ§Ø±ÛŒØ® ØªØ­ÙˆÛŒÙ„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
            }
            if (!delivery.projectManagerName || delivery.projectManagerName.trim() === '') {
              newErrors[`delivery_${index}_projectManager`] = 'Ù†Ø§Ù… Ù…Ø¯ÛŒØ± Ù¾Ø±ÙˆÚ˜Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
            }
            if (!delivery.receiverName || delivery.receiverName.trim() === '') {
              newErrors[`delivery_${index}_receiver`] = 'Ù†Ø§Ù… ØªØ­ÙˆÛŒÙ„â€ŒÚ¯ÛŒØ±Ù†Ø¯Ù‡ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª';
            }
            if (delivery.products.length === 0) {
              newErrors[`delivery_${index}_products`] = 'Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ÛŒØ¯ Ø¯Ø± ØªØ­ÙˆÛŒÙ„ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯';
            }
          });
          
          // Validate that all products are distributed across deliveries
          const totalProductQuantities = new Map<number, number>();
          wizardData.products.forEach((product, index) => {
            totalProductQuantities.set(index, product.quantity);
          });
          
          wizardData.deliveries.forEach(delivery => {
            delivery.products.forEach(dp => {
              const current = totalProductQuantities.get(dp.productIndex) || 0;
              totalProductQuantities.set(dp.productIndex, current - dp.quantity);
            });
          });
          
          // Check for over-delivery
          totalProductQuantities.forEach((remaining, productIndex) => {
            if (remaining < 0) {
              const product = wizardData.products[productIndex];
              newErrors.deliveries = `ØªØ¹Ø¯Ø§Ø¯ ØªØ­ÙˆÛŒÙ„ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ "${product.stoneName || product.product?.namePersian || 'Ù…Ø­ØµÙˆÙ„'}" Ø¨ÛŒØ´ØªØ± Ø§Ø² ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ø§Ø³Øª`;
            }
          });
          
          // Check that all products are fully distributed
          const undistributedProducts: string[] = [];
          totalProductQuantities.forEach((remaining, productIndex) => {
            if (remaining > 0) {
              const product = wizardData.products[productIndex];
              undistributedProducts.push(
                `"${product.stoneName || product.product?.namePersian || 'Ù…Ø­ØµÙˆÙ„'}" (${formatDisplayNumber(remaining)} Ø¹Ø¯Ø¯ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡)`
              );
            }
          });
          
          if (undistributedProducts.length > 0) {
            newErrors.deliveries = `ØªÙ…Ø§Ù… Ù…Ø­ØµÙˆÙ„Ø§Øª Ø¨Ø§ÛŒØ¯ Ø¯Ø± ØªØ­ÙˆÛŒÙ„â€ŒÙ‡Ø§ ØªÙˆØ²ÛŒØ¹ Ø´ÙˆÙ†Ø¯. Ù…Ø­ØµÙˆÙ„Ø§Øª Ø²ÛŒØ± Ù‡Ù†ÙˆØ² Ø¨Ù‡ Ø·ÙˆØ± Ú©Ø§Ù…Ù„ ØªÙˆØ²ÛŒØ¹ Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯: ${undistributedProducts.join('ØŒ ')}`;
          }
        }
        break;
      case 7: // Payment Method
        // At least one payment entry is required
        if (wizardData.payment.payments.length === 0) {
          newErrors.paymentMethod = 'Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ÛŒØ¯ Ø§Ø¶Ø§ÙÙ‡ Ø´ÙˆØ¯';
        } else {
          // Validate each payment entry
          wizardData.payment.payments.forEach((payment, index) => {
            if (!payment.method) {
              newErrors.paymentMethod = `Ù†ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`;
              return;
            }
            if (!payment.amount || payment.amount <= 0) {
              newErrors.paymentMethod = `Ù…Ø¨Ù„Øº Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯`;
              return;
            }
            if (!payment.status) {
              newErrors.paymentMethod = `ÙˆØ¶Ø¹ÛŒØª Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`;
              return;
        }
            if (!payment.paymentDate) {
              newErrors.paymentMethod = `ØªØ§Ø±ÛŒØ® Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`;
              return;
            }
            // Validate conditional fields
            if (payment.method === 'CHECK' && !payment.checkNumber) {
              newErrors.paymentMethod = `Ø´Ù…Ø§Ø±Ù‡ Ú†Ú© Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} (Ú†Ú©) Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`;
              return;
            }
            if (payment.method === 'CHECK' && !payment.nationalCode) {
              newErrors.paymentMethod = `Ú©Ø¯ Ù…Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} (Ú†Ú©) Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`;
              return;
            }
            if (payment.method === 'CASH' && !payment.cashType) {
              newErrors.paymentMethod = `Ù†ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ù‚Ø¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª #${index + 1} (Ù†Ù‚Ø¯ÛŒ) Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª`;
              return;
            }
          });
        }
        break;
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Reset delivery step selection when leaving the step
  useEffect(() => {
    if (currentStep !== 6) {
      deliverySchedule.setSelectedProductIndices(new Set());
    }
  }, [currentStep]);

  const goToNextStep = () => {
    if (validateCurrentStep()) {
      setCurrentStep(prev => Math.min(prev + 1, WIZARD_STEPS.length));
      setErrors({});
    }
  };

  const goToPreviousStep = () => {
    setCurrentStep(prev => Math.max(prev - 1, 1));
    setErrors({});
  };

  const renderStepContent = () => {
    switch (currentStep) {
      case 1:
        return (
          <Step1ContractDate
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            currentUser={currentUser || undefined}
          />
        );
        
      case 2:
        return (
          <Step2CustomerSelection
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            customerSearchTerm={customerSearchTerm}
            setCustomerSearchTerm={setCustomerSearchTerm}
            customers={customers}
            filteredCustomers={filteredCustomers}
            currentStep={currentStep}
          />
        );
        
      case 3:
        return (
          <Step3ProjectManagement
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            currentStep={currentStep}
          />
        );
        
      case 4: // NEW: Product Type Selection
        return (
          <Step4ProductTypeSelection
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
          />
        );
      case 5: // Updated: Product Selection (was case 4)
        // Conditional rendering based on product type
        const selectedProductType = wizardData.selectedProductTypeForAddition;
        
        if (!selectedProductType) {
          return (
            <div className="space-y-6">
              <div className="text-center">
                <p className="text-red-500">Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ù†ÙˆØ¹ Ù…Ø­ØµÙˆÙ„ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</p>
              </div>
            </div>
          );
        }
        
        return (
          <Step5ProductSelection
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            productSearchTerm={productSearchTerm}
            setProductSearchTerm={setProductSearchTerm}
            products={products}
            filteredProducts={filteredProducts}
            handleProductSelection={handleProductSelection}
            setShowProductModal={setShowProductModal}
            setSelectedProductForConfiguration={setSelectedProduct}
            setSelectedProductIndexForEdit={setEditingProductIndex}
            handleRemoveProduct={(index) => {
              const newProducts = wizardData.products.filter((_, i) => i !== index);
              updateWizardData({ products: newProducts });
            }}
            currentStep={currentStep}
            productsSummary={productsSummary}
          />
        );
        
      case 6: // Delivery Schedule
        return (
          <Step6DeliverySchedule
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
          />
        );
        
      case 7: // Payment Method
        return (
          <Step7PaymentMethod
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            showPaymentEntryModal={paymentHandlers.showPaymentEntryModal}
            setShowPaymentEntryModal={paymentHandlers.setShowPaymentEntryModal}
          />
        );
        
      case 8: // Digital Signature
        return (
          <Step8DigitalSignature
            wizardData={wizardData}
            updateWizardData={updateWizardData}
            errors={errors}
            sendingCode={digitalSignature.sendingCode}
            verifyingCode={digitalSignature.verifyingCode}
            countdown={digitalSignature.countdown || 0}
            handleSendVerificationCode={handleSendVerificationCode}
            handleVerifyCode={handleVerifyCode}
            handlePhoneNumberChange={(phoneNumber: string) => {
              updateWizardData({
                signature: {
                  ...wizardData.signature!,
                  phoneNumber
                }
              });
            }}
            handleVerificationCodeChange={(code: string) => {
              updateWizardData({
                signature: {
                  ...wizardData.signature!,
                  verificationCode: code
                }
              });
            }}
          />
        );
        
      default:
        return null;
    }
  };
  
  // Legacy code removed - component is used above
  // The unreachable code block has been removed to fix linter errors
  
  if (loading && currentStep === 1) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-teal-500"></div>
      </div>
    );
  }

  // Removed orphaned generateContractHTML function - using the correct one below

  const generateContractHTML = (data: any) => {
    const productsTable = data.products && data.products.length > 0 ? `
      <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
        <thead>
          <tr style="background-color: #f5f5f5;">
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Ù†Ø§Ù… Ù…Ø­ØµÙˆÙ„</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Ø§Ø¨Ø¹Ø§Ø¯</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">ØªØ¹Ø¯Ø§Ø¯</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Ù…ØªØ± Ù…Ø±Ø¨Ø¹</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">ÙÛŒ</th>
            <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Ù‚ÛŒÙ…Øª Ú©Ù„</th>
          </tr>
        </thead>
        <tbody>
          ${data.products.map((product: any) => `
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.product?.namePersian || product.product?.name || product.namePersian || product.name || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.product?.widthValue && product.product?.thicknessValue ? `${product.product.widthValue} Ã— ${product.product.thicknessValue}` : product.length && product.width ? `${product.length} Ã— ${product.width}` : 'Ù†Ø§Ù…Ø´Ø®Øµ'}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${formatQuantity(product.quantity || 0)}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${formatSquareMeters(product.product?.squareMeter || product.squareMeter || 0)}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.unitPrice ? formatPrice(product.unitPrice, product.currency || 'ØªÙˆÙ…Ø§Ù†') : 'Ù†Ø§Ù…Ø´Ø®Øµ'}</td>
              <td style="border: 1px solid #ddd; padding: 8px;">${product.totalPrice ? formatPrice(product.totalPrice, product.currency || 'ØªÙˆÙ…Ø§Ù†') : 'Ù†Ø§Ù…Ø´Ø®Øµ'}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    ` : '';

    const deliveriesSection = data.deliveries && data.deliveries.length > 0 ? `
      <h3>Ø¨Ø±Ù†Ø§Ù…Ù‡ ØªØ­ÙˆÛŒÙ„:</h3>
      <ul>
        ${data.deliveries.map((delivery: any) => `
          <li>ØªØ§Ø±ÛŒØ®: ${delivery.deliveryDate} - ${delivery.notes || 'Ø¨Ø¯ÙˆÙ† ØªÙˆØ¶ÛŒØ­Ø§Øª'}</li>
        `).join('')}
      </ul>
    ` : '';

    return `
      <div style="font-family: 'Tahoma', sans-serif; direction: rtl; text-align: right;">
        <h1 style="text-align: center; color: #333;">Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ ÙØ±ÙˆØ´ Ø³Ø¨Ù„Ø§Ù† Ø§Ø³ØªÙˆÙ†</h1>
        
        <div style="margin: 20px 0;">
          <p><strong>Ø´Ù…Ø§Ø±Ù‡ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯:</strong> ${data.contractNumber}</p>
          <p><strong>ØªØ§Ø±ÛŒØ® Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯:</strong> ${data.contractDate}</p>
        </div>

        <div style="margin: 20px 0;">
          <h3>Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø´ØªØ±ÛŒ:</h3>
          <p><strong>Ù†Ø§Ù…:</strong> ${data.customer?.firstName} ${data.customer?.lastName}</p>
          ${data.customer?.companyName ? `<p><strong>Ù†Ø§Ù… Ø´Ø±Ú©Øª:</strong> ${data.customer.companyName}</p>` : ''}
          ${data.customer?.phoneNumbers && data.customer.phoneNumbers.length > 0 ? `<p><strong>Ø´Ù…Ø§Ø±Ù‡ ØªÙ…Ø§Ø³:</strong> ${data.customer.phoneNumbers[0].number}</p>` : ''}
        </div>

        ${data.project ? `
          <div style="margin: 20px 0;">
            <h3>Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±ÙˆÚ˜Ù‡:</h3>
            <p><strong>Ø¢Ø¯Ø±Ø³ Ù¾Ø±ÙˆÚ˜Ù‡:</strong> ${data.project.address || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</p>
            <p><strong>Ù†Ø§Ù… Ù¾Ø±ÙˆÚ˜Ù‡:</strong> ${data.project.name || 'Ù†Ø§Ù…Ø´Ø®Øµ'}</p>
          </div>
        ` : ''}

        <div style="margin: 20px 0;">
          <h3>Ø§Ù‚Ù„Ø§Ù… Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯:</h3>
          ${productsTable}
        </div>

        ${data.payment ? `
          <div style="margin: 20px 0;">
            <h3>Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±Ø¯Ø§Ø®Øª:</h3>
            <p><strong>Ù†Ø­ÙˆÙ‡ Ù¾Ø±Ø¯Ø§Ø®Øª:</strong> ${data.payment.method}</p>
            <p><strong>Ù…Ø¨Ù„Øº Ú©Ù„:</strong> ${data.payment.totalAmount ? formatPrice(data.payment.totalAmount, data.payment.currency || 'ØªÙˆÙ…Ø§Ù†') : 'Ù†Ø§Ù…Ø´Ø®Øµ'}</p>
          </div>
        ` : ''}

        ${deliveriesSection}

        <div style="margin-top: 40px; text-align: center;">
          <p>Ø§ÛŒÙ† Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ Ø¯Ø± ØªØ§Ø±ÛŒØ® ${data.contractDate} Ù…Ù†Ø¹Ù‚Ø¯ Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
        </div>
      </div>
    `;
  };
  
  // Contract submission is now provided by useContractSubmission hook
  const contractSubmission = useContractSubmission({
    wizardData,
    updateWizardData,
    setCurrentStep,
    setErrors,
    setLoading: setWizardLoading,
    validateCurrentStep,
    generateContractHTML,
    userDepartment: userDepartment || undefined,
    departments
  });
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 py-8 relative z-0">
      <div className="max-w-6xl mx-auto px-4 relative z-0">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-gray-800 dark:text-white mb-2">
            Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ Ø¬Ø¯ÛŒØ¯
          </h1>
          <p className="text-gray-600 dark:text-gray-300">
            Ù…Ø±Ø§Ø­Ù„ Ø§ÛŒØ¬Ø§Ø¯ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯ Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯
          </p>
        </div>

        {/* Progress Bar */}
        <WizardProgressBar currentStep={currentStep} steps={WIZARD_STEPS as WizardStep[]} />

        {/* Step Content */}
        <div className="glass-liquid-card p-8 mb-8 relative z-0">
          {renderStepContent()}
        </div>

        {/* Navigation */}
        <WizardNavigation
          currentStep={currentStep}
          totalSteps={WIZARD_STEPS.length}
          onPrevious={goToPreviousStep}
          onNext={goToNextStep}
          onSubmit={contractSubmission.handleCreateContract}
          loading={loading}
          canGoNext={true}
          canGoPrevious={currentStep > 1}
        />

        {/* Error Display */}
        {errors.general && (
          <div className="mt-4 p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
            <p className="text-red-600 dark:text-red-400">{errors.general}</p>
          </div>
        )}

        {/* Product Configuration Modal */}
        {showProductModal && useStairFlowV2 && productConfig.productType === 'stair' && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999] p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] flex flex-col z-[10000]">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 flex items-center justify-between flex-shrink-0">
                <div className="flex items-center gap-3">
                  <div className="w-1 h-8 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                  <h3 className="text-xl font-bold text-purple-900 dark:text-purple-200">{isEditMode ? 'ÙˆÛŒØ±Ø§ÛŒØ´ Ù…Ø­ØµÙˆÙ„ Ù¾Ù„Ù‡' : 'Ø§Ù†ØªØ®Ø§Ø¨ Ù…Ø­ØµÙˆÙ„ Ù¾Ù„Ù‡'}</h3>
                  {isEditMode && (
                    <span className="px-2.5 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded-full text-xs font-semibold">
                      Ø­Ø§Ù„Øª ÙˆÛŒØ±Ø§ÛŒØ´
                    </span>
                  )}
                </div>
                <button 
                  className="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg p-2 transition-colors" 
                  onClick={() => setShowProductModal(false)}
                  title="Ø¨Ø³ØªÙ†"
                >
                  <FaTimes className="w-5 h-5" />
                </button>
              </div>
              
              {/* Step Indicators */}
              {(() => {
                const [currentDraft] = getActiveDraft();
                const hasStone = !!currentDraft.stoneId;
                const hasThickness = !!currentDraft.thicknessCm;
                const hasLength = hasLengthMeasurement(currentDraft);
                const hasWidth = !!currentDraft.widthCm;
                const hasQuantity = !!currentDraft.quantity;
                const hasSqm = !!currentDraft.squareMeters;
                const hasPrice = !!currentDraft.pricePerSquareMeter;
                const hasTools = (currentDraft.tools || []).length > 0;
                const hasTotal = !!currentDraft.totalPrice;
                
                return (
                  <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-900/50 dark:to-gray-800/50 flex-shrink-0">
                    <div className="flex items-center gap-2 overflow-x-auto">
                      <div className="flex items-center gap-1.5 text-xs whitespace-nowrap">
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${true ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>0. Ø¨Ø®Ø´</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasStone ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>1. Ù†ÙˆØ¹ Ø³Ù†Ú¯</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasThickness ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>2. Ù‚Ø·Ø±</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasLength ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>3. Ø·ÙˆÙ„</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasWidth ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>4. Ø¹Ø±Ø¶</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasQuantity ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>5. ØªØ¹Ø¯Ø§Ø¯</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasSqm ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>6. Ù…ØªØ± Ù…Ø±Ø¨Ø¹</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasPrice ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>7. Ù‚ÛŒÙ…Øª</span>
                        <span className="text-gray-400 dark:text-gray-500">â†’</span>
                            <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasTools ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>8. Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§</span>
                            <span className="text-gray-400 dark:text-gray-500">â†’</span>
                        {stairSystemV2.stairActivePart !== 'riser' && (
                          <>
                            <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${
                              (currentDraft.numberOfLayersPerStair &&
                                currentDraft.numberOfLayersPerStair > 0 &&
                                currentDraft.layerWidthCm &&
                                currentDraft.pricePerSquareMeter &&
                                (stairSystemV2.layerTypes.length === 0 || currentDraft.layerTypeId))
                                ? 'bg-gradient-to-r from-orange-500 to-orange-600 text-white shadow-md'
                                : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'
                            }`}>9. Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§</span>
                            <span className="text-gray-400 dark:text-gray-500">â†’</span>
                          </>
                        )}
                        <span className={`px-3 py-1.5 rounded-lg font-medium transition-all ${hasTotal ? 'bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-md' : 'bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400'}`}>{stairSystemV2.stairActivePart !== 'riser' ? '10. Ø¬Ù…Ø¹ Ú©Ù„' : '9. Ø¬Ù…Ø¹ Ú©Ù„'}</span>
                      </div>
                    </div>
                  </div>
                );
              })()}
              
              <div className="flex-1 overflow-y-auto">
                <div className="p-6 space-y-6">
                  {/* Part Selector - Enhanced */}
                  <div className="bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 rounded-lg border border-purple-200 dark:border-purple-700 p-4">
                    <div className="flex items-center gap-3">
                      <div className="w-1 h-6 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                      <label className="text-sm font-semibold text-purple-900 dark:text-purple-200">Ø¨Ø®Ø´:</label>
                      <select 
                        className="flex-1 rounded-lg bg-white dark:bg-gray-800 px-4 py-2 border border-purple-300 dark:border-purple-600 text-gray-800 dark:text-white font-medium focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all" 
                        value={stairSystemV2.stairActivePart} 
                        onChange={(e) => setActivePart(e.target.value as StairStepperPart)}
                      >
                        <option value="tread">Ú©Ù Ù¾Ù„Ù‡</option>
                        <option value="riser">Ø®ÛŒØ²</option>
                        <option value="landing">Ù¾Ø§Ú¯Ø±Ø¯</option>
                      </select>
                    </div>
                  </div>
                {(() => {
                  const [draft, setDraft] = getActiveDraft();
                  const totals = computeTotalsV2(stairSystemV2.stairActivePart, draft);
                  const chargeableCuttingCost = totals.billableCuttingCost;
                  const chargeableCuttingCostLongitudinal = totals.billableCuttingCostLongitudinal;
                  const chargeableCuttingCostCross = totals.billableCuttingCostCross;
                  const draftErrors = stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart] || {};
                  const lengthMInfo = getActualLengthMeters(draft);
                  const selectedFinishing = stoneFinishings.find(option => option.id === draft.finishingId);
                  const finishingPricePerSquareMeter =
                    draft.finishingPricePerSquareMeter ??
                    selectedFinishing?.pricePerSquareMeter ??
                    null;
                  const finishingPreviewCost =
                    draft.finishingEnabled && finishingPricePerSquareMeter
                      ? totals.pricingSquareMeters * finishingPricePerSquareMeter
                      : 0;
                  const defaultMandatoryEnabled = stairSystemV2.stairActivePart === 'riser' || stairSystemV2.stairActivePart === 'landing';
                  const mandatoryEnabled = draft.useMandatory ?? defaultMandatoryEnabled;
                  const supportsMandatory = stairSystemV2.stairActivePart === 'tread' || stairSystemV2.stairActivePart === 'riser' || stairSystemV2.stairActivePart === 'landing';
                  const mandatoryPercentageValue = draft.mandatoryPercentage ?? 20;
                  return (
                    <div className="space-y-6">
                      {/* Input Fields Section - Enhanced */}
                      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                        <div className="flex items-center gap-2 mb-4">
                          <div className="w-1 h-5 bg-gradient-to-b from-teal-500 to-teal-600 rounded-full"></div>
                          <h5 className="text-sm font-semibold text-gray-800 dark:text-white">Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø­ØµÙˆÙ„</h5>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div className="md:col-span-2">
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                Ù†ÙˆØ¹ Ø³Ù†Ú¯
                              </span>
                            </label>
                            <div className="relative">
                              <input 
                                className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all" 
                                placeholder="Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ù†ÙˆØ¹ Ø¨Ø±Ø´ØŒ Ø¬Ù†Ø³ Ø³Ù†Ú¯ØŒ Ù…Ø¹Ø¯Ù†ØŒ Ù†ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø®ØªØŒ Ø±Ù†Ú¯/Ø®ØµÙˆØµÛŒØ§Øª" 
                                value={stairSystemV2.stoneSearchTerm} 
                                onChange={(e) => stairSystemV2.setStoneSearchTerm(e.target.value)} 
                              />
                              {draft.stoneProduct && (
                                <div className="mt-2 p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg">
                                  <div className="text-sm font-medium text-teal-800 dark:text-teal-200">{draft.stoneLabel}</div>
                                  {draft.stoneProduct.basePrice && (
                                    <div className="text-xs text-teal-600 dark:text-teal-400 mt-1">
                                      Ù‚ÛŒÙ…Øª: {formatPrice(draft.stoneProduct.basePrice)}
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                            {stairSystemV2.stoneSearchTerm && (
                              <div className="mt-2 max-h-48 overflow-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg">
                                {stairSystemV2.isSearchingStones && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">
                                    <span className="animate-pulse">Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ...</span>
                                  </div>
                                )}
                                {!stairSystemV2.isSearchingStones && stairSystemV2.stoneSearchResults.length === 0 && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯</div>
                                )}
                                {stairSystemV2.stoneSearchResults.map((p: Product) => (
                                  <button 
                                    key={p.id} 
                                    type="button" 
                                    className="w-full text-right px-4 py-2.5 hover:bg-teal-50 dark:hover:bg-teal-900/20 text-sm border-b border-gray-100 dark:border-gray-700 last:border-0 transition-colors" 
                                    onClick={() => {
                                      selectProductForStairPart(stairSystemV2.stairActivePart, p);
                                    }}
                                  >
                                    {/* ğŸ¯ Show complete product name using generateFullProductName */}
                                    <div className="font-medium text-gray-800 dark:text-white">
                                      {p.fullName || generateFullProductName(p) || p.namePersian || p.name}
                                    </div>
                                    {p.basePrice && (
                                      <div className="text-xs text-teal-600 dark:text-teal-400 mt-0.5">{formatPrice(p.basePrice)}</div>
                                    )}
                                  </button>
                                ))}
                              </div>
                            )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                Ù‚Ø·Ø± (Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±)
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.stoneProduct?.thicknessValue ?? draft.thicknessCm ?? null}
                              onChange={(_value) => {}}
                              min={1}
                              step={1}
                              disabled
                              className="w-full rounded-lg bg-gray-100 dark:bg-gray-700/60 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-600 dark:text-gray-300 cursor-not-allowed"
                              placeholder="Ø§Ø¨ØªØ¯Ø§ Ù…Ø­ØµÙˆÙ„ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯"
                            />
                            <p className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                              Ù‚Ø·Ø± Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ø² Ù…Ø´Ø®ØµØ§Øª Ù…Ø­ØµÙˆÙ„ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ ØªÙ†Ø¸ÛŒÙ… Ù…ÛŒâ€ŒØ´ÙˆØ¯ Ùˆ Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ± Ù†ÛŒØ³Øª.
                            </p>
                          {draftErrors.thickness && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.thickness}</p>
                          )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                Ø·ÙˆÙ„
                              </span>
                            </label>
                            <div className="flex gap-2">
                              <FormattedNumberInput
                                value={draft.lengthValue ?? null}
                            onChange={(value) => {
                              const normalizedValue = value && value > 0 ? value : null;
                              const updatedDraft: StairPartDraftV2 = { ...draft, lengthValue: normalizedValue };
                              const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'length', value);
                              if (error) {
                                stairSystemV2.setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], length: error }
                                }));
                              } else {
                                clearDraftFieldError(stairSystemV2.stairActivePart, 'length');
                              }
                              setDraft(updatedDraft);
                            }}
                                min={0}
                                step={0.01}
                                className="flex-1 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                                placeholder="Ù…Ø«Ø§Ù„: 1.2"
                              />
                              <select 
                                className="rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all font-medium" 
                                value={draft.lengthUnit || 'm'} 
                                onChange={(e) => setDraft({ ...draft, lengthUnit: (e.target.value as UnitType) })}
                              >
                                <option value="cm">cm</option>
                                <option value="m">m</option>
                              </select>
                            </div>
                            {stairSystemV2.stairActivePart !== 'riser' && (
                            <div className="mt-3">
                              <label className="block text-xs font-medium text-gray-600 dark:text-gray-300 mb-1">
                                Ø·ÙˆÙ„ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (Ø¨Ø±Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ)
                              </label>
                              <div className="flex gap-2">
                                <FormattedNumberInput
                                  value={draft.standardLengthValue ?? null}
                                  onChange={(value) => {
                                    const normalized = value && value > 0 ? value : null;
                                    const updatedDraft: StairPartDraftV2 = { ...draft, standardLengthValue: normalized };
                                    if (normalized && normalized > 0) {
                                      clearDraftFieldError(stairSystemV2.stairActivePart, 'length');
                                    }
                                    setDraft(updatedDraft);
                                  }}
                                  min={0}
                                  step={0.01}
                                  className="flex-1 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                                  placeholder="Ù…Ø«Ø§Ù„: 1.2"
                                />
                                <select 
                                  className="rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all font-medium" 
                                  value={draft.standardLengthUnit || draft.lengthUnit || 'm'} 
                                  onChange={(e) => setDraft({ ...draft, standardLengthUnit: (e.target.value as UnitType) })}
                                >
                                  <option value="m">m</option>
                                  <option value="cm">cm</option>
                                </select>
                              </div>
                              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                                Ø§Ú¯Ø± Ø·ÙˆÙ„ ÙˆØ§Ù‚Ø¹ÛŒ ÙˆØ§Ø±Ø¯ Ù†Ø´ÙˆØ¯ØŒ Ø§Ø² Ù‡Ù…ÛŒÙ† Ø·ÙˆÙ„ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                              </p>
                            </div>
                            )}
                          {draftErrors.length && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.length}</p>
                          )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                Ø¹Ø±Ø¶ (Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±)
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.widthCm ?? null}
                            onChange={(value) => {
                              const updatedDraft = { ...draft, widthCm: value && value > 0 ? value : null };
                              // ğŸ¯ Validate using comprehensive validation function
                              const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'width', value);
                              if (error) {
                                stairSystemV2.setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], width: error }
                                }));
                              } else {
                                clearDraftFieldError(stairSystemV2.stairActivePart, 'width');
                              }
                              setDraft(updatedDraft);
                            }}
                              min={0}
                              step={0.1}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                              placeholder="Ù…Ø«Ø§Ù„: 40"
                            />
                          {draftErrors.width && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.width}</p>
                          )}
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                ØªØ¹Ø¯Ø§Ø¯
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.quantity ?? null}
                            onChange={(value) => {
                              // ğŸ¯ Ensure integer value for quantity
                              const intValue = value ? Math.floor(value) : null;
                              const updatedDraft = { ...draft, quantity: intValue && intValue > 0 ? intValue : null };
                              // ğŸ¯ Validate using comprehensive validation function
                              const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'quantity', intValue);
                              if (error) {
                                stairSystemV2.setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], quantity: error }
                                }));
                              } else {
                                clearDraftFieldError(stairSystemV2.stairActivePart, 'quantity');
                              }
                              setDraft(updatedDraft);
                            }}
                              min={1}
                              step={1}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                              placeholder="Ù…Ø«Ø§Ù„: 100"
                            />
                          {draftErrors.quantity && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.quantity}</p>
                          )}
                          </div>
                          {draft.stoneProduct && totals.piecesPerStone > 0 && totals.baseStoneQuantity > 0 && (
                            <div className="md:col-span-2">
                              <div className="mt-2 rounded-lg border border-teal-200 dark:border-teal-800 bg-teal-50 dark:bg-teal-900/20 px-4 py-3 text-xs leading-5 text-teal-700 dark:text-teal-200">
                                <div>
                                  Ø§Ø² Ù‡Ø± Ø³Ù†Ú¯ {formatDisplayNumber(totals.piecesPerStone)} Ù‚Ø·Ø¹Ù‡ Ø¨Ø§ Ø¹Ø±Ø¶ {formatDisplayNumber(draft.widthCm ?? 0)} Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± Ø¨Ù‡ Ø¯Ø³Øª Ù…ÛŒâ€ŒØ¢ÛŒØ¯.
                                </div>
                                <div>
                                  ØªØ¹Ø¯Ø§Ø¯ Ø³Ù†Ú¯ Ù¾Ø§ÛŒÙ‡ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²: {formatDisplayNumber(totals.baseStoneQuantity)} Ø¹Ø¯Ø¯
                                  {totals.leftoverWidthCm > 0 ? ` â€¢ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡ Ù‡Ø± Ø³Ù†Ú¯: ${formatDisplayNumber(totals.leftoverWidthCm)}cm` : ''}
                                </div>
                              </div>
                            </div>
                          )}
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-blue-500"></span>
                                Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (Ø®ÙˆØ¯Ú©Ø§Ø±)
                              </span>
                            </label>
                            <input 
                              className="w-full rounded-lg bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 px-4 py-2.5 text-blue-700 dark:text-blue-300 font-semibold cursor-not-allowed" 
                              value={formatDisplayNumber(totals.sqm)} 
                              readOnly 
                            />
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-teal-500"></span>
                                Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.pricePerSquareMeter ?? null}
                            onChange={(value) => {
                              const updatedDraft = { ...draft, pricePerSquareMeter: value && value > 0 ? value : null };
                              // ğŸ¯ Validate using comprehensive validation function
                              const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'pricePerSquareMeter', value);
                              if (error) {
                                stairSystemV2.setStairDraftErrors(prev => ({
                                  ...prev,
                                  [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], pricePerSquareMeter: error }
                                }));
                              } else {
                                clearDraftFieldError(stairSystemV2.stairActivePart, 'pricePerSquareMeter');
                              }
                              setDraft(updatedDraft);
                            }}
                              min={0}
                              step={1000}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                              placeholder="Ù…Ø«Ø§Ù„: 1,500,000"
                            />
                          {draftErrors.pricePerSquareMeter && (
                            <p className="mt-1 text-xs text-red-500">{draftErrors.pricePerSquareMeter}</p>
                          )}
                          </div>
                          {supportsMandatory && (
                            <div className="md:col-span-2 rounded-lg border border-yellow-100 dark:border-yellow-800 bg-white dark:bg-gray-900/30 p-4">
                              <div className="flex items-center gap-2">
                                <input
                                  type="checkbox"
                                  className="rounded border-gray-300 text-yellow-600 focus:ring-yellow-500"
                                  checked={mandatoryEnabled}
                                  onChange={(e) => {
                                    const nextValue = e.target.checked;
                                    const updatedDraft = {
                                      ...draft,
                                      useMandatory: nextValue,
                                      mandatoryPercentage: nextValue ? (draft.mandatoryPercentage ?? 20) : null
                                    };
                                    if (!nextValue) {
                                      clearDraftFieldError(stairSystemV2.stairActivePart, 'mandatoryPercentage');
                                    }
                                    setDraft(updatedDraft);
                                  }}
                                />
                                <div>
                                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                    Ø­Ú©Ù…ÛŒ (Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª)
                                  </label>
                                  <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                    Ø¯Ø± ØµÙˆØ±Øª ÙØ¹Ø§Ù„ Ø¨ÙˆØ¯Ù†ØŒ Ù‚ÛŒÙ…Øª Ø³Ù†Ú¯ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø±ØµØ¯ÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                  </p>
                                </div>
                              </div>
                              {mandatoryEnabled && (
                                <div className="mt-3 flex items-center gap-2">
                                  <FormattedNumberInput
                                    value={mandatoryPercentageValue}
                                    onChange={(value) => {
                                      const updatedDraft = { ...draft, mandatoryPercentage: value ?? 0 };
                                      const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'mandatoryPercentage', value);
                                      if (error) {
                                        stairSystemV2.setStairDraftErrors(prev => ({
                                          ...prev,
                                          [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], mandatoryPercentage: error }
                                        }));
                                      } else {
                                        clearDraftFieldError(stairSystemV2.stairActivePart, 'mandatoryPercentage');
                                      }
                                      setDraft(updatedDraft);
                                    }}
                                    min={0}
                                    max={100}
                                    step={1}
                                    className="w-24 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent text-sm"
                                  />
                                  <span className="text-xs text-gray-600 dark:text-gray-300">%</span>
                                  <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                    Ù‚ÛŒÙ…Øª Ù¾Ø§ÛŒÙ‡ Ø¨Ø§ {formatDisplayNumber(mandatoryPercentageValue)}% Ø§ÙØ²Ø§ÛŒØ´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                  </p>
                                </div>
                              )}
                              {draftErrors.mandatoryPercentage && (
                                <p className="mt-1 text-xs text-red-500">
                                  {draftErrors.mandatoryPercentage}
                                </p>
                              )}
                            </div>
                          )}
                          {totals.billableCuttingCost > 0 && (
                            <div className="md:col-span-2">
                              <div className="mt-2 rounded-lg border border-amber-200 dark:border-amber-700 bg-amber-50 dark:bg-amber-900/20 px-4 py-3 text-xs leading-5 text-amber-700 dark:text-amber-200">
                                {totals.billableCuttingCostLongitudinal > 0 && (
                                  <div>
                                    Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ: {formatPrice(totals.billableCuttingCostLongitudinal)} ({formatDisplayNumber(lengthMInfo)} m Ã— {formatDisplayNumber(totals.baseStoneQuantity)} Ø³Ù†Ú¯ Ã— {formatPrice(totals.shouldChargeCuttingCost ? (totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter) : 0)})
                                  </div>
                                )}
                                {totals.billableCuttingCostCross > 0 && (
                                  <div className="mt-1">
                                    Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ: {formatPrice(totals.billableCuttingCostCross)} ({formatDisplayNumber((draft.widthCm || 0) / 100)} m Ã— {formatDisplayNumber(totals.baseStoneQuantity)} Ø³Ù†Ú¯ Ã— {formatPrice(totals.shouldChargeCuttingCost ? (totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter) : 0)})
                                  </div>
                                )}
                              </div>
                            </div>
                          )}
                        </div>
                      </div>

                      {/* Tools Section - Enhanced */}
                      {stairSystemV2.stairActivePart !== 'riser' && (
                      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                        <div className="flex items-center justify-between mb-4">
                          <div className="flex items-center gap-2">
                            <div className="w-1 h-5 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                            <h5 className="text-sm font-semibold text-gray-800 dark:text-white">Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ (Ø¨Ø± Ù…ØªØ±)</h5>
                          </div>
                          {stairSystemV2.stairActivePart === 'landing' && (
                            <span className="text-xs text-purple-600 dark:text-purple-400 bg-purple-50 dark:bg-purple-900/20 px-2 py-1 rounded">Ù…Ø¯Ù„ Ù„Ø¨Ù‡ Ù¾Ø§Ú¯Ø±Ø¯: Ù…Ø­ÛŒØ·/Ø¬Ù‡Øªâ€ŒÙ‡Ø§</span>
                          )}
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div>
                            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Ø§ÙØ²ÙˆØ¯Ù† Ø§Ø¨Ø²Ø§Ø±</label>
                            <input 
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all" 
                              placeholder="Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§" 
                              value={stairSystemV2.toolsSearchTerm} 
                              onChange={(e) => stairSystemV2.setToolsSearchTerm(e.target.value)} 
                              onFocus={() => stairSystemV2.setToolsDropdownOpen(true)} 
                              onBlur={() => setTimeout(() => stairSystemV2.setToolsDropdownOpen(false), 150)} 
                            />
                            {(stairSystemV2.toolsDropdownOpen || stairSystemV2.toolsSearchTerm) && (
                              <div className="mt-2 max-h-48 overflow-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg">
                                {stairSystemV2.isSearchingTools && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">
                                    <span className="animate-pulse">Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ...</span>
                                  </div>
                                )}
                                {!stairSystemV2.isSearchingTools && stairSystemV2.toolsResults.length === 0 && (
                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯</div>
                                )}
                                {stairSystemV2.toolsResults.map((t: any) => (
                                  <button 
                                    key={t.id} 
                                    type="button" 
                                    className="w-full text-right px-4 py-2.5 hover:bg-purple-50 dark:hover:bg-purple-900/20 text-sm border-b border-gray-100 dark:border-gray-700 last:border-0 transition-colors" 
                                    onClick={() => {
                                      const exists = (draft.tools || []).some(x => x.toolId === t.id);
                                      if (exists) return;
                                      setDraft({ ...draft, tools: [ ...(draft.tools || []), { toolId: t.id, name: t.namePersian || t.name, pricePerMeter: t.pricePerMeter || t.price || t.costPerMeter || 0, front: false, left: false, right: false, back: false, perimeter: false } ] });
                                      stairSystemV2.setToolsSearchTerm('');
                                      stairSystemV2.setToolsDropdownOpen(false);
                                    }}
                                  >
                                    <div className="font-medium text-gray-800 dark:text-white">{t.namePersian || t.name}</div>
                                    {(t.pricePerMeter || t.price || t.costPerMeter) && (
                                      <div className="text-xs text-purple-600 dark:text-purple-400 mt-0.5">
                                        {formatPrice(t.pricePerMeter || t.price || t.costPerMeter)}/m
                                      </div>
                                    )}
                                  </button>
                                ))}
                              </div>
                            )}
                          </div>

                          <div>
                            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ùˆ Ù„Ø¨Ù‡â€ŒÙ‡Ø§</label>
                            {(draft.tools || []).length === 0 ? (
                              <div className="text-center py-8 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-dashed border-gray-300 dark:border-gray-600">
                                <p className="text-xs text-gray-400 dark:text-gray-500">Ø§Ø¨Ø²Ø§Ø±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
                              </div>
                            ) : (
                              <div className="space-y-2 max-h-64 overflow-y-auto">
                                {(draft.tools || []).map((tool, idx) => {
                                  const meters = computeToolMetersForTool(stairSystemV2.stairActivePart, draft, tool);
                                  const tp = meters * (tool.pricePerMeter || 0);
                                  return (
                                    <div key={tool.toolId} className="p-3 rounded-lg border border-purple-200 dark:border-purple-800 bg-purple-50 dark:bg-purple-900/20 shadow-sm">
                                      <div className="flex items-center justify-between mb-3">
                                        <div className="font-medium text-purple-800 dark:text-purple-200 text-sm">{tool.name}</div>
                                        <div className="flex items-center gap-2 text-xs">
                                          <span className="px-2 py-1 bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded font-medium">
                                            {formatDisplayNumber(meters)} m
                                          </span>
                                          <span className="font-semibold text-purple-600 dark:text-purple-400">{formatPrice(tp)}</span>
                                          <button 
                                            type="button" 
                                            className="text-red-500 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/20 px-2 py-1 rounded transition-colors" 
                                            onClick={() => {
                                              const tools = (draft.tools || []).filter((_, i) => i !== idx);
                                              setDraft({ ...draft, tools });
                                            }}
                                            title="Ø­Ø°Ù Ø§Ø¨Ø²Ø§Ø±"
                                          >
                                            <FaTrash className="w-3 h-3" />
                                          </button>
                                        </div>
                                      </div>
                                      <div className="flex flex-wrap gap-2 text-xs">
                                        {stairSystemV2.stairActivePart === 'landing' && (
                                          <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                            <input 
                                              type="checkbox" 
                                              checked={!!tool.perimeter} 
                                              onChange={(e) => {
                                                const tools = [...(draft.tools || [])];
                                                tools[idx] = { ...tool, perimeter: e.target.checked };
                                                setDraft({ ...draft, tools });
                                              }} 
                                              className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                            /> 
                                            <span className="text-gray-700 dark:text-gray-300">Ù…Ø­ÛŒØ· Ú©Ø§Ù…Ù„</span>
                                          </label>
                                        )}
                                        <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                          <input 
                                            type="checkbox" 
                                            checked={!!tool.front} 
                                            onChange={(e) => {
                                              const tools = [...(draft.tools || [])]; 
                                              tools[idx] = { ...tool, front: e.target.checked }; 
                                              setDraft({ ...draft, tools });
                                            }} 
                                            className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                          /> 
                                          <span className="text-gray-700 dark:text-gray-300">Ø¬Ù„Ùˆ</span>
                                        </label>
                                        {stairSystemV2.stairActivePart === 'landing' && (
                                          <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                            <input 
                                              type="checkbox" 
                                              checked={!!tool.back} 
                                              onChange={(e) => {
                                                const tools = [...(draft.tools || [])]; 
                                                tools[idx] = { ...tool, back: e.target.checked }; 
                                                setDraft({ ...draft, tools });
                                              }} 
                                              className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                            /> 
                                            <span className="text-gray-700 dark:text-gray-300">Ø¹Ù‚Ø¨</span>
                                          </label>
                                        )}
                                        <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                          <input 
                                            type="checkbox" 
                                            checked={!!tool.left} 
                                            onChange={(e) => {
                                              const tools = [...(draft.tools || [])]; 
                                              tools[idx] = { ...tool, left: e.target.checked }; 
                                              setDraft({ ...draft, tools });
                                            }} 
                                            className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                          /> 
                                          <span className="text-gray-700 dark:text-gray-300">Ú†Ù¾</span>
                                        </label>
                                        <label className="flex items-center gap-1.5 px-2 py-1 bg-white dark:bg-gray-800 rounded border border-purple-200 dark:border-purple-700 cursor-pointer hover:bg-purple-100 dark:hover:bg-purple-900/30 transition-colors">
                                          <input 
                                            type="checkbox" 
                                            checked={!!tool.right} 
                                            onChange={(e) => {
                                              const tools = [...(draft.tools || [])]; 
                                              tools[idx] = { ...tool, right: e.target.checked }; 
                                              setDraft({ ...draft, tools });
                                            }} 
                                            className="rounded border-gray-300 text-purple-600 focus:ring-purple-500"
                                          /> 
                                          <span className="text-gray-700 dark:text-gray-300">Ø±Ø§Ø³Øª</span>
                                        </label>
                                      </div>
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                      )}

                      {/* Layers Section (Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§) - Enhanced */}
                      {/* ğŸ¯ Hide layers section for riser */}
                      {stairSystemV2.stairActivePart !== 'riser' && (
                      <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                        <div className="flex items-center justify-between mb-4">
                          <div className="flex items-center gap-2">
                            <div className="w-1 h-5 bg-gradient-to-b from-orange-500 to-orange-600 rounded-full"></div>
                            <h5 className="text-sm font-semibold text-gray-800 dark:text-white">Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§</h5>
                          </div>
                          <span className="text-xs text-orange-600 dark:text-orange-400 bg-orange-50 dark:bg-orange-900/20 px-2 py-1 rounded">Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡</span>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          <div>
                            <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                              <span className="flex items-center gap-1">
                                <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                ØªØ¹Ø¯Ø§Ø¯ Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡
                              </span>
                            </label>
                            <FormattedNumberInput
                              value={draft.numberOfLayersPerStair ?? null}
                              onChange={(value) => {
                                // ğŸ¯ Ensure integer value and validate
                                const intValue = value ? Math.floor(value) : null;
                                const requiresLayerType = stairSystemV2.layerTypes.length > 0;
                                if (intValue && intValue > 0 && intValue <= 10) { // Reasonable max: 10 layers per stair
                                  let updatedDraft: StairPartDraftV2 = { ...draft, numberOfLayersPerStair: intValue };
                                  if (!hasLayerEdgeSelection(updatedDraft.layerEdges)) {
                                    updatedDraft = deriveLayerEdgesFromTools(updatedDraft, stairSystemV2.stairActivePart);
                                  }
                                  setDraft(updatedDraft);
                                  if (requiresLayerType && !draft.layerTypeId) {
                                    stairSystemV2.setStairDraftErrors(prev => ({
                                      ...prev,
                                      [stairSystemV2.stairActivePart]: { 
                                        ...prev[stairSystemV2.stairActivePart], 
                                        layerType: 'Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯'
                                      }
                                    }));
                                  } else {
                                    clearDraftFieldError(stairSystemV2.stairActivePart, 'layerType');
                                  }
                                } else if (intValue === null || intValue === 0) {
                                  setDraft({
                                    ...draft,
                                    numberOfLayersPerStair: null,
                                    layerUseDifferentStone: false,
                                    layerStoneProductId: null,
                                    layerStoneProduct: null,
                                    layerStoneLabel: null,
                                    layerPricePerSquareMeter: null,
                                    layerUseMandatory: undefined,
                                    layerMandatoryPercentage: null
                                  });
                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerType');
                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStone');
                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStonePrice');
                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerMandatoryPercentage');
                                } else if (intValue > 10) {
                                  // Show error for too many layers
                                  stairSystemV2.setStairDraftErrors(prev => ({
                                    ...prev,
                                    [stairSystemV2.stairActivePart]: { 
                                      ...prev[stairSystemV2.stairActivePart], 
                                      quantity: 'ØªØ¹Ø¯Ø§Ø¯ Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² 10 Ø¨Ø§Ø´Ø¯'
                                    }
                                  }));
                                }
                              }}
                              min={1}
                              step={1}
                              max={10}
                              className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                              placeholder="Ù…Ø«Ø§Ù„: 2 (Ø¨Ø±Ø§ÛŒ Ø¯ÙˆØ¨Ù„)"
                            />
                            <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                              ØªØ¹Ø¯Ø§Ø¯ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡ Ù†ÛŒØ§Ø² Ø§Ø³Øª (Ù…Ø«Ø§Ù„: 2 Ø¨Ø±Ø§ÛŒ Ø¯ÙˆØ¨Ù„)
                            </p>
                          </div>
                          
                          {draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && (
                            <>
                              <div>
                                <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  <span className="flex items-center gap-1">
                                    <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                    Ø¹Ø±Ø¶ Ù„Ø§ÛŒÙ‡ (Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±)
                                  </span>
                                </label>
                                <FormattedNumberInput
                                  value={draft.layerWidthCm ?? null}
                                  onChange={(value) => {
                                    const updatedDraft = { ...draft, layerWidthCm: value && value > 0 ? value : null };
                                    // ğŸ¯ Validate layer width against available remaining width
                                    if (value && value > 0) {
                                      const originalWidthCm = draft.stoneProduct?.widthValue || 0;
                                      const mainWidthCm = draft.widthCm || 0;
                                      const availableWidthCm = originalWidthCm - mainWidthCm;
                                      
                                      if (originalWidthCm > 0 && value > availableWidthCm && availableWidthCm > 0) {
                                        stairSystemV2.setStairDraftErrors(prev => ({
                                          ...prev,
                                          [stairSystemV2.stairActivePart]: { 
                                            ...prev[stairSystemV2.stairActivePart], 
                                            width: `Ø¹Ø±Ø¶ Ù„Ø§ÛŒÙ‡ (${formatDisplayNumber(value)}cm) Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ (${formatDisplayNumber(availableWidthCm)}cm) Ø¨Ø§Ø´Ø¯`
                                          }
                                        }));
                                      } else if (value < 0.5) {
                                        stairSystemV2.setStairDraftErrors(prev => ({
                                          ...prev,
                                          [stairSystemV2.stairActivePart]: { 
                                            ...prev[stairSystemV2.stairActivePart], 
                                            width: 'Ø¹Ø±Ø¶ Ù„Ø§ÛŒÙ‡ Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ 0.5 Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± Ø¨Ø§Ø´Ø¯'
                                          }
                                        }));
                                      } else {
                                        clearDraftFieldError(stairSystemV2.stairActivePart, 'width');
                                      }
                                    }
                                    setDraft(updatedDraft);
                                  }}
                                  min={0.5}
                                  step={0.1}
                                  className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                                  placeholder="Ù…Ø«Ø§Ù„: 15"
                                />
                              </div>
                              
                              
                              {stairSystemV2.layerTypes.length > 0 && (
                                <div>
                                  <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    <span className="flex items-center gap-1">
                                      <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                      Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡
                                    </span>
                                  </label>
                                  <select
                                    className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all font-medium"
                                    value={draft.layerTypeId || ''}
                                    disabled={stairSystemV2.isLoadingLayerTypes}
                                    onChange={(e) => {
                                      const selectedId = e.target.value;
                                      if (!selectedId) {
                                        setDraft({
                                          ...draft,
                                          layerTypeId: null,
                                          layerTypeName: null,
                                          layerTypePrice: null
                                        });
                                        if ((draft.numberOfLayersPerStair || 0) > 0) {
                                          stairSystemV2.setStairDraftErrors(prev => ({
                                            ...prev,
                                            [stairSystemV2.stairActivePart]: { 
                                              ...prev[stairSystemV2.stairActivePart], 
                                              layerType: 'Ù„Ø·ÙØ§Ù‹ Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯'
                                            }
                                          }));
                                        }
                                        return;
                                      }
                                      const selected = stairSystemV2.layerTypes.find(option => option.id === selectedId);
                                      if (selected) {
                                        clearDraftFieldError(stairSystemV2.stairActivePart, 'layerType');
                                        setDraft({
                                          ...draft,
                                          layerTypeId: selected.id,
                                          layerTypeName: selected.name,
                                          layerTypePrice: selected.pricePerLayer
                                        });
                                      }
                                    }}
                                  >
                                    <option value="">Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡...</option>
                                    {stairSystemV2.layerTypes.map((option: LayerTypeOption) => (
                                      <option key={option.id} value={option.id}>
                                        {option.name} - {option.pricePerLayer.toLocaleString('fa-IR')} ØªÙˆÙ…Ø§Ù†
                                      </option>
                                    ))}
                                  </select>
                                  {stairSystemV2.layerTypesError && (
                                    <p className="mt-1 text-xs text-red-500 dark:text-red-400">
                                      {stairSystemV2.layerTypesError}
                                    </p>
                                  )}
                                  {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerType && (
                                    <p className="mt-1 text-xs text-red-500">
                                      {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerType}
                                    </p>
                                  )}
                                </div>
                              )}

                              <div className="md:col-span-2">
                                <div className="border border-dashed border-orange-200 dark:border-orange-800 rounded-lg p-4 bg-orange-50/30 dark:bg-orange-900/10">
                                  <div className="flex items-center justify-between">
                                    <div>
                                      <h6 className="text-xs font-semibold text-orange-700 dark:text-orange-300">
                                        Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø³Ù†Ú¯ Ù…ØªÙØ§ÙˆØª Ø¨Ø±Ø§ÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§
                                      </h6>
                                      <p className="text-[11px] text-gray-500 dark:text-gray-400 mt-1">
                                        Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø³Ù†Ú¯ Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø¨Ø±Ø§ÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡ Ùˆ Ù‚ÛŒÙ…Øª Ù…Ø³ØªÙ‚Ù„ Ø¢Ù† Ø±Ø§ Ø«Ø¨Øª Ú©Ù†ÛŒØ¯.
                                      </p>
                                    </div>
                                    <button
                                      type="button"
                                      onClick={() => {
                                        if (draft.layerUseDifferentStone) {
                                          setDraft({
                                            ...draft,
                                            layerUseDifferentStone: false,
                                            layerStoneProductId: null,
                                            layerStoneProduct: null,
                                            layerStoneLabel: null,
                                            layerPricePerSquareMeter: null,
                                            layerUseMandatory: undefined,
                                            layerMandatoryPercentage: null
                                          });
                                          clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStone');
                                          clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStonePrice');
                                          clearDraftFieldError(stairSystemV2.stairActivePart, 'layerMandatoryPercentage');
                                        } else {
                                          setDraft({
                                            ...draft,
                                            layerUseDifferentStone: true,
                                            layerStoneProductId: null,
                                            layerStoneProduct: null,
                                            layerStoneLabel: null,
                                            layerPricePerSquareMeter: draft.pricePerSquareMeter || null,
                                            layerUseMandatory: true,
                                            layerMandatoryPercentage: draft.layerMandatoryPercentage ?? 20
                                          });
                                        }
                                      }}
                                      className={`px-3 py-1.5 rounded-lg text-xs font-medium transition-colors ${
                                        draft.layerUseDifferentStone
                                          ? 'bg-orange-500 text-white hover:bg-orange-600'
                                          : 'bg-white dark:bg-gray-900/40 text-orange-600 border border-orange-200 dark:border-orange-800 hover:bg-orange-100 dark:hover:bg-orange-900/40'
                                      }`}
                                    >
                                      {draft.layerUseDifferentStone ? 'Ù„ØºÙˆ Ø§Ø³ØªÙØ§Ø¯Ù‡' : 'ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ'}
                                    </button>
                                  </div>

                                  {draft.layerUseDifferentStone && (
                                    <div className="mt-4 space-y-4">
                                      <div>
                                        <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                          Ø§Ù†ØªØ®Ø§Ø¨ Ø³Ù†Ú¯ Ø¨Ø±Ø§ÛŒ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§
                                        </label>
                                        {!draft.layerStoneProduct ? (
                                          <>
                                            <input
                                              className="w-full rounded-lg bg-white dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                                              placeholder="Ù†Ø§Ù… Ø³Ù†Ú¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†ÛŒØ¯"
                                              value={stairSystemV2.layerStoneSearchTerm}
                                              onChange={(e) => stairSystemV2.setLayerStoneSearchTerm(e.target.value)}
                                              onFocus={() => stairSystemV2.setLayerStoneDropdownOpen(true)}
                                              onBlur={() => setTimeout(() => stairSystemV2.setLayerStoneDropdownOpen(false), 150)}
                                            />
                                            {stairSystemV2.layerStoneDropdownOpen && (
                                              <div className="mt-2 max-h-48 overflow-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-lg">
                                                {stairSystemV2.isSearchingLayerStones && (
                                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">
                                                    <span className="animate-pulse">Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ...</span>
                                                  </div>
                                                )}
                                                {!stairSystemV2.isSearchingLayerStones && stairSystemV2.layerStoneSearchResults.length === 0 && (
                                                  <div className="p-3 text-center text-sm text-gray-500 dark:text-gray-400">Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯</div>
                                                )}
                                                {stairSystemV2.layerStoneSearchResults.map((p) => (
                                                  <button
                                                    key={p.id}
                                                    type="button"
                                                    className="w-full text-right px-4 py-2.5 hover:bg-orange-50 dark:hover:bg-orange-900/20 text-sm border-b border-gray-100 dark:border-gray-700 last:border-0 transition-colors"
                                                    onClick={() => {
                                                      const altLabel = (p as any).fullName || generateFullProductName(p as Product) || p.namePersian || p.name;
                                                      setDraft({
                                                        ...draft,
                                                        layerUseDifferentStone: true,
                                                        layerStoneProductId: p.id,
                                                        layerStoneProduct: p,
                                                        layerStoneLabel: altLabel,
                                                        layerPricePerSquareMeter: p.basePrice || draft.layerPricePerSquareMeter || draft.pricePerSquareMeter || null,
                                                        layerUseMandatory: draft.layerUseMandatory ?? true,
                                                        layerMandatoryPercentage: draft.layerMandatoryPercentage ?? 20
                                                      });
                                                      stairSystemV2.setLayerStoneSearchTerm('');
                                                      stairSystemV2.setLayerStoneDropdownOpen(false);
                                                      clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStone');
                                                    }}
                                                  >
                                                    <div className="font-medium text-gray-800 dark:text-white">
                                                      {(p as any).fullName || generateFullProductName(p as Product) || p.namePersian || p.name}
                                                    </div>
                                                    {p.basePrice && (
                                                      <div className="text-xs text-orange-600 dark:text-orange-400 mt-0.5">{formatPrice(p.basePrice)}</div>
                                                    )}
                                                  </button>
                                                ))}
                                              </div>
                                            )}
                                          </>
                                        ) : (
                                          <div className="flex items-center justify-between p-3 bg-white dark:bg-gray-900/40 border border-orange-200 dark:border-orange-700 rounded-lg">
                                            <div>
                                              <div className="text-sm font-semibold text-gray-800 dark:text-white">
                                                {draft.layerStoneLabel || draft.layerStoneProduct.namePersian || draft.layerStoneProduct.name}
                                              </div>
                                              <div className="text-[11px] text-gray-500 dark:text-gray-400">
                                                Ú©Ø¯: {draft.layerStoneProduct.code || '-'}
                                              </div>
                                            </div>
                                            <div className="flex gap-2">
                                              <button
                                                type="button"
                                                className="px-2 py-1 text-xs text-orange-600 hover:text-orange-800 hover:bg-orange-100 dark:hover:bg-orange-900/30 rounded"
                                                onClick={() => {
                                                  setDraft({
                                                    ...draft,
                                                    layerStoneProductId: null,
                                                    layerStoneProduct: null,
                                                    layerStoneLabel: null
                                                  });
                                                  stairSystemV2.setLayerStoneSearchTerm('');
                                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStone');
                                                }}
                                              >
                                                ØªØºÛŒÛŒØ±
                                              </button>
                                              <button
                                                type="button"
                                                className="px-2 py-1 text-xs text-red-600 hover:text-red-800 hover:bg-red-50 dark:hover:bg-red-900/30 rounded"
                                                onClick={() => {
                                                  setDraft({
                                                    ...draft,
                                                    layerUseDifferentStone: false,
                                                    layerStoneProductId: null,
                                                    layerStoneProduct: null,
                                                    layerStoneLabel: null,
                                                    layerPricePerSquareMeter: null
                                                  });
                                                  stairSystemV2.setLayerStoneSearchTerm('');
                                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStone');
                                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStonePrice');
                                                }}
                                              >
                                                Ø­Ø°Ù
                                              </button>
                                            </div>
                                          </div>
                                        )}
                                        {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerStone && (
                                          <p className="mt-1 text-xs text-red-500">
                                            {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerStone}
                                          </p>
                                        )}
                                      </div>

                                      <div>
                                        <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                          Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø³Ù†Ú¯ Ù„Ø§ÛŒÙ‡ (ØªÙˆÙ…Ø§Ù†)
                                        </label>
                                        <FormattedNumberInput
                                          value={draft.layerPricePerSquareMeter ?? null}
                                          onChange={(value) => {
                                            const updatedDraft = { ...draft, layerPricePerSquareMeter: value && value > 0 ? value : null };
                                            const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'layerStonePrice', value);
                                            if (error) {
                                              stairSystemV2.setStairDraftErrors(prev => ({
                                                ...prev,
                                                [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], layerStonePrice: error }
                                              }));
                                            } else {
                                              clearDraftFieldError(stairSystemV2.stairActivePart, 'layerStonePrice');
                                            }
                                            setDraft(updatedDraft);
                                          }}
                                          min={0}
                                          step={1000}
                                          className="w-full rounded-lg bg-white dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-4 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all"
                                          placeholder="Ù…Ø«Ø§Ù„: 1,800,000"
                                        />
                                        {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerStonePrice && (
                                          <p className="mt-1 text-xs text-red-500">
                                            {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerStonePrice}
                                          </p>
                                        )}
                                      </div>

                                      <div className="rounded-lg border border-orange-100 dark:border-orange-800 bg-white dark:bg-gray-900/30 p-3">
                                        <div className="flex items-center gap-2">
                                          <input
                                            type="checkbox"
                                            className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                            checked={draft.layerUseMandatory ?? true}
                                            onChange={(e) => {
                                              const nextValue = e.target.checked;
                                              const updatedDraft = {
                                                ...draft,
                                                layerUseMandatory: nextValue,
                                                layerMandatoryPercentage: nextValue
                                                  ? (draft.layerMandatoryPercentage ?? 20)
                                                  : null
                                              };
                                              if (!nextValue) {
                                                clearDraftFieldError(stairSystemV2.stairActivePart, 'layerMandatoryPercentage');
                                              }
                                              setDraft(updatedDraft);
                                            }}
                                          />
                                          <div>
                                            <label className="text-xs font-medium text-gray-700 dark:text-gray-300">
                                              Ø­Ú©Ù…ÛŒ (Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª)
                                            </label>
                                            <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                              Ø¯Ø± ØµÙˆØ±Øª ÙØ¹Ø§Ù„ Ø¨ÙˆØ¯Ù†ØŒ Ù‚ÛŒÙ…Øª Ø³Ù†Ú¯ Ù„Ø§ÛŒÙ‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø±ØµØ¯ÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                            </p>
                                          </div>
                                        </div>
                                        {draft.layerUseMandatory !== false && (
                                          <div className="mt-3 flex items-center gap-2">
                                            <FormattedNumberInput
                                              value={draft.layerMandatoryPercentage ?? 20}
                                              onChange={(value) => {
                                                const updatedDraft = { ...draft, layerMandatoryPercentage: value ?? 0 };
                                                const error = validateDraftNumericFields(stairSystemV2.stairActivePart, updatedDraft, 'layerMandatoryPercentage', value);
                                                if (error) {
                                                  stairSystemV2.setStairDraftErrors(prev => ({
                                                    ...prev,
                                                    [stairSystemV2.stairActivePart]: { ...prev[stairSystemV2.stairActivePart], layerMandatoryPercentage: error }
                                                  }));
                                                } else {
                                                  clearDraftFieldError(stairSystemV2.stairActivePart, 'layerMandatoryPercentage');
                                                }
                                                setDraft(updatedDraft);
                                              }}
                                              min={0}
                                              max={100}
                                              step={1}
                                              className="w-24 rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent text-sm"
                                            />
                                            <span className="text-xs text-gray-600 dark:text-gray-300">%</span>
                                            <p className="text-[11px] text-gray-500 dark:text-gray-400">
                                              Ù‚ÛŒÙ…Øª Ù†Ù‡Ø§ÛŒÛŒ Ø¨Ø§ {formatDisplayNumber(draft.layerMandatoryPercentage ?? 20)}% Ø§ÙØ²Ø§ÛŒØ´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                            </p>
                                          </div>
                                        )}
                                        {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerMandatoryPercentage && (
                                          <p className="mt-1 text-xs text-red-500">
                                            {stairSystemV2.stairDraftErrors[stairSystemV2.stairActivePart]?.layerMandatoryPercentage}
                                          </p>
                                        )}
                                      </div>
                                    </div>
                                  )}
                                </div>
                              </div>

                              {/* ğŸ¯ Layer Edge Selection */}
                              <div className="md:col-span-2">
                                <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  <span className="flex items-center gap-1">
                                    <span className="w-2 h-2 rounded-full bg-orange-500"></span>
                                    Ø§Ù†ØªØ®Ø§Ø¨ Ù„Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ Ù„Ø§ÛŒÙ‡
                                  </span>
                                </label>
                                <div className="flex flex-wrap gap-2 p-3 bg-orange-50/50 dark:bg-orange-900/10 rounded-lg border border-orange-200 dark:border-orange-800">
                                  {stairSystemV2.stairActivePart === 'landing' && (
                                    <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                      <input 
                                        type="checkbox" 
                                        checked={!!(draft.layerEdges?.perimeter)} 
                                        onChange={(e) => {
                                          const currentEdges = draft.layerEdges || {};
                                          setDraft({ 
                                            ...draft, 
                                            layerEdges: { 
                                              ...currentEdges, 
                                              perimeter: e.target.checked,
                                              // If perimeter is checked, uncheck individual edges
                                              front: e.target.checked ? false : currentEdges.front,
                                              left: e.target.checked ? false : currentEdges.left,
                                              right: e.target.checked ? false : currentEdges.right,
                                              back: e.target.checked ? false : currentEdges.back
                                            } 
                                          });
                                        }} 
                                        className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      /> 
                                      <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">Ù…Ø­ÛŒØ· Ú©Ø§Ù…Ù„</span>
                                    </label>
                                  )}
                                  <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                    <input 
                                      type="checkbox" 
                                      checked={!!(draft.layerEdges?.front)} 
                                      onChange={(e) => {
                                        const currentEdges = draft.layerEdges || {};
                                        setDraft({ 
                                          ...draft, 
                                          layerEdges: { 
                                            ...currentEdges, 
                                            front: e.target.checked,
                                            perimeter: e.target.checked ? false : currentEdges.perimeter
                                          } 
                                        });
                                      }} 
                                      className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      disabled={!!(draft.layerEdges?.perimeter)}
                                    /> 
                                    <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">Ø¬Ù„Ùˆ</span>
                                  </label>
                                  {stairSystemV2.stairActivePart === 'landing' && (
                                    <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                      <input 
                                        type="checkbox" 
                                        checked={!!(draft.layerEdges?.back)} 
                                        onChange={(e) => {
                                          const currentEdges = draft.layerEdges || {};
                                          setDraft({ 
                                            ...draft, 
                                            layerEdges: { 
                                              ...currentEdges, 
                                              back: e.target.checked,
                                              perimeter: e.target.checked ? false : currentEdges.perimeter
                                            } 
                                          });
                                        }} 
                                        className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                        disabled={!!(draft.layerEdges?.perimeter)}
                                      /> 
                                      <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">Ø¹Ù‚Ø¨</span>
                                    </label>
                                  )}
                                  <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                    <input 
                                      type="checkbox" 
                                      checked={!!(draft.layerEdges?.left)} 
                                      onChange={(e) => {
                                        const currentEdges = draft.layerEdges || {};
                                        setDraft({ 
                                          ...draft, 
                                          layerEdges: { 
                                            ...currentEdges, 
                                            left: e.target.checked,
                                            perimeter: e.target.checked ? false : currentEdges.perimeter
                                          } 
                                        });
                                      }} 
                                      className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      disabled={!!(draft.layerEdges?.perimeter)}
                                    /> 
                                    <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">Ú†Ù¾</span>
                                  </label>
                                  <label className="flex items-center gap-1.5 px-3 py-2 bg-white dark:bg-gray-800 rounded border border-orange-200 dark:border-orange-700 cursor-pointer hover:bg-orange-100 dark:hover:bg-orange-900/30 transition-colors">
                                    <input 
                                      type="checkbox" 
                                      checked={!!(draft.layerEdges?.right)} 
                                      onChange={(e) => {
                                        const currentEdges = draft.layerEdges || {};
                                        setDraft({ 
                                          ...draft, 
                                          layerEdges: { 
                                            ...currentEdges, 
                                            right: e.target.checked,
                                            perimeter: e.target.checked ? false : currentEdges.perimeter
                                          } 
                                        });
                                      }} 
                                      className="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                                      disabled={!!(draft.layerEdges?.perimeter)}
                                    /> 
                                    <span className="text-gray-700 dark:text-gray-300 text-xs font-medium">Ø±Ø§Ø³Øª</span>
                                  </label>
                                </div>
                                {(!draft.layerEdges || (!draft.layerEdges.front && !draft.layerEdges.left && !draft.layerEdges.right && !draft.layerEdges.back && !draft.layerEdges.perimeter)) && (
                                  <p className="mt-2 text-xs text-orange-600 dark:text-orange-400">
                                    Ù„Ø·ÙØ§Ù‹ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ù„Ø¨Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯
                                  </p>
                                )}
                              </div>
                              
                              {draft.numberOfLayersPerStair && draft.layerWidthCm && draft.pricePerSquareMeter && draft.quantity && 
                               (stairSystemV2.layerTypes.length === 0 || draft.layerTypeId) &&
                               draft.layerEdges && (draft.layerEdges.front || draft.layerEdges.left || draft.layerEdges.right || draft.layerEdges.back || draft.layerEdges.perimeter) && (() => {
                                // ğŸ¯ Use computeLayerSqmV2 for consistent calculation (accounts for overlap)
                                const totalLayers = draft.quantity * draft.numberOfLayersPerStair;
                                const totalLayerSqm = computeLayerSqmV2(stairSystemV2.stairActivePart, draft);
                                
                                const layerWidthCm = draft.layerWidthCm || 0;
                                const stoneWidthCm = draft.layerUseDifferentStone 
                                  ? (draft.layerStoneProduct?.widthValue || draft.stoneProduct?.widthValue || 0)
                                  : (draft.stoneProduct?.widthValue || 0);
                                const stairLengthM = getActualLengthMeters(draft);
                                
                                    const stoneWidthM = stoneWidthCm / 100;
                                const columnsPerStone = stoneWidthCm > 0 && layerWidthCm > 0
                                  ? Math.max(1, Math.floor(stoneWidthCm / layerWidthCm))
                                  : 0;
                                
                                const edgeDemandsPreview = getLayerEdgeDemands(stairSystemV2.stairActivePart, draft);
                                const needsNewStone = edgeDemandsPreview.filter(edge =>
                                  !(edge.edge === 'front' || edge.edge === 'back' || edge.edge === 'perimeter')
                                );
                                
                                const stoneAreaUsedSqm = (() => {
                                  if (!needsNewStone.length || !columnsPerStone || !stairLengthM || !stoneWidthM) {
                                    return 0;
                                  }
                                  let stonesNeeded = 0;
                                  needsNewStone.forEach(edge => {
                                    if (edge.lengthM <= 0) return;
                                    const stripsPerColumn = Math.max(1, Math.floor(stairLengthM / edge.lengthM));
                                    const stripsPerStone = Math.max(1, stripsPerColumn * columnsPerStone);
                                    stonesNeeded += Math.ceil(edge.layersNeeded / stripsPerStone);
                                  });
                                  if (!stonesNeeded) return 0;
                                  return stonesNeeded * stairLengthM * stoneWidthM;
                                })();
                                
                                // Use the same price as the main stair part
                                const pricePerSqm = draft.pricePerSquareMeter || 0;
                                const layerTypeUnitPrice = draft.layerTypePrice || 0;
                                
                                // ğŸ¯ FIX: Calculate layer type cost based on total length per stair Ã— number of stairs Ã— layer type price per meter
                                // Ù…Ø¬Ù…ÙˆØ¹ Ø·ÙˆÙ„Ù‡ Ù‡Ø§ÛŒ Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ù¾Ù„Ù‡ (Ú†Ù¾ + Ø±Ø§Ø³Øª + Ø¬Ù„Ùˆ) Ã— ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡ Ù‡Ø§ Ã— Ù‡Ø²ÛŒÙ†Ù‡ Ù‡Ø± Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡
                                const totalLayerLengthPerStairM = getTotalLayerLengthPerStairM(stairSystemV2.stairActivePart, draft);
                                const totalLayerLengthM = totalLayerLengthPerStairM * draft.quantity;
                                const layerTypeCostPreview = totalLayerLengthM * layerTypeUnitPrice;
                                
                                // ğŸ¯ FIX: Calculate layer stone price based on stone area used, NOT layer square meters
                                // Use stone area used for pricing (includes waste/remaining pieces)
                                const pricingStoneAreaSqm = stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : totalLayerSqm;
                                const baseLayerCost = pricingStoneAreaSqm * pricePerSqm;
                                const layerTotalPrice = baseLayerCost + layerTypeCostPreview;
                                
                                return (
                                  <div className="md:col-span-2">
                                    <div className="mt-2 rounded-lg border border-orange-200 dark:border-orange-800 bg-orange-50 dark:bg-orange-900/20 px-4 py-3 text-xs leading-5 text-orange-700 dark:text-orange-200">
                                      <div className="font-semibold mb-1">Ø®Ù„Ø§ØµÙ‡ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§:</div>
                                      <div>ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§: {formatDisplayNumber(totalLayers)} Ø¹Ø¯Ø¯ ({formatDisplayNumber(draft.quantity)} Ù¾Ù„Ù‡ Ã— {formatDisplayNumber(draft.numberOfLayersPerStair)} Ù„Ø§ÛŒÙ‡)</div>
                                      <div className="mt-1">
                                        <span className="font-medium">Ù„Ø¨Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡: </span>
                                        {stairSystemV2.stairActivePart === 'landing' && draft.layerEdges?.perimeter && (
                                          <span className="text-orange-600 dark:text-orange-400">Ù…Ø­ÛŒØ· Ú©Ø§Ù…Ù„</span>
                                        )}
                                        {!draft.layerEdges?.perimeter && (
                                          <>
                                            {draft.layerEdges?.front && <span className="text-orange-600 dark:text-orange-400">Ø¬Ù„Ùˆ </span>}
                                            {draft.layerEdges?.back && <span className="text-orange-600 dark:text-orange-400">Ø¹Ù‚Ø¨ </span>}
                                            {draft.layerEdges?.left && <span className="text-orange-600 dark:text-orange-400">Ú†Ù¾ </span>}
                                            {draft.layerEdges?.right && <span className="text-orange-600 dark:text-orange-400">Ø±Ø§Ø³Øª </span>}
                                          </>
                                        )}
                                      </div>
                                      <div>Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡: {formatSquareMeters(totalLayerSqm)}</div>
                                      {stoneAreaUsedSqm > 0 && (
                                        <div>Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø³Ù†Ú¯: {formatSquareMeters(stoneAreaUsedSqm)}</div>
                                      )}
                                      <div className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                        Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹: {formatPrice(pricePerSqm)} (Ù‡Ù…Ø§Ù† Ø³Ù†Ú¯ Ø§ØµÙ„ÛŒ)
                                      </div>
                                      <div className="mt-1 pt-1 border-t border-orange-200 dark:border-orange-700">
                                        <div className="text-xs text-gray-600 dark:text-gray-400 mb-1">
                                            Ù‚ÛŒÙ…Øª Ø³Ù†Ú¯ Ù„Ø§ÛŒÙ‡: {formatPrice((stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : totalLayerSqm) * pricePerSqm)}
                                            {stoneAreaUsedSqm > 0 && (
                                            <span className="text-xs text-gray-500 dark:text-gray-500 mr-1">
                                                (Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø³Ù†Ú¯: {formatSquareMeters(stoneAreaUsedSqm)})
                                            </span>
                                          )}
                                        </div>
                                        {layerTypeUnitPrice > 0 && (
                                          <div className="text-xs text-gray-600 dark:text-gray-400 mb-1">
                                            Ù‡Ø²ÛŒÙ†Ù‡ Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡ ({draft.layerTypeName || '-'}): {formatPrice(layerTypeCostPreview)}
                                            <span className="text-xs text-gray-500 dark:text-gray-500 ml-1">
                                              ({formatDisplayNumber(totalLayerLengthPerStairM)} Ù…ØªØ± Ã— {formatDisplayNumber(draft.quantity)} Ù¾Ù„Ù‡ Ã— {formatPrice(layerTypeUnitPrice)}/Ù…ØªØ±)
                                            </span>
                                          </div>
                                        )}
                                        <div className="mt-1 pt-1 border-t border-orange-200 dark:border-orange-700">
                                          <span className="font-semibold">Ù‚ÛŒÙ…Øª Ú©Ù„ Ù„Ø§ÛŒÙ‡â€ŒÙ‡Ø§: {formatPrice(layerTotalPrice)}</span>
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                );
                              })()}
                            </>
                          )}
                        </div>
                      </div>
                      )}

                      {stoneFinishings.length > 0 && (
                        <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-5 shadow-sm">
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-2">
                              <div className="w-1 h-5 bg-gradient-to-b from-teal-500 to-teal-600 rounded-full"></div>
                              <h5 className="text-sm font-semibold text-gray-800 dark:text-white">Ù¾Ø±Ø¯Ø§Ø®Øª Ø³Ù†Ú¯</h5>
                            </div>
                            <span className="text-xs text-teal-600 dark:text-teal-300 bg-teal-50 dark:bg-teal-900/30 px-2 py-1 rounded">
                              Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ù‡ Ø§Ø²Ø§ÛŒ Ù…ØªØ± Ù…Ø±Ø¨Ø¹
                            </span>
                          </div>
                          <div className="space-y-4">
                            <label className="flex items-center gap-2 text-sm text-gray-700 dark:text-gray-200">
                              <input
                                type="checkbox"
                                className="rounded border-gray-300 text-teal-600 focus:ring-teal-500"
                                checked={!!draft.finishingEnabled}
                                onChange={(e) => {
                                  const enabled = e.target.checked;
                                  if (!enabled) {
                                    setDraft({
                                      ...draft,
                                      finishingEnabled: false,
                                      finishingId: null,
                                      finishingLabel: null,
                                      finishingPricePerSquareMeter: null
                                    });
                                    return;
                                  }
                                  const defaultFinishing = draft.finishingId
                                    ? stoneFinishings.find(option => option.id === draft.finishingId)
                                    : stoneFinishings[0];
                                  setDraft({
                                    ...draft,
                                    finishingEnabled: true,
                                    finishingId: defaultFinishing?.id || draft.finishingId || null,
                                    finishingLabel: defaultFinishing
                                      ? (defaultFinishing.namePersian || defaultFinishing.name || '')
                                      : draft.finishingLabel || null,
                                    finishingPricePerSquareMeter: defaultFinishing
                                      ? defaultFinishing.pricePerSquareMeter
                                      : draft.finishingPricePerSquareMeter || null
                                  });
                                }}
                              />
                              ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¨Ø®Ø´
                            </label>

                            {draft.finishingEnabled && (
                              <>
                                <div>
                                  <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ù¾Ø±Ø¯Ø§Ø®Øª
                                  </label>
                                  <select
                                    value={draft.finishingId || ''}
                                    onChange={(e) => {
                                      const selectedId = e.target.value;
                                      if (!selectedId) {
                                        setDraft({
                                          ...draft,
                                          finishingId: null,
                                          finishingLabel: null,
                                          finishingPricePerSquareMeter: null
                                        });
                                        return;
                                      }
                                      const selected = stoneFinishings.find(option => option.id === selectedId);
                                      if (selected) {
                                        setDraft({
                                          ...draft,
                                          finishingEnabled: true,
                                          finishingId: selected.id,
                                          finishingLabel: selected.namePersian || selected.name || '',
                                          finishingPricePerSquareMeter: selected.pricePerSquareMeter
                                        });
                                      }
                                    }}
                                    className="w-full rounded-lg bg-gray-50 dark:bg-gray-700/50 border border-gray-300 dark:border-gray-600 px-3 py-2.5 text-gray-800 dark:text-white focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent transition-all"
                                  >
                                    <option value="">Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø±Ø¯Ø§Ø®Øª...</option>
                                    {stoneFinishings.map(option => (
                                      <option key={option.id} value={option.id}>
                                        {option.namePersian} - {formatPrice(option.pricePerSquareMeter)}
                                      </option>
                                    ))}
                                  </select>
                                </div>

                                {selectedFinishing && finishingPricePerSquareMeter && (
                                  <div className="rounded-lg border border-teal-200 dark:border-teal-800 bg-teal-50 dark:bg-teal-900/20 px-4 py-3 text-xs leading-5 text-teal-700 dark:text-teal-200 space-y-1.5">
                                    <div className="flex justify-between">
                                      <span>Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹:</span>
                                      <span className="font-semibold">{formatPrice(finishingPricePerSquareMeter)}</span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span>Ù…Ø³Ø§Ø­Øª Ù…Ø­Ø§Ø³Ø¨Ø§ØªÛŒ:</span>
                                      <span className="font-semibold">{formatSquareMeters(totals.pricingSquareMeters)}</span>
                                    </div>
                                    <div className="flex justify-between">
                                      <span>Ù‡Ø²ÛŒÙ†Ù‡ ØªÙ‚Ø±ÛŒØ¨ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª:</span>
                                      <span className="font-semibold">{formatPrice(finishingPreviewCost)}</span>
                                    </div>
                                  </div>
                                )}
                            </>
                          )}
                        </div>
                      </div>
                      )}

                      {/* Part Total - Enhanced */}
                      <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 rounded-lg border-2 border-teal-300 dark:border-teal-700 p-4 flex items-center justify-between shadow-sm">
                        <div className="flex items-center gap-2">
                          <div className="w-1 h-6 bg-gradient-to-b from-teal-500 to-teal-600 rounded-full"></div>
                          <span className="text-sm font-semibold text-teal-900 dark:text-teal-200">Ø¬Ù…Ø¹ Ú©Ù„ Ø§ÛŒÙ† Ø¨Ø®Ø´</span>
                        </div>
                        <div className="text-xl font-bold text-teal-700 dark:text-teal-300">{formatPrice(totals.partTotal || 0)}</div>
                      </div>
                    </div>
                  );
                })()}

                {/* Session group summary (enhanced table) */}
                <div className="mt-4 border-t border-gray-200 dark:border-gray-700 pt-4">
                  <div className="flex items-center gap-2 mb-3">
                    <div className="w-1 h-6 bg-gradient-to-b from-purple-500 to-purple-600 rounded-full"></div>
                    <h4 className="text-base font-semibold text-gray-800 dark:text-white">Ø®Ù„Ø§ØµÙ‡ Ø§Ù‚Ù„Ø§Ù… Ø§ÙØ²ÙˆØ¯Ù‡ Ø´Ø¯Ù‡</h4>
                    <span className="px-2 py-0.5 bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded-full text-xs font-medium">
                      {stairSystemV2.stairSessionItems.length} Ø¢ÛŒØªÙ…
                    </span>
                  </div>
                  {stairSystemV2.stairSessionItems.length === 0 ? (
                    <div className="text-center py-6 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-dashed border-gray-300 dark:border-gray-600">
                      <p className="text-sm text-gray-400 dark:text-gray-500">Ù‡Ù†ÙˆØ² Ø¢ÛŒØªÙ…ÛŒ Ø§ÙØ²ÙˆØ¯Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
                    </div>
                  ) : (
                    <div className="overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 shadow-sm">
                      <table className="min-w-full text-sm">
                        <thead>
                          <tr className="bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/30 dark:to-purple-800/30 border-b border-purple-200 dark:border-purple-700">
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ø¨Ø®Ø´</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ø§Ø¨Ø¹Ø§Ø¯</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">ØªØ¹Ø¯Ø§Ø¯</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ù…ØªØ± Ù…Ø±Ø¨Ø¹</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ù‚ÛŒÙ…Øª Ù…ØªØ± Ù…Ø±Ø¨Ø¹</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ù‡Ø²ÛŒÙ†Ù‡ Ø§Ø¨Ø²Ø§Ø±</th>
                            <th className="text-right py-3 px-4 font-semibold text-purple-900 dark:text-purple-200">Ø¬Ù…Ø¹ Ø¬Ø²</th>
                          </tr>
                        </thead>
                        <tbody>
                          {stairSystemV2.stairSessionItems.map((it, idx) => {
                            const toolsTotal = ((it as any).meta?.tools || [])?.reduce((s: number, x: any) => s + (x.totalPrice || 0), 0) || 0;
                            const isLayer = ((it as any).meta?.isLayer) || false;
                            const layerInfo = ((it as any).meta?.layerInfo) || null;
                            const partTypeLabel = isLayer 
                              ? `Ù„Ø§ÛŒÙ‡ ${it.stairPartType === 'tread' ? 'Ú©Ù Ù¾Ù„Ù‡' : it.stairPartType === 'riser' ? 'Ø®ÛŒØ²' : 'Ù¾Ø§Ú¯Ø±Ø¯'}`
                              : (it.stairPartType === 'tread' ? 'Ú©Ù Ù¾Ù„Ù‡' : it.stairPartType === 'riser' ? 'Ø®ÛŒØ²' : 'Ù¾Ø§Ú¯Ø±Ø¯');
                            const partTypeColor = isLayer 
                              ? 'orange' 
                              : (it.stairPartType === 'tread' ? 'purple' : it.stairPartType === 'riser' ? 'blue' : 'indigo');
                            const lengthDisplay = it.lengthUnit === 'm' ? `${formatDisplayNumber(it.length)} m` : `${formatDisplayNumber(it.length)} cm`;
                            const widthDisplay = `${formatDisplayNumber(it.width)} cm`;
                            const stairMeta = ((it as any).meta?.stair) || {};
                            const baseStoneQuantity = stairMeta.baseStoneQuantity || 0;
                            const piecesPerStoneMeta = stairMeta.piecesPerStone || 0;
                            const leftoverWidthMeta = stairMeta.leftoverWidthCmPerStone || 0;
                            
                            return (
                              <tr key={idx} className={`border-b border-gray-100 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors ${idx % 2 === 0 ? 'bg-white dark:bg-gray-800' : 'bg-gray-50/50 dark:bg-gray-800/30'}`}>
                                <td className="py-3 px-4">
                                  <span className={`inline-flex items-center px-2.5 py-1 rounded-full text-xs font-semibold ${
                                    partTypeColor === 'purple' ? 'bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300' :
                                    partTypeColor === 'blue' ? 'bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300' :
                                    partTypeColor === 'orange' ? 'bg-orange-100 dark:bg-orange-900/30 text-orange-700 dark:text-orange-300' :
                                    'bg-indigo-100 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-300'
                                  }`}>
                                    {partTypeLabel}
                                  </span>
                                  {isLayer && layerInfo && (
                                    <div className="text-xs text-orange-600 dark:text-orange-400 mt-1">
                                      {layerInfo.numberOfLayersPerStair} Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ù¾Ù„Ù‡
                                    </div>
                                  )}
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300">
                                  <div className="flex flex-col gap-0.5">
                                    <span className="font-medium">Ø·ÙˆÙ„: {lengthDisplay}</span>
                                    <span className="text-xs text-gray-500 dark:text-gray-400">Ø¹Ø±Ø¶: {widthDisplay}</span>
                                  </div>
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300">
                                  <div className="flex flex-col gap-1">
                                    <span className="font-medium">{formatDisplayNumber(it.quantity || 0)} Ø¹Ø¯Ø¯</span>
                                    {baseStoneQuantity > 0 && (
                                      <span className="text-xs text-purple-600 dark:text-purple-300">
                                        Ø³Ù†Ú¯ Ù¾Ø§ÛŒÙ‡: {formatDisplayNumber(baseStoneQuantity)} Ø¹Ø¯Ø¯
                                        {piecesPerStoneMeta > 0 ? ` â€¢ ${formatDisplayNumber(piecesPerStoneMeta)} Ù‚Ø·Ø¹Ù‡ Ø§Ø² Ù‡Ø± Ø³Ù†Ú¯` : ''}
                                        {leftoverWidthMeta > 0 ? ` â€¢ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡: ${formatDisplayNumber(leftoverWidthMeta)}cm` : ''}
                                      </span>
                                    )}
                                    {isLayer && layerInfo && (
                                      <span className="text-xs text-orange-600 dark:text-orange-400 mt-0.5">
                                        {layerInfo.layersFromRemainingStones > 0 || layerInfo.layersFromNewStones > 0
                                          ? `${layerInfo.layersFromRemainingStones || 0} Ø§Ø² Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ØŒ ${layerInfo.layersFromNewStones || 0} Ø§Ø² Ø³Ù†Ú¯ Ø¬Ø¯ÛŒØ¯`
                                          : ''}
                                      </span>
                                    )}
                                  </div>
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300 font-medium">
                                  {formatSquareMeters(it.squareMeters || 0)}
                                </td>
                                <td className="py-3 px-4 text-gray-700 dark:text-gray-300">
                                  {formatPrice(it.pricePerSquareMeter || 0)}
                                </td>
                                <td className="py-3 px-4">
                                  <div className="flex flex-col gap-1.5">
                                  {(((it as any).meta?.tools) || []).length === 0 ? (
                                    <span className="text-xs text-gray-400 dark:text-gray-500">-</span>
                                  ) : (
                                      ((it as any).meta?.tools || []).map((t: any, i: number) => (
                                        <div key={i} className="text-xs bg-purple-50 dark:bg-purple-900/20 px-2 py-1 rounded border border-purple-200 dark:border-purple-800">
                                          <span className="font-medium text-purple-700 dark:text-purple-300">{t.name}</span>
                                          <span className="text-gray-600 dark:text-gray-400"> â€¢ {formatDisplayNumber(t.computedMeters || 0)} m</span>
                                          <span className="text-gray-500 dark:text-gray-500"> Ã— {formatPrice(t.pricePerMeter || 0)}</span>
                                        </div>
                                      ))
                                    )}
                                    {it.finishingId && it.finishingCost ? (
                                      <div className="text-xs bg-teal-50 dark:bg-teal-900/20 px-2 py-1 rounded border border-teal-200 dark:border-teal-800">
                                        <span className="font-medium text-teal-700 dark:text-teal-300">Ù¾Ø±Ø¯Ø§Ø®Øª:</span>
                                        <span className="text-gray-600 dark:text-gray-400 mr-1">
                                          {it.finishingName || 'Ù¾Ø±Ø¯Ø§Ø®Øª'} â€¢ {formatSquareMeters(it.finishingSquareMeters || it.squareMeters || 0)}
                                        </span>
                                        <span className="text-teal-600 dark:text-teal-300 font-semibold">
                                          {formatPrice(it.finishingCost)}
                                        </span>
                                      </div>
                                    ) : null}
                                  </div>
                                </td>
                                <td className="py-3 px-4">
                                  {toolsTotal > 0 ? (
                                    <span className="font-medium text-purple-600 dark:text-purple-400">{formatPrice(toolsTotal)}</span>
                                  ) : (
                                    <span className="text-xs text-gray-400 dark:text-gray-500">-</span>
                                  )}
                                </td>
                                <td className="py-3 px-4">
                                  <span className="font-semibold text-teal-600 dark:text-teal-400">
                                    {formatPrice(
                                      typeof it.totalPrice === 'number' ? it.totalPrice : (typeof it.totalPrice === 'string' ? parseFloat(it.totalPrice) || 0 : 0)
                                    )}
                                  </span>
                                </td>
                              </tr>
                            );
                          })}
                          <tr className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border-t-2 border-teal-300 dark:border-teal-700">
                            <td className="py-3 px-4 font-bold text-teal-900 dark:text-teal-200" colSpan={7}>Ø¬Ù…Ø¹ Ú©Ù„ Ú¯Ø±ÙˆÙ‡</td>
                            <td className="py-3 px-4">
                              <span className="font-bold text-lg text-teal-700 dark:text-teal-300">
                                {formatPrice(stairSystemV2.stairSessionItems.reduce((s, it) => s + (it.totalPrice || 0), 0))}
                              </span>
                            </td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                  )}
                </div>
                </div>
              </div>
              <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex items-center justify-end gap-2 flex-shrink-0">
                <button type="button" className="px-3 py-2 rounded-md bg-gray-200 dark:bg-gray-700" onClick={() => setShowProductModal(false)}>Ø§Ù†ØµØ±Ø§Ù</button>
                <button type="button" className="px-3 py-2 rounded-md bg-purple-600 text-white" onClick={() => {
                  const [draft] = getActiveDraft();
                  // Validate required fields
                  const fieldErrors = validateDraftRequiredFields(stairSystemV2.stairActivePart, draft);
                  const hasErrors = Object.values(fieldErrors).some(Boolean);
                  if (hasErrors) {
                    stairSystemV2.setStairDraftErrors(prev => ({
                      ...prev,
                      [stairSystemV2.stairActivePart]: {
                        ...prev[stairSystemV2.stairActivePart],
                        ...fieldErrors
                      }
                    }));
                    setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø®Ø·Ø§Ù‡Ø§ÛŒ Ù…Ø´Ø®Øµâ€ŒØ´Ø¯Ù‡ Ø±Ø§ Ø¨Ø±Ø·Ø±Ù Ú©Ù†ÛŒØ¯' });
                    return;
                  }
                  stairSystemV2.setStairDraftErrors(prev => ({ ...prev, [stairSystemV2.stairActivePart]: {} }));
                  setErrors({});
                  const sid = stairSystemV2.ensureStairSessionId();
                  const totals = computeTotalsV2(stairSystemV2.stairActivePart, draft);
                  const chargeableCuttingCost = totals.billableCuttingCost;
                  const chargeableCuttingCostLongitudinal = totals.billableCuttingCostLongitudinal;
                  const chargeableCuttingCostCross = totals.billableCuttingCostCross;
                  const actualLengthM = getActualLengthMeters(draft);
                  const pricingLengthM = getPricingLengthMeters(draft);
                  const widthM = (draft.widthCm || 0) / 100;
                  const toolsMeters = computeToolsMetersV2(stairSystemV2.stairActivePart, draft);
                  let metaTools = (draft.tools || []).map(t => {
                    const meters = computeToolMetersForTool(stairSystemV2.stairActivePart, draft, t);
                    return {
                      toolId: t.toolId,
                      name: t.name,
                      pricePerMeter: t.pricePerMeter,
                      edges: { front: !!t.front, left: !!t.left, right: !!t.right, back: !!t.back, perimeter: !!t.perimeter },
                      computedMeters: meters,
                      totalPrice: meters * (t.pricePerMeter || 0)
                    };
                  });
                  const stoneProduct = draft.stoneProduct!;
                  const selectedFinishing = draft.finishingId
                    ? stoneFinishings.find(option => option.id === draft.finishingId)
                    : undefined;
                  const finishingCost = computeFinishingCost(draft, totals.pricingSquareMeters);
                  if (totals.cuttingCostLongitudinal > 0 && totals.shouldChargeCuttingCost) {
                    const cutMeters = actualLengthM * totals.baseStoneQuantity;
                    metaTools = [
                      ...metaTools,
                      {
                        toolId: `cut-longitudinal-${draft.stoneId || 'new'}`,
                        name: 'Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ',
                        pricePerMeter: totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter,
                        edges: { front: false, left: false, right: false, back: false, perimeter: true },
                        computedMeters: cutMeters,
                        totalPrice: chargeableCuttingCostLongitudinal
                      }
                    ];
                  }
                  if (totals.cuttingCostCross > 0 && totals.shouldChargeCuttingCost) {
                    const widthMeters = ((draft.widthCm || 0) / 100) * totals.baseStoneQuantity;
                    // Use "Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø±" if there's only 1 cross cut (no longitudinal cut)
                    const hasOnlyCrossCut = totals.cuttingCostLongitudinal === 0 || !totals.cuttingCostLongitudinal;
                    const cutName = hasOnlyCrossCut ? 'Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø±' : 'Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ';
                    metaTools = [
                      ...metaTools,
                      {
                        toolId: `cut-cross-${draft.stoneId || 'new'}`,
                        name: cutName,
                        pricePerMeter: totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter,
                        edges: { front: false, left: false, right: false, back: false, perimeter: true },
                        computedMeters: widthMeters,
                        totalPrice: chargeableCuttingCostCross
                      }
                    ];
                  }
                  const toolsTotal = metaTools.reduce((sum, t) => sum + (t.totalPrice || 0), 0);
                  
                  // ğŸ¯ Use original width for pricing (like long stone products)
                  const originalWidthCm = stoneProduct.widthValue || 0;
                  const userWidthCm = draft.widthCm || 0;
                  const baseStoneQuantity = totals.baseStoneQuantity;
                  
                  const defaultMandatoryForPart = stairSystemV2.stairActivePart === 'riser' || stairSystemV2.stairActivePart === 'landing';
                  const isDraftMandatory = draft.useMandatory ?? defaultMandatoryForPart;
                  const mandatoryPercentageValue = draft.mandatoryPercentage ?? 20;
                  const mandatoryAmount = isDraftMandatory && mandatoryPercentageValue > 0
                    ? totals.baseMaterialPrice * (mandatoryPercentageValue / 100)
                    : 0;
                  const basePrice = totals.baseMaterialPrice + mandatoryAmount;
                  const totalPrice = basePrice + toolsTotal + finishingCost + chargeableCuttingCost;
                  
                  const hasWidthCut = totals.cuttingCostLongitudinal > 0;
                  const hasLengthCut = totals.cuttingCostCross > 0;
                  
                  // Calculate remaining stone if product was cut
                  let remainingStones: RemainingStone[] = [];
                  let isCut = false;
                  let cutType: 'longitudinal' | 'cross' | null = null;
                  let cuttingCost = chargeableCuttingCost;
                  let cuttingCostPerMeter = totals.shouldChargeCuttingCost ? totals.cuttingCostPerMeter : 0;
                  let cutDetails: StoneCut[] = [];
                  const cuttingBreakdown: CuttingBreakdownEntry[] = [];
                  
                  if (hasWidthCut) {
                    isCut = true;
                    cutType = 'longitudinal';
                    const remainingWidth = totals.leftoverWidthCm;
                    if (remainingWidth > 0 && actualLengthM > 0 && baseStoneQuantity > 0) {
                      const remainingStoneId = `remaining_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      const remainingWidthInMeters = remainingWidth / 100;
                      const remainingStone: RemainingStone = {
                        id: remainingStoneId,
                        width: remainingWidth,
                        length: actualLengthM,
                        squareMeters: (remainingWidthInMeters * actualLengthM * baseStoneQuantity),
                        isAvailable: remainingWidth > 0,
                        sourceCutId: `cut_${draft.stoneId}_${Date.now()}`,
                        quantity: baseStoneQuantity
                      };
                      remainingStones = [remainingStone];
                    }
                    
                    const cutId = `cut_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const cutDetail: StoneCut = {
                      id: cutId,
                      originalWidth: originalWidthCm,
                      cutWidth: userWidthCm,
                      remainingWidth: totals.leftoverWidthCm,
                      length: actualLengthM * 100 * baseStoneQuantity,
                      cuttingCost: chargeableCuttingCostLongitudinal,
                      cuttingCostPerMeter: totals.shouldChargeCuttingCost
                        ? (totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter)
                        : 0,
                      orientation: 'longitudinal'
                    };
                    cutDetails = [cutDetail];
                    cuttingBreakdown.push({
                      type: 'longitudinal',
                      meters: actualLengthM * baseStoneQuantity,
                      rate: totals.shouldChargeCuttingCost
                        ? (totals.cuttingCostPerMeterLongitudinal || totals.cuttingCostPerMeter)
                        : 0,
                      cost: chargeableCuttingCostLongitudinal
                    });
                  }
                  
                  if (hasLengthCut) {
                    isCut = true;
                    if (!hasWidthCut) {
                      cutType = 'cross';
                    }
                    if (pricingLengthM > actualLengthM && baseStoneQuantity > 0) {
                      const remainingLength = pricingLengthM - actualLengthM;
                      const crossStoneId = `remaining_cross_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      const widthMeters = userWidthCm / 100;
                      const crossRemaining: RemainingStone = {
                        id: crossStoneId,
                        width: userWidthCm,
                        length: remainingLength,
                        squareMeters: widthMeters * remainingLength * baseStoneQuantity,
                        isAvailable: true,
                        sourceCutId: `cut_cross_${draft.stoneId}_${Date.now()}`,
                        quantity: baseStoneQuantity
                      };
                      remainingStones = [...remainingStones, crossRemaining];
                      
                      const crossCutId = `cut_cross_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                      cutDetails = [
                        ...cutDetails,
                        {
                          id: crossCutId,
                          originalWidth: pricingLengthM * 100,
                          cutWidth: actualLengthM * 100,
                          remainingWidth: remainingLength * 100,
                          length: userWidthCm * baseStoneQuantity,
                          cuttingCost: chargeableCuttingCostCross,
                          cuttingCostPerMeter: totals.shouldChargeCuttingCost
                            ? (totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter)
                            : 0,
                          orientation: 'cross'
                        }
                      ];
                    }
                    cuttingBreakdown.push({
                      type: 'cross',
                      meters: (userWidthCm / 100) * baseStoneQuantity,
                      rate: totals.shouldChargeCuttingCost
                        ? (totals.cuttingCostPerMeterCross || totals.cuttingCostPerMeter)
                        : 0,
                      cost: chargeableCuttingCostCross
                    });
                  }
                  
                  const storedLengthValue = convertMetersToUnit(actualLengthM, draft.lengthUnit || 'm');
                  const product: ContractProduct = {
                    productId: draft.stoneId!,
                    product: stoneProduct,
                    productType: 'stair',
                    stairSystemId: sid,
                    stairPartType: stairSystemV2.stairActivePart,
                    stoneCode: stoneProduct.code,
                    stoneName: draft.stoneLabel || stoneProduct.namePersian || stoneProduct.name || '',
                    diameterOrWidth: draft.thicknessCm || stoneProduct.thicknessValue || 0, // Ù‚Ø·Ø± = Ø¶Ø®Ø§Ù…Øª (thickness)
                    length: storedLengthValue,
                    lengthUnit: draft.lengthUnit || 'cm',
                    width: draft.widthCm!,
                    widthUnit: 'cm',
                    quantity: draft.quantity!,
                    squareMeters: totals.sqm,
                    pricePerSquareMeter: draft.pricePerSquareMeter!,
                    totalPrice: totalPrice,
                    description: '',
                    currency: 'ØªÙˆÙ…Ø§Ù†',
                    isMandatory: isDraftMandatory && mandatoryPercentageValue > 0,
                    mandatoryPercentage: isDraftMandatory && mandatoryPercentageValue > 0 ? mandatoryPercentageValue : 0,
                    originalTotalPrice: totals.baseMaterialPrice,
                    isCut: isCut,
                    cutType: cutType,
                    originalWidth: originalWidthCm,
                    originalLength: actualLengthM, // Store original length in meters for canvas visualization
                    cuttingCost: cuttingCost,
                    cuttingCostPerMeter: cuttingCostPerMeter,
                    cutDescription: isCut
                      ? hasWidthCut && hasLengthCut
                        ? `Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ (${originalWidthCm}cm â†’ ${userWidthCm}cm) Ùˆ Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ (${formatDisplayNumber(pricingLengthM)}m â†’ ${formatDisplayNumber(actualLengthM)}m)`
                        : hasWidthCut
                          ? `Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ (${originalWidthCm}cm â†’ ${userWidthCm}cm)`
                          : `Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø± (${formatDisplayNumber(pricingLengthM)}m â†’ ${formatDisplayNumber(actualLengthM)}m)`
                      : '',
                    remainingStones: remainingStones,
                    cutDetails: cutDetails,
                    usedRemainingStones: [],
                    totalUsedRemainingWidth: 0,
                    totalUsedRemainingLength: 0,
                    appliedSubServices: [],
                    totalSubServiceCost: toolsTotal,
                    usedLengthForSubServices: 0,
                    usedSquareMetersForSubServices: 0,
                    cuttingBreakdown: cuttingBreakdown.length ? cuttingBreakdown : undefined,
                    standardLengthValue: stairSystemV2.stairActivePart === 'riser' ? null : (draft.standardLengthValue ?? null),
                    standardLengthUnit: stairSystemV2.stairActivePart === 'riser'
                      ? (draft.lengthUnit || 'm')
                      : (draft.standardLengthUnit || draft.lengthUnit || 'm'),
                    actualLengthMeters: actualLengthM || null,
                    finishingId: draft.finishingEnabled ? draft.finishingId || null : null,
                    finishingName: draft.finishingEnabled ? (draft.finishingLabel || selectedFinishing?.namePersian || selectedFinishing?.name || null) : null,
                    finishingPricePerSquareMeter: draft.finishingEnabled ? (draft.finishingPricePerSquareMeter ?? selectedFinishing?.pricePerSquareMeter ?? null) : null,
                    finishingCost: draft.finishingEnabled ? finishingCost : null,
                    finishingSquareMeters: draft.finishingEnabled && finishingCost > 0 ? totals.pricingSquareMeters : null,
                    meta: {
                      stairStepperV2: true,
                      meters: { lengthM: actualLengthM, widthM, toolsMeters },
                      tools: metaTools,
                      stair: {
                        baseStoneQuantity: totals.baseStoneQuantity,
                        piecesPerStone: totals.piecesPerStone,
                        leftoverWidthCmPerStone: totals.leftoverWidthCm,
                        pricingSquareMeters: totals.pricingSquareMeters,
                        standardLength: stairSystemV2.stairActivePart !== 'riser' && draft.standardLengthValue ? {
                          value: draft.standardLengthValue,
                          unit: draft.standardLengthUnit || draft.lengthUnit || 'm',
                          meters: pricingLengthM
                        } : undefined,
                      },
                      finishing: draft.finishingEnabled && finishingCost > 0 ? {
                        id: draft.finishingId,
                        name: draft.finishingLabel || selectedFinishing?.namePersian || selectedFinishing?.name,
                        pricePerSquareMeter: draft.finishingPricePerSquareMeter ?? selectedFinishing?.pricePerSquareMeter ?? null,
                        squareMeters: totals.pricingSquareMeters,
                        cost: finishingCost
                        } : undefined
                    } as any
                  };
                  // ============================================================================
                  // ğŸ¯ REFACTORED LAYER HANDLING - Single state update for all changes
                  // ============================================================================
                  
                  // Check if layers are defined with edges selected
                  const hasLayerEdges = draft.layerEdges && (
                    draft.layerEdges.front || 
                    draft.layerEdges.left || 
                    draft.layerEdges.right || 
                    draft.layerEdges.back || 
                    draft.layerEdges.perimeter
                  );
                  
                  // Prepare all updates in a single transaction
                  stairSystemV2.setStairSessionItems(prev => {
                    // Remove previous entries for this part (and its layers) to keep session consistent during edits
                    const baseItems = prev.filter(item => {
                      const isLayerItem = ((item.meta as any)?.isLayer) || false;
                      if (isLayerItem) {
                        const parentPart = (item.meta as any)?.layerInfo?.parentPartType;
                        return parentPart !== stairSystemV2.stairActivePart;
                      }
                      return item.stairPartType !== stairSystemV2.stairActivePart;
                    });

                    // Start with adding the main stair part product
                    const updatedItems = [...baseItems, product];
                    const mainStairPartIndex = updatedItems.length - 1;
                    
                    // Process layers if configured
                    if (draft.numberOfLayersPerStair && draft.numberOfLayersPerStair > 0 && 
                        draft.layerWidthCm && hasLayerEdges && getLayerEffectivePricePerSquareMeter(draft) && 
                        draft.quantity) {
                      
                      // ğŸ¯ STEP 1: Find existing layer product (if any)
                      // Check both session items AND wizardData.products to prevent duplicates
                      const existingLayerInSession = findExistingLayerProduct(updatedItems, draft, stairSystemV2.stairActivePart);
                      const existingLayerInWizard = findExistingLayerProduct(wizardData.products, draft, stairSystemV2.stairActivePart);
                      const existingLayerProduct = existingLayerInSession || existingLayerInWizard;
                      
                      // ğŸ¯ STEP 2: Calculate layer metrics
                      const totalLayerSqm = computeLayerSqmV2(stairSystemV2.stairActivePart, draft);
                      const layerWidthCm = draft.layerWidthCm || 0;
                      const totalLayers = draft.quantity * draft.numberOfLayersPerStair;
                      const mainStairLengthM = getActualLengthMeters(draft);
                      // ğŸ¯ FIX: Use maximum layer length needed (accounts for different edge types with different lengths)
                      // This ensures we have enough stone for all layer types (front, left, right, etc.)
                      const layerLengthM = getMaxLayerLengthM(stairSystemV2.stairActivePart, draft) || mainStairLengthM;
                      const layerEdgeDemands = getLayerEdgeDemands(stairSystemV2.stairActivePart, draft);
                      const layerStoneProduct = getLayerStoneProductForDraft(draft, stoneProduct);
                      const usingAlternateLayerStone = !!(draft.layerUseDifferentStone && draft.layerStoneProduct);
                      const baseLayerPricePerSqm = getLayerBasePricePerSquareMeter(draft);
                      const effectiveLayerPricePerSqm = getLayerEffectivePricePerSquareMeter(draft);

                      // Get cutting cost per meter for layer calculations
                      const layerCuttingCostPerMeter = 
                        (layerStoneProduct as any)?.cuttingCostPerMeter ??
                        getCuttingTypePricePerMeter('LONG') ??
                        0;
                      
                      // ğŸ¯ STEP 3: Collect all available remaining stones
                      const allAvailableRemainingStones = usingAlternateLayerStone
                        ? []
                        : collectAvailableRemainingStones(updatedItems, remainingStones);
                      
                      // ğŸ¯ STEP 4: Calculate layer metrics (remaining stone usage, cutting costs, etc.)
                      const totalLayerDemand = layerEdgeDemands.length
                        ? layerEdgeDemands.reduce((sum, demand) => sum + demand.layersNeeded, 0)
                        : totalLayers;
                      const layerMetrics = usingAlternateLayerStone
                        ? {
                            layersFromRemainingStones: 0,
                            layersFromNewStones: totalLayerDemand,
                            totalLayerCuttingCost: 0,
                            layerCutDetails: [] as StoneCut[],
                            usedRemainingStonesForLayers: [] as RemainingStone[],
                            layerRemainingPieces: [] as RemainingStone[],
                            squareMetersFromRemaining: 0,
                            squareMetersFromNew: totalLayerSqm,
                            totalLayerDemand,
                            unfulfilledDemands: layerEdgeDemands.length
                              ? layerEdgeDemands.map(demand => ({
                                  edge: demand.edge,
                                  lengthM: demand.lengthM,
                                  quantity: demand.layersNeeded
                                }))
                              : [{
                                  edge: 'front',
                                  lengthM: layerLengthM,
                                  quantity: totalLayerDemand
                                }]
                          }
                        : calculateLayerMetrics({
                            totalLayers: totalLayerDemand,
                            layerWidthCm,
                            layerLengthM,
                            availableRemainingStones: allAvailableRemainingStones,
                            cuttingCostPerMeter: layerCuttingCostPerMeter,
                            edgeDemands: layerEdgeDemands
                          });
                      
                      // ğŸ¯ STEP 5: Calculate pricing
                      const layerSqmPerStair = totalLayerSqm / (draft.quantity * draft.numberOfLayersPerStair);
                      const layerTypeUnitPrice = draft.layerTypePrice || 0;
                      
                      // ğŸ¯ FIX: Calculate layer type cost based on total length per stair Ã— number of stairs Ã— layer type price per meter
                      // Ù…Ø¬Ù…ÙˆØ¹ Ø·ÙˆÙ„Ù‡ Ù‡Ø§ÛŒ Ù„Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ù¾Ù„Ù‡ (Ú†Ù¾ + Ø±Ø§Ø³Øª + Ø¬Ù„Ùˆ) Ã— ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡ Ù‡Ø§ Ã— Ù‡Ø²ÛŒÙ†Ù‡ Ù‡Ø± Ù†ÙˆØ¹ Ù„Ø§ÛŒÙ‡
                      const totalLayerLengthPerStairM = getTotalLayerLengthPerStairM(stairSystemV2.stairActivePart, draft);
                      const totalLayerLengthM = totalLayerLengthPerStairM * draft.quantity;
                      const layerTypeCost = totalLayerLengthM * layerTypeUnitPrice;
                      
                      const layerSqmFromNew = (() => {
                        if (layerMetrics.squareMetersFromNew !== undefined) {
                          return layerMetrics.squareMetersFromNew;
                        }
                        const totalDemand = layerMetrics.totalLayerDemand || totalLayerDemand || 0;
                        if (totalDemand <= 0) {
                          return 0;
                        }
                        return layerSqmPerStair * (layerMetrics.layersFromNewStones / totalDemand);
                      })();
                      
                      const calculateStoneAreaUsed = (): number => {
                        const stoneWidthCm = layerStoneProduct?.widthValue || originalWidthCm;
                        const stoneLengthM = mainStairLengthM;
                        if (stoneWidthCm <= 0 || layerWidthCm <= 0 || stoneLengthM <= 0) {
                          return usingAlternateLayerStone ? totalLayerSqm : layerSqmFromNew;
                        }
                        
                        const stoneWidthM = stoneWidthCm / 100;
                        const columnsPerStone = Math.max(1, Math.floor(stoneWidthCm / layerWidthCm));
                        const baseLength = Math.max(layerLengthM, stoneLengthM);
                        
                        const unfulfilledDemands = (layerMetrics.unfulfilledDemands && layerMetrics.unfulfilledDemands.length)
                          ? layerMetrics.unfulfilledDemands
                          : [{
                              edge: 'front' as LayerEdgeDemand['edge'],
                              lengthM: layerLengthM > 0 ? layerLengthM : stoneLengthM,
                              quantity: layerMetrics.layersFromNewStones
                            }];
                        
                        let totalStonesNeeded = 0;
                        unfulfilledDemands.forEach(demand => {
                          if (!demand.lengthM || demand.lengthM <= 0 || !demand.quantity) {
                            return;
                          }
                          
                          const stripsPerColumn = Math.max(1, Math.floor(stoneLengthM / demand.lengthM));
                          const stripsPerStone = Math.max(1, stripsPerColumn * columnsPerStone);
                          totalStonesNeeded += Math.ceil(demand.quantity / stripsPerStone);
                        });
                        
                        if (totalStonesNeeded === 0) {
                          return usingAlternateLayerStone ? totalLayerSqm : layerSqmFromNew;
                        }
                        
                        return totalStonesNeeded * stoneLengthM * stoneWidthM;
                      };
                      
                      const stoneAreaUsedSqm = usingAlternateLayerStone
                        ? totalLayerSqm
                        : calculateStoneAreaUsed();
                      
                      const pricingStoneAreaSqm = stoneAreaUsedSqm > 0 ? stoneAreaUsedSqm : layerSqmFromNew;
                      
                      const shouldChargeLayerCutting =
                        !(usingAlternateLayerStone && (draft.layerUseMandatory ?? true) && (draft.layerMandatoryPercentage ?? 0) > 0);
                      const chargeableLayerCuttingCost = shouldChargeLayerCutting ? layerMetrics.totalLayerCuttingCost : 0;
                      // ğŸ¯ FIX: Layer material price should be based on stone area used, NOT layer square meters
                      // ğŸ¯ NOTE: effectiveLayerPricePerSqm already includes mandatory pricing if applicable
                      // Example: stoneAreaUsedSqm (0.976 mÂ²) Ã— pricePerSqm (700,000) = 683,200 ØªÙˆÙ…Ø§Ù†
                      const layerMaterialPrice = pricingStoneAreaSqm * effectiveLayerPricePerSqm;
                      // ğŸ¯ FIX: Ensure layerTotalPrice is always a number (not string) and properly rounded
                      const layerTotalPrice = Number((layerMaterialPrice + layerTypeCost + chargeableLayerCuttingCost).toFixed(2));
                      
                      // ğŸ¯ STEP 6: Handle existing layer product merge OR create new layer product
                      if (existingLayerProduct) {
                        // Check if existing layer is in session or in wizardData
                        const existingLayerIndex = updatedItems.findIndex(item => item === existingLayerProduct);
                        
                        if (existingLayerIndex >= 0) {
                          // Merge existing layer product in session
                          const mergedLayerProduct = mergeLayerProduct(existingLayerProduct, {
                            draft,
                            parentPartType: stairSystemV2.stairActivePart,
                            newLayersNeeded: totalLayers,
                            newLayerSqm: totalLayerSqm,
                            layerMaterialPrice,
                            layerTypeCost,
                            totalLayerCuttingCost: chargeableLayerCuttingCost,
                            layerCutDetails: layerMetrics.layerCutDetails,
                            usedRemainingStonesForLayers: layerMetrics.usedRemainingStonesForLayers,
                            layersFromRemainingStones: layerMetrics.layersFromRemainingStones,
                            layersFromNewStones: layerMetrics.layersFromNewStones,
                            layerPricePerSquareMeter: effectiveLayerPricePerSqm,
                            layerStoneLabel: usingAlternateLayerStone
                              ? (draft.layerStoneLabel || layerStoneProduct?.namePersian || layerStoneProduct?.name || '')
                              : null,
                            layerUseDifferentStone: usingAlternateLayerStone,
                            layerStoneProductId: usingAlternateLayerStone
                              ? (draft.layerStoneProductId || layerStoneProduct?.id || null)
                              : null,
                            layerStoneBasePricePerSquareMeter: baseLayerPricePerSqm,
                            layerUseMandatory: draft.layerUseDifferentStone ? (draft.layerUseMandatory ?? true) : undefined,
                            layerMandatoryPercentage: draft.layerUseDifferentStone ? (draft.layerMandatoryPercentage ?? 0) : undefined,
                            stoneAreaUsedSqm: stoneAreaUsedSqm
                          });
                          updatedItems[existingLayerIndex] = mergedLayerProduct;
                        } else if (existingLayerInWizard) {
                          // Existing layer is in wizardData.products - skip creating new one in session
                          // It will be merged when adding to wizardData (handled in the "Add to Contract" button handler)
                          console.log('â„¹ï¸ Existing layer product found in wizardData.products, will be merged when adding to contract');
                          // Don't create a new layer product in session - prevents duplicates
                        }
                      } else {
                        // Create new layer product
                        const newLayerProduct = createLayerProduct({
                          draft,
                          stoneProduct: layerStoneProduct || stoneProduct,
                          stairSystemId: sid,
                          parentPartType: stairSystemV2.stairActivePart,
                          totalLayers,
                          totalLayerSqm,
                          layerMaterialPrice,
                          layerTotalPrice,
                          layerTypeCost,
                          layersFromRemainingStones: layerMetrics.layersFromRemainingStones,
                          layersFromNewStones: layerMetrics.layersFromNewStones,
                          totalLayerCuttingCost: chargeableLayerCuttingCost,
                          layerCutDetails: layerMetrics.layerCutDetails,
                          layerRemainingPieces: layerMetrics.layerRemainingPieces,
                          usedRemainingStonesForLayers: layerMetrics.usedRemainingStonesForLayers,
                          originalWidthCm: layerStoneProduct?.widthValue || originalWidthCm,
                          lengthM: mainStairLengthM,
                          layerCuttingCostPerMeter,
                          parentProductIndexInSession: mainStairPartIndex,
                          layerPricePerSquareMeter: effectiveLayerPricePerSqm,
                          layerStoneLabel: draft.layerUseDifferentStone
                            ? (draft.layerStoneLabel || layerStoneProduct?.namePersian || layerStoneProduct?.name || '')
                            : null,
                          layerUseDifferentStone: usingAlternateLayerStone,
                          layerStoneProductId: draft.layerUseDifferentStone
                            ? (draft.layerStoneProductId || layerStoneProduct?.id || null)
                            : null,
                          layerStoneBasePricePerSquareMeter: baseLayerPricePerSqm,
                          layerUseMandatory: draft.layerUseDifferentStone ? (draft.layerUseMandatory ?? true) : undefined,
                          layerMandatoryPercentage: draft.layerUseDifferentStone ? (draft.layerMandatoryPercentage ?? 0) : undefined,
                          stoneAreaUsedSqm: stoneAreaUsedSqm
                        });
                        updatedItems.push(newLayerProduct);
                      }
                      
                      // ğŸ¯ STEP 7: Update remaining stone usage tracking
                      if (layerMetrics.usedRemainingStonesForLayers.length > 0) {
                        const remainingStoneUpdates = updateRemainingStoneUsage(
                          updatedItems,
                          layerMetrics.usedRemainingStonesForLayers,
                          mainStairPartIndex
                        );
                        
                        // Apply all remaining stone usage updates
                        remainingStoneUpdates.forEach((updatedProduct, idx) => {
                          if (idx >= 0 && idx < updatedItems.length) {
                            updatedItems[idx] = updatedProduct;
                          }
                        });
                      }
                    }
                    
                    return updatedItems;
                  });
                  
                  // Reset fields for quick next entry (keep unit toggle)
                  const [, setDraft] = getActiveDraft();
                  const defaultMandatoryAfterReset = stairSystemV2.stairActivePart === 'riser' || stairSystemV2.stairActivePart === 'landing';
                  setDraft({
                    stoneId: null,
                    stoneLabel: '',
                    stoneProduct: null,
                    pricePerSquareMeter: null,
                    useMandatory: defaultMandatoryAfterReset,
                    mandatoryPercentage: defaultMandatoryAfterReset ? 20 : null,
                    thicknessCm: null,
                    lengthValue: null,
                    lengthUnit: draft.lengthUnit || 'm', // Default to meters for length
                    widthCm: null,
                    quantity: null,
                    squareMeters: null,
                    tools: [],
                    totalPrice: null,
                    // Reset layer fields
                    numberOfLayersPerStair: null,
                    layerWidthCm: null,
                    layerTypeId: null,
                    layerTypeName: null,
                    layerTypePrice: null,
                    layerEdges: undefined,
                    layerUseDifferentStone: false,
                    layerStoneProductId: null,
                    layerStoneProduct: null,
                    layerStoneLabel: null,
                    layerPricePerSquareMeter: null,
                    layerUseMandatory: undefined,
                    layerMandatoryPercentage: null,
                    standardLengthValue: null,
                    standardLengthUnit: draft.lengthUnit || 'm',
                    finishingEnabled: false,
                    finishingId: null,
                    finishingLabel: null,
                    finishingPricePerSquareMeter: null
                  });
                  stairSystemV2.setStoneSearchTerm('');
                  stairSystemV2.setToolsSearchTerm('');
                  stairSystemV2.setToolsDropdownOpen(false);
                  setErrors({});
                }}>Ø§ÙØ²ÙˆØ¯Ù† Ø§ÛŒÙ† Ø¨Ø®Ø´</button>
                <button type="button" className="px-3 py-2 rounded-md bg-green-600 text-white" onClick={() => {
                  if (!stairSystemV2.stairSessionItems.length) { setShowProductModal(false); return; }
                  
                  // Handle edit mode: replace existing products instead of adding new ones
                  if (isEditMode && editingProductIndex !== null) {
                    // Find the old stairSystemId from the product being edited
                    const oldProduct = wizardData.products[editingProductIndex];
                    const oldStairSystemId = oldProduct?.stairSystemId;
                    
                    if (oldStairSystemId) {
                      // Remove all old products with the same stairSystemId
                      const updatedProducts = wizardData.products.filter(p => 
                        !(p.productType === 'stair' && p.stairSystemId === oldStairSystemId)
                      );
                      
                      // Preserve the stairSystemId for the updated products and recalculate parentProductIndex for layers
                      const currentProductsCount = updatedProducts.length;
                      
                      // Create a map of session items to their final indices
                      const sessionToFinalIndexMap = new Map<ContractProduct, number>();
                      let nonLayerCount = 0;
                      stairSystemV2.stairSessionItems.forEach((item) => {
                        const isLayer = ((item.meta as any)?.isLayer) || false;
                        if (!isLayer) {
                          sessionToFinalIndexMap.set(item, currentProductsCount + nonLayerCount);
                          nonLayerCount++;
                        }
                      });
                      
                      const productsToAdd = stairSystemV2.stairSessionItems.map((item, sessionIndex) => {
                        const isLayer = ((item.meta as any)?.isLayer) || false;
                        if (isLayer) {
                          const layerInfo = (item.meta as any)?.layerInfo;
                          const parentIndexInSession = layerInfo?.parentProductIndexInSession;
                          
                          if (parentIndexInSession !== undefined && parentIndexInSession >= 0) {
                            const parentInSession = stairSystemV2.stairSessionItems[parentIndexInSession];
                            if (parentInSession) {
                              const parentFinalIndex = sessionToFinalIndexMap.get(parentInSession);
                              if (parentFinalIndex !== undefined && parentFinalIndex >= 0) {
                                return {
                                  ...item,
                                  stairSystemId: oldStairSystemId,
                                  parentProductIndex: parentFinalIndex
                                };
                              }
                            }
                          }
                        }
                        return {
                          ...item,
                          stairSystemId: oldStairSystemId
                        };
                      });
                      
                      // Add updated products
                      updateWizardData({ products: [...updatedProducts, ...productsToAdd] });
                    } else {
                      // Fallback: just replace the single product
                      const updatedProducts = [...wizardData.products];
                      updatedProducts[editingProductIndex] = stairSystemV2.stairSessionItems[0];
                      updateWizardData({ products: updatedProducts });
                    }
                  } else {
                    // Add mode: append session items to wizardData
                    // ğŸ¯ Set parentProductIndex for layer products to link them to their parent stair part
                    const currentProductsCount = wizardData.products.length;
                    
                    // First, check for existing layer products in wizardData that should be merged
                    // Filter out layer products from session that already exist in wizardData
                    const sessionItemsToAdd: ContractProduct[] = [];
                    const layerProductsToMerge: Array<{ existing: ContractProduct; new: ContractProduct }> = [];
                    
                    stairSystemV2.stairSessionItems.forEach((item) => {
                      const isLayer = ((item.meta as any)?.isLayer) || false;
                      if (isLayer) {
                        // Check if this layer already exists in wizardData
                        const existingLayer = findExistingLayerProduct(wizardData.products, {
                          layerEdges: (item.meta as any)?.layerEdges,
                          layerWidthCm: item.width,
                          lengthValue: item.length,
                          lengthUnit: item.lengthUnit || 'm',
                          numberOfLayersPerStair: ((item.meta as any)?.layerInfo)?.numberOfLayersPerStair,
                          layerUseDifferentStone: item.layerUseDifferentStone,
                          layerStoneProductId: item.layerUseDifferentStone
                            ? (item.layerStoneProductId || item.productId)
                            : null
                        } as StairPartDraftV2, ((item.meta as any)?.layerInfo)?.parentPartType || 'tread');
                        
                        if (existingLayer) {
                          // Layer exists in wizardData - mark for merge instead of adding new
                          layerProductsToMerge.push({ existing: existingLayer, new: item });
                        } else {
                          // New layer - add to session items
                          sessionItemsToAdd.push(item);
                        }
                      } else {
                        // Non-layer item - always add
                        sessionItemsToAdd.push(item);
                      }
                    });
                    
                    // Create a map of session items to their final indices in wizardData.products
                    const sessionToFinalIndexMap = new Map<ContractProduct, number>();
                    let nonLayerCount = 0;
                    sessionItemsToAdd.forEach((item) => {
                      const isLayer = ((item.meta as any)?.isLayer) || false;
                      if (!isLayer) {
                        // Non-layer items are added in order
                        sessionToFinalIndexMap.set(item, currentProductsCount + nonLayerCount);
                        nonLayerCount++;
                      }
                    });
                    
                    // Now map all items and set parentProductIndex for layers
                    const productsToAdd = sessionItemsToAdd.map((item) => {
                      const isLayer = ((item.meta as any)?.isLayer) || false;
                      if (isLayer) {
                        const layerInfo = (item.meta as any)?.layerInfo;
                        const parentIndexInSession = layerInfo?.parentProductIndexInSession;
                        
                        if (parentIndexInSession !== undefined && parentIndexInSession >= 0) {
                          // Find the parent product in original session items (not filtered)
                          const parentInSession = stairSystemV2.stairSessionItems[parentIndexInSession];
                          
                          if (parentInSession) {
                            // Get the parent's final index from our map
                            const parentFinalIndex = sessionToFinalIndexMap.get(parentInSession);
                            
                            if (parentFinalIndex !== undefined && parentFinalIndex >= 0) {
                              return {
                                ...item,
                                parentProductIndex: parentFinalIndex
                              };
                            } else {
                              // Fallback: calculate based on session index (shouldn't happen, but handle gracefully)
                              console.warn('âš ï¸ Could not find parent final index for layer product, using fallback calculation');
                              // Find parent's index in original session
                              const parentSessionIndex = stairSystemV2.stairSessionItems.findIndex(p => p === parentInSession);
                              if (parentSessionIndex >= 0) {
                                // Count non-layer items before parent in session
                                let nonLayerBeforeParent = 0;
                                for (let i = 0; i < parentSessionIndex; i++) {
                                  if (!((stairSystemV2.stairSessionItems[i].meta as any)?.isLayer)) {
                                    nonLayerBeforeParent++;
                                  }
                                }
                                return {
                                  ...item,
                                  parentProductIndex: currentProductsCount + nonLayerBeforeParent
                                };
                              }
                            }
                          }
                        }
                      }
                      return item;
                    });
                    
                    // Merge existing layer products in wizardData
                    const updatedProducts = [...wizardData.products];
                    layerProductsToMerge.forEach(({ existing, new: newLayer }) => {
                      const existingIndex = updatedProducts.findIndex(p => p === existing);
                      if (existingIndex >= 0) {
                        const layerInfo = (newLayer.meta as any)?.layerInfo;
                        const existingLayerInfo = (existing.meta as any)?.layerInfo;
                        
                        // Merge the layer product
                        const metaLayerType = (newLayer.meta as any)?.layerType;
                        const mergedLayer = mergeLayerProduct(existing, {
                          draft: {
                            layerEdges: (newLayer.meta as any)?.layerEdges,
                            numberOfLayersPerStair: layerInfo?.numberOfLayersPerStair,
                            quantity: layerInfo?.parentQuantity || 0,
                            layerTypeId: newLayer.layerTypeId ?? metaLayerType?.id ?? null,
                            layerTypeName: newLayer.layerTypeName ?? metaLayerType?.name ?? null,
                            layerTypePrice: newLayer.layerTypePrice ?? metaLayerType?.pricePerLayer ?? null,
                            layerUseDifferentStone: newLayer.layerUseDifferentStone,
                            layerStoneProductId: newLayer.layerStoneProductId || newLayer.productId,
                            layerStoneProduct: newLayer.layerUseDifferentStone ? newLayer.product : null,
                            layerStoneLabel: newLayer.layerStoneName || newLayer.stoneName,
                            layerPricePerSquareMeter: newLayer.layerStonePricePerSquareMeter || newLayer.pricePerSquareMeter
                          } as StairPartDraftV2,
                          parentPartType: layerInfo?.parentPartType || 'tread',
                          newLayersNeeded: newLayer.quantity || 0,
                          newLayerSqm: newLayer.squareMeters || 0,
                          layerMaterialPrice: newLayer.originalTotalPrice || 0,
                          layerTypeCost: metaLayerType?.totalCost ?? ((newLayer.layerTypePrice || 0) * (newLayer.quantity || 0)),
                          totalLayerCuttingCost: newLayer.cuttingCost || 0,
                          layerCutDetails: newLayer.cutDetails || [],
                          usedRemainingStonesForLayers: newLayer.usedRemainingStones || [],
                          layersFromRemainingStones: layerInfo?.layersFromRemainingStones || 0,
                          layersFromNewStones: layerInfo?.layersFromNewStones || 0,
                          layerPricePerSquareMeter: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStonePricePerSquareMeter || newLayer.pricePerSquareMeter || 0)
                            : (newLayer.pricePerSquareMeter || 0),
                          layerStoneLabel: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStoneName || newLayer.stoneName)
                            : null,
                          layerUseDifferentStone: newLayer.layerUseDifferentStone,
                          layerStoneProductId: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStoneProductId || newLayer.productId)
                            : null,
                          layerStoneBasePricePerSquareMeter: newLayer.layerUseDifferentStone
                            ? (newLayer.layerStoneBasePricePerSquareMeter || newLayer.layerStonePricePerSquareMeter || newLayer.pricePerSquareMeter || 0)
                            : null,
                          layerUseMandatory: newLayer.layerUseDifferentStone ? (newLayer.layerUseMandatory ?? true) : undefined,
                          layerMandatoryPercentage: newLayer.layerUseDifferentStone ? (newLayer.layerMandatoryPercentage ?? 0) : undefined,
                          stoneAreaUsedSqm: (newLayer.meta as any)?.stoneAreaUsedSqm
                        });
                        updatedProducts[existingIndex] = mergedLayer;
                      }
                    });
                    
                    updateWizardData({ products: [...updatedProducts, ...productsToAdd] });
                  }
                  
                  stairSystemV2.setStairSessionItems([]);
                  stairSystemV2.setStairSessionId(null);
                  setIsEditMode(false);
                  setEditingProductIndex(null);
                  setShowProductModal(false);
                }}>Ø§ØªÙ…Ø§Ù… Ùˆ Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯</button>
              </div>
            </div>
          </div>
        )}
        {showProductModal && (productConfig.productType !== 'stair' || !useStairFlowV2) && (selectedProduct || (productConfig.productType === 'stair' && stairSystemConfig)) && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999] p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto z-[10000]">
              <div className="p-6">
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-white">
                    {isEditMode ? 'ÙˆÛŒØ±Ø§ÛŒØ´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­ØµÙˆÙ„' : 'ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­ØµÙˆÙ„'}
                  </h3>
                  <button
                    onClick={() => {
                      // Validate before closing if it's a stair system
                      if (productConfig.productType === 'stair' && stairSystemConfig) {
                        const hasSelectedPart = stairSystemConfig.tread.isSelected || 
                                                stairSystemConfig.riser.isSelected || 
                                                stairSystemConfig.landing.isSelected;
                        
                        if (!hasSelectedPart) {
                          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ©ÛŒ Ø§Ø² Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ù¾Ù„Ù‡ (Ú©Ù Ù¾Ù„Ù‡ØŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ØŒ ÛŒØ§ Ù¾Ø§Ú¯Ø±Ø¯) Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
                          return;
                        }
                      }
                      
                      setShowProductModal(false);
                      setSelectedProduct(null);
                      setProductConfig({});
                      setLengthUnit('m');
                      setWidthUnit('cm');
                      setIsMandatory(false);
                      setMandatoryPercentage(20);
                      setIsEditMode(false);
                      setEditingProductIndex(null);
                      setTouchedFields(new Set()); // Reset touched fields
                      setStairSystemConfig(null);
                      setErrors({});
                    }}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                  >
                    <FaTimes className="w-6 h-6" />
                  </button>
                </div>

                {/* Error Display */}
                {errors.products && (
                  <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
                    <p className="text-red-600 dark:text-red-400 text-sm">{errors.products}</p>
                  </div>
                )}

                {/* Product Info - Show for longitudinal and slab products */}
                {selectedProduct && (productConfig.productType === 'longitudinal' || productConfig.productType === 'slab') && (
                  <div className={`mb-6 p-4 rounded-lg ${
                    productConfig.productType === 'slab' 
                      ? 'bg-gradient-to-r from-indigo-50 to-purple-50 dark:from-indigo-900/20 dark:to-purple-900/20 border border-indigo-200 dark:border-indigo-800' 
                      : 'bg-gray-50 dark:bg-gray-700'
                  }`}>
                    <div className="flex items-center justify-between mb-2">
                      <div className="flex items-center gap-2">
                        <h4 className="font-medium text-gray-800 dark:text-white">
                          {selectedProduct.namePersian}
                        </h4>
                        {productConfig.productType === 'slab' && (
                          <span className="px-2 py-1 bg-indigo-500 text-white text-xs rounded-full font-medium">
                            Ø³Ù†Ú¯ Ø§Ø³Ù„Ø¨
                          </span>
                        )}
                        {productConfig.productType === 'longitudinal' && (
                          <span className="px-2 py-1 bg-teal-500 text-white text-xs rounded-full font-medium">
                            Ø³Ù†Ú¯ Ø·ÙˆÙ„ÛŒ
                          </span>
                        )}
                      </div>
                      {isEditMode && (
                        <span className="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 text-xs rounded-full">
                          Ø­Ø§Ù„Øª ÙˆÛŒØ±Ø§ÛŒØ´
                        </span>
                      )}
                    </div>
                    <p className="text-sm text-gray-600 dark:text-gray-300">
                      {selectedProduct.stoneTypeNamePersian} â€¢ Ø¹Ø±Ø¶ {selectedProduct.widthValue}Ã—Ø¶Ø®Ø§Ù…Øª {selectedProduct.thicknessValue}cm
                      {productConfig.productType === 'slab' && (
                        <span className="ml-2 text-indigo-600 dark:text-indigo-400">â€¢ Ø¨Ø±Ø´ Ø¯Ùˆ Ø¨Ø¹Ø¯ÛŒ (Ø·ÙˆÙ„ Ùˆ Ø¹Ø±Ø¶)</span>
                      )}
                    </p>
                  </div>
                )}
                
                {/* Stair System Info - Show when editing stair system */}
                {productConfig.productType === 'stair' && stairSystemConfig && (
                  <div className="mb-6 p-4 bg-purple-50 dark:bg-purple-900/20 rounded-lg border border-purple-200 dark:border-purple-800">
                    <div className="flex items-center justify-between mb-2">
                      <h4 className="font-medium text-purple-800 dark:text-purple-200">
                        ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡
                      </h4>
                      {isEditMode && (
                        <span className="px-2 py-1 bg-blue-100 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 text-xs rounded-full">
                          Ø­Ø§Ù„Øª ÙˆÛŒØ±Ø§ÛŒØ´
                        </span>
                      )}
                    </div>
                    <p className="text-sm text-purple-600 dark:text-purple-300">
                      {stairSystemConfig.numberOfSteps} Ù¾Ù„Ù‡ ({stairSystemConfig.quantityType === 'steps' ? 'ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡' : 'ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù†'})
                    </p>
                  </div>
                )}

                {/* Configuration Form */}
                <div className="space-y-4">
                  {/* Conditional rendering based on product type */}
                  {productConfig.productType === 'stair' ? (
                    /* STAIR SYSTEM (Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡) CONFIGURATION FORM - 3 Sections */
                    <>
                      {/* Common Configuration */}
                      <div className="space-y-4">
                        {/* Quantity Type Switcher */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg p-4 bg-gray-50 dark:bg-gray-700/50">
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
                            Ù†ÙˆØ¹ ØªØ¹Ø¯Ø§Ø¯:
                          </label>
                          <div className="flex gap-2">
                            <button
                              type="button"
                              onClick={() => {
                                setQuantityType('steps');
                                updateStairSystemConfig(prev => prev ? { ...prev, quantityType: 'steps' } : null);
                              }}
                              className={`flex-1 px-4 py-3 rounded-lg transition-all font-medium ${
                                stairSystemConfig?.quantityType === 'steps'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡
                            </button>
                            <button
                              type="button"
                              onClick={() => {
                                setQuantityType('staircases');
                                updateStairSystemConfig(prev => prev ? { ...prev, quantityType: 'staircases' } : null);
                              }}
                              className={`flex-1 px-4 py-3 rounded-lg transition-all font-medium ${
                                stairSystemConfig?.quantityType === 'staircases'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù† Ú©Ø§Ù…Ù„
                            </button>
                          </div>
                        </div>

                        {/* Number of Steps (Common) */}
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            {stairSystemConfig?.quantityType === 'steps' ? 'ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡' : 'ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡ Ø¯Ø± Ù‡Ø± Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù†'}
                          </label>
                          <FormattedNumberInput
                            value={stairSystemConfig?.numberOfSteps || 0}
                            onChange={(value) => {
                              updateStairSystemConfig(prev => {
                                if (!prev) return null;
                                const newNumberOfSteps = value || 0;
                                // Update default quantities for tread and riser if they haven't been manually changed
                                return {
                                  ...prev,
                                  numberOfSteps: newNumberOfSteps,
                                  tread: {
                                    ...prev.tread,
                                    quantity: prev.tread.quantity === 0 || prev.tread.quantity === prev.numberOfSteps 
                                      ? newNumberOfSteps 
                                      : prev.tread.quantity
                                  },
                                  riser: {
                                    ...prev.riser,
                                    quantity: prev.riser.quantity === 0 || prev.riser.quantity === prev.numberOfSteps 
                                      ? newNumberOfSteps 
                                      : prev.riser.quantity
                                  }
                                };
                              });
                            }}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                            min={0}
                            step={1}
                            placeholder="ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡"
                          />
                        </div>

                        {/* Number of Staircases (if quantityType === 'staircases') */}
                        {stairSystemConfig?.quantityType === 'staircases' && (
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                              ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù† Ú©Ø§Ù…Ù„
                            </label>
                            <FormattedNumberInput
                              value={stairSystemConfig?.numberOfStaircases || 1}
                              onChange={(value) => {
                                updateStairSystemConfig(prev => prev ? { ...prev, numberOfStaircases: value || 1 } : null);
                              }}
                              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                              min={1}
                              step={1}
                              placeholder="1"
                            />
                          </div>
                        )}
                      </div>
                      {/* Three Collapsible Sections for Stair Parts */}
                      <div className="space-y-4">
                        {/* Section 1: Ú©Ù Ù¾Ù„Ù‡ (Tread) */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden">
                          <button
                            type="button"
                            onClick={() => setTreadExpanded(!treadExpanded)}
                            className="w-full flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                          >
                            <div className="flex items-center gap-3">
                              <input
                                type="checkbox"
                                checked={stairSystemConfig?.tread.isSelected || false}
                                onChange={(e) => {
                                  updateStairPart('tread', { isSelected: e.target.checked });
                                }}
                                onClick={(e) => e.stopPropagation()}
                                className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                              />
                              <span className="font-semibold text-gray-800 dark:text-white">Ú©Ù Ù¾Ù„Ù‡ (Tread)</span>
                            </div>
                            {treadExpanded ? (
                              <FaChevronUp className="text-gray-500 dark:text-gray-400" />
                            ) : (
                              <FaChevronDown className="text-gray-500 dark:text-gray-400" />
                            )}
                          </button>
                          
                          {treadExpanded && stairSystemConfig && (
                            <div className="p-4 space-y-4 border-t border-gray-200 dark:border-gray-600">
                              {/* Product Selection for Tread */}
                              <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  Ø§Ù†ØªØ®Ø§Ø¨ Ù…Ø­ØµÙˆÙ„:
                                </label>
                                {stairSystemConfig.tread.product ? (
                                  <div className="p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg mb-2">
                                    <div className="flex items-center justify-between">
                                      <div>
                                        <p className="font-medium text-gray-800 dark:text-white">
                                          {generateFullProductName(stairSystemConfig.tread.product)}
                                        </p>
                                        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                          {stairSystemConfig.tread.product.stoneTypeNamePersian} â€¢ Ø¹Ø±Ø¶ {stairSystemConfig.tread.product.widthValue}Ã—Ø¶Ø®Ø§Ù…Øª {stairSystemConfig.tread.product.thicknessValue}cm
                                        </p>
                                      </div>
                                      <button
                                        type="button"
                                        onClick={() => {
                                          updateStairPart('tread', {
                                            productId: null,
                                            product: null,
                                            pricePerSquareMeter: 0
                                          });
                                          syncDraftWithProduct('tread', null);
                                          if (stairSystemV2.stairActivePart === 'tread') {
                                            stairSystemV2.setStoneSearchTerm('');
                                          }
                                          setTreadProductSearchTerm('');
                                        }}
                                        className="text-sm text-teal-600 dark:text-teal-400 hover:text-teal-700 dark:hover:text-teØ§Ù„-300"
                                      >
                                        ØªØºÛŒÛŒØ±
                                      </button>
                                    </div>
                                  </div>
                                ) : (
                                  <div className="mb-2">
                                    <div className="relative">
                                      <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                        <FaSearch className="h-5 w-5 text-gray-400" />
                                      </div>
                                      <input
                                        type="text"
                                        placeholder="Ø¬Ø³ØªØ¬Ùˆ Ù…Ø­ØµÙˆÙ„..."
                                        value={treadProductSearchTerm}
                                        onChange={(e) => setTreadProductSearchTerm(e.target.value)}
                                        className="w-full pr-10 pl-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      />
                                    </div>
                                    {treadProductSearchTerm && (
                                      <div className="mt-2 max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800">
                                        {filteredTreadProducts.map((product) => (
                                          <div
                                            key={product.id}
                                            onClick={() => {
                                              selectProductForStairPart('tread', product);
                                              setTreadProductSearchTerm('');
                                            }}
                                            className="p-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0"
                                          >
                                            <p className="font-medium text-gray-800 dark:text-white text-sm">
                                              {generateFullProductName(product)}
                                            </p>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                              {product.basePrice ? formatPrice(product.basePrice, product.currency) : 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡'}
                                            </p>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>

                              {/* Tread Dimensions */}
                              {stairSystemConfig.tread.product && (
                                <>
                                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    {/* Tread Width */}
                                    <div>
                                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Ø·ÙˆÙ„ Ù¾Ù„Ù‡ (Ø¹Ø±Ø¶ Ù¾Ù„Ù‡â€ŒÚ©Ø§Ù†)
                                      </label>
                                      <div className="space-y-2">
                                        <FormattedNumberInput
                                          value={stairSystemConfig.tread.treadWidth || 0}
                                          onChange={(value) => {
                                            updateStairPart('tread', { treadWidth: value || 0 });
                                          }}
                                          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                          min={0}
                                          step={0.1}
                                          placeholder="Ø·ÙˆÙ„ Ù¾Ù„Ù‡"
                                        />
                                        <div className="flex gap-1">
                                          <button
                                            type="button"
                                            onClick={() => {
                                              updateStairPart('tread', { lengthUnit: 'cm' });
                                              if (stairSystemConfig.tread.treadWidth) {
                                                const converted = stairSystemConfig.tread.lengthUnit === 'm' ? stairSystemConfig.tread.treadWidth * 100 : stairSystemConfig.tread.treadWidth;
                                                updateStairPart('tread', { treadWidth: converted });
                                              }
                                            }}
                                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                              stairSystemConfig.tread.lengthUnit === 'cm'
                                                ? 'bg-teal-500 text-white shadow-lg'
                                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                                            }`}
                                          >
                                            Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                                          </button>
                                          <button
                                            type="button"
                                            onClick={() => {
                                              updateStairPart('tread', { lengthUnit: 'm' });
                                              if (stairSystemConfig.tread.treadWidth) {
                                                const converted = stairSystemConfig.tread.lengthUnit === 'cm' ? stairSystemConfig.tread.treadWidth / 100 : stairSystemConfig.tread.treadWidth;
                                                updateStairPart('tread', { treadWidth: converted });
                                              }
                                            }}
                                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                              stairSystemConfig.tread.lengthUnit === 'm'
                                                ? 'bg-teal-500 text-white shadow-lg'
                                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                                            }`}
                                          >
                                            Ù…ØªØ± (m)
                                          </button>
                                        </div>
                                      </div>
                                    </div>

                                    {/* Tread Depth */}
                                    <div>
                                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        Ø¹Ø±Ø¶ Ù¾Ù„Ù‡ (Ø¹Ù…Ù‚ Ù¾Ù„Ù‡) (cm)
                                      </label>
                                      <FormattedNumberInput
                                        value={stairSystemConfig.tread.treadDepth || 30}
                                        onChange={(value) => {
                                          updateStairPart('tread', { treadDepth: value || 30 });
                                        }}
                                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        min={0}
                                        step={0.1}
                                        placeholder="30"
                                      />
                                      <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                        Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ 28-32 Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±
                                      </p>
                                    </div>
                                  </div>

                                  {/* Quantity for Tread */}
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                      ØªØ¹Ø¯Ø§Ø¯ (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: {stairSystemConfig.numberOfSteps || 0})
                                    </label>
                                    <FormattedNumberInput
                                      value={stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0}
                                      onChange={(value) => {
                                        updateStairPart('tread', { quantity: value || 0 });
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      min={0}
                                      step={1}
                                      placeholder={`${stairSystemConfig.numberOfSteps || 0}`}
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                      Ø¨Ù‡ Ø·ÙˆØ± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡ Ù‡Ù…Ú¯Ø§Ù… Ø§Ø³ØªØŒ Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯
                                    </p>
                                  </div>

                                  {/* Tread Calculations */}
                                  {(() => {
                                    const treadMetrics = calculateTreadMetrics({
                                      treadWidth: stairSystemConfig.tread.treadWidth || 0,
                                      treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                                      treadDepth: stairSystemConfig.tread.treadDepth || 30,
                                      quantity: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                                      quantityType: stairSystemConfig.quantityType,
                                      numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                                    });
                                    
                                    const nosingCost = calculateNosingCuttingCost({
                                      nosingType: stairSystemConfig.tread.nosingType || 'none',
                                      treadWidth: stairSystemConfig.tread.treadWidth || 0,
                                      treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                                      numberOfSteps: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                                      numberOfStaircases: stairSystemConfig.quantityType === 'staircases' ? (stairSystemConfig.numberOfStaircases || 1) : 1,
                                      quantityType: stairSystemConfig.quantityType
                                    });
                                    
                                    const basePrice = treadMetrics.totalArea * (stairSystemConfig.tread.pricePerSquareMeter || 0);
                                    const mandatoryPrice = stairSystemConfig.tread.isMandatory && stairSystemConfig.tread.mandatoryPercentage
                                      ? basePrice * (stairSystemConfig.tread.mandatoryPercentage / 100)
                                      : 0;
                                    const totalPrice = basePrice + mandatoryPrice + nosingCost.cuttingCost;
                                    
                                    // Update stair part with calculated values
                                    // Always update if squareMeters or totalPrice changed (to handle price/mandatory/nosing changes)
                                    // Use Math.abs to handle floating point comparison issues
                                    const squareMetersChanged = Math.abs((stairSystemConfig.tread.squareMeters || 0) - treadMetrics.totalArea) > 0.001;
                                    const totalPriceChanged = Math.abs((stairSystemConfig.tread.totalPrice || 0) - totalPrice) > 0.01;
                                    
                                    if (squareMetersChanged || totalPriceChanged) {
                                      // Use requestAnimationFrame for better state update timing
                                      requestAnimationFrame(() => {
                                        updateStairPart('tread', {
                                          squareMeters: treadMetrics.totalArea,
                                          totalPrice: totalPrice,
                                          originalTotalPrice: basePrice,
                                          nosingCuttingCost: nosingCost.cuttingCost,
                                          nosingCuttingCostPerMeter: nosingCost.cuttingCostPerMeter
                                        });
                                      });
                                    }
                                    
                                    return (
                                      <div className="space-y-3">
                                        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                                          <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">Ù…ØªØ± Ù…Ø±Ø¨Ø¹:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatSquareMeters(treadMetrics.totalArea)}
                                              </span>
                                            </div>
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">ØªØ¹Ø¯Ø§Ø¯:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatDisplayNumber(treadMetrics.totalQuantity)}
                                              </span>
                                            </div>
                                          </div>
                                        </div>

                                        {/* Nosing Configuration (only for tread) */}
                                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg p-3">
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            Ù†ÙˆØ¹ Ù¾ÛŒØ´Ø§Ù†ÛŒ:
                                          </label>
                                          <select
                                            value={stairSystemConfig.tread.nosingType || 'none'}
                                            onChange={(e) => {
                                              updateStairPart('tread', { nosingType: e.target.value });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                          >
                                            {NOSING_TYPES.filter(n => n.available).map(nosing => (
                                              <option key={nosing.id} value={nosing.id}>
                                                {nosing.name} {nosing.cuttingCostPerMeter > 0 ? `(${formatPrice(nosing.cuttingCostPerMeter, 'ØªÙˆÙ…Ø§Ù†')}/Ù…ØªØ±)` : ''}
                                              </option>
                                            ))}
                                          </select>
                                          {nosingCost.cuttingCost > 0 && (
                                            <p className="text-xs text-blue-600 dark:text-blue-400 mt-2">
                                              Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ù¾ÛŒØ´Ø§Ù†ÛŒ: {formatPrice(nosingCost.cuttingCost, 'ØªÙˆÙ…Ø§Ù†')}
                                            </p>
                                          )}
                                        </div>

                                        {/* Price per Square Meter */}
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (ØªÙˆÙ…Ø§Ù†):
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.tread.pricePerSquareMeter || 0}
                                            onChange={(value) => {
                                              updateStairPart('tread', { pricePerSquareMeter: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={1000}
                                            placeholder="Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹"
                                          />
                                        </div>

                                        {/* Mandatory Pricing for Tread */}
                                        <div className="border-t border-gray-200 dark:border-gray-600 pt-3">
                                          <div className="flex items-center space-x-3 space-x-reverse mb-2">
                                            <input
                                              type="checkbox"
                                              checked={stairSystemConfig.tread.isMandatory || false}
                                              onChange={(e) => {
                                                updateStairPart('tread', { isMandatory: e.target.checked });
                                              }}
                                              className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                                            />
                                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                              Ø­Ú©Ù…ÛŒ (Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª)
                                            </label>
                                          </div>
                                          {stairSystemConfig.tread.isMandatory && (
                                            <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-3">
                                              <div className="flex items-center space-x-3 space-x-reverse">
                                                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                                  Ø¯Ø±ØµØ¯ Ø§ÙØ²Ø§ÛŒØ´:
                                                </label>
                                                <FormattedNumberInput
                                                  value={stairSystemConfig.tread.mandatoryPercentage || 20}
                                                  onChange={(value) => {
                                                    updateStairPart('tread', { mandatoryPercentage: value || 20 });
                                                  }}
                                                  className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                                  min={0}
                                                  max={100}
                                                />
                                                <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                                              </div>
                                            </div>
                                          )}
                                        </div>

                                        {/* Total Price for Tread */}
                                        {totalPrice > 0 && (
                                          <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border border-teal-200 dark:border-teal-800 rounded-lg p-3">
                                            <div className="flex justify-between items-center">
                                              <span className="text-sm font-medium text-teal-800 dark:text-teal-200">
                                                Ù‚ÛŒÙ…Øª Ú©Ù„ Ú©Ù Ù¾Ù„Ù‡:
                                              </span>
                                              <span className="text-lg font-bold text-teal-900 dark:text-teal-100">
                                                {formatPrice(totalPrice, 'ØªÙˆÙ…Ø§Ù†')}
                                              </span>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })()}
                                </>
                              )}
                            </div>
                          )}
                        </div>
                        {/* Section 2: Ø®ÛŒØ² Ù¾Ù„Ù‡ (Riser) */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden">
                          <button
                            type="button"
                            onClick={() => setRiserExpanded(!riserExpanded)}
                            className="w-full flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                          >
                            <div className="flex items-center gap-3">
                              <input
                                type="checkbox"
                                checked={stairSystemConfig?.riser.isSelected || false}
                                onChange={(e) => {
                                  updateStairPart('riser', { isSelected: e.target.checked });
                                }}
                                onClick={(e) => e.stopPropagation()}
                                className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                              />
                              <span className="font-semibold text-gray-800 dark:text-white">Ø®ÛŒØ² Ù¾Ù„Ù‡ (Riser)</span>
                            </div>
                            {riserExpanded ? (
                              <FaChevronUp className="text-gray-500 dark:text-gray-400" />
                            ) : (
                              <FaChevronDown className="text-gray-500 dark:text-gray-400" />
                            )}
                          </button>
                          
                          {riserExpanded && stairSystemConfig && (
                            <div className="p-4 space-y-4 border-t border-gray-200 dark:border-gray-600">
                              {/* Product Selection for Riser */}
                              <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  Ø§Ù†ØªØ®Ø§Ø¨ Ù…Ø­ØµÙˆÙ„:
                                </label>
                                {stairSystemConfig.riser.product ? (
                                  <div className="p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg mb-2">
                                    <div className="flex items-center justify-between">
                                      <div>
                                        <p className="font-medium text-gray-800 dark:text-white">
                                          {generateFullProductName(stairSystemConfig.riser.product)}
                                        </p>
                                        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                          {stairSystemConfig.riser.product.stoneTypeNamePersian} â€¢ Ø¹Ø±Ø¶ {stairSystemConfig.riser.product.widthValue}Ã—Ø¶Ø®Ø§Ù…Øª {stairSystemConfig.riser.product.thicknessValue}cm
                                        </p>
                                      </div>
                                      <button
                                        type="button"
                                        onClick={() => {
                                          updateStairPart('riser', {
                                            productId: null,
                                            product: null,
                                            pricePerSquareMeter: 0
                                          });
                                          syncDraftWithProduct('riser', null);
                                          if (stairSystemV2.stairActivePart === 'riser') {
                                            stairSystemV2.setStoneSearchTerm('');
                                          }
                                          setRiserProductSearchTerm('');
                                        }}
                                        className="text-sm text-teal-600 dark:text-teal-400 hover:text-teal-700 dark:hover:text-teØ§Ù„-300"
                                      >
                                        ØªØºÛŒÛŒØ±
                                      </button>
                                    </div>
                                  </div>
                                ) : (
                                  <div className="mb-2">
                                    <div className="relative">
                                      <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                        <FaSearch className="h-5 w-5 text-gray-400" />
                                      </div>
                                      <input
                                        type="text"
                                        placeholder="Ø¬Ø³ØªØ¬Ùˆ Ù…Ø­ØµÙˆÙ„..."
                                        value={riserProductSearchTerm}
                                        onChange={(e) => setRiserProductSearchTerm(e.target.value)}
                                        className="w-full pr-10 pl-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      />
                                    </div>
                                    {riserProductSearchTerm && (
                                      <div className="mt-2 max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800">
                                        {filteredRiserProducts.map((product) => (
                                          <div
                                            key={product.id}
                                            onClick={() => {
                                              selectProductForStairPart('riser', product);
                                              setRiserProductSearchTerm('');
                                            }}
                                            className="p-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0"
                                          >
                                            <p className="font-medium text-gray-800 dark:text-white text-sm">
                                              {generateFullProductName(product)}
                                            </p>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                              {product.basePrice ? formatPrice(product.basePrice, product.currency) : 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡'}
                                            </p>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>

                              {/* Riser Dimensions */}
                              {stairSystemConfig.riser.product && (
                                <>
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                      Ø§Ø±ØªÙØ§Ø¹ Ù‚Ø§Ø¦Ù…Ù‡ (cm)
                                    </label>
                                    <FormattedNumberInput
                                      value={stairSystemConfig.riser.riserHeight || 17}
                                      onChange={(value) => {
                                        updateStairPart('riser', { riserHeight: value || 17 });
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      min={0}
                                      step={0.1}
                                      placeholder="17"
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                      Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ 15-19 Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±
                                    </p>
                                  </div>

                                  {/* Quantity for Riser */}
                                  <div>
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                      ØªØ¹Ø¯Ø§Ø¯ (Ù¾ÛŒØ´â€ŒÙØ±Ø¶: {stairSystemConfig.numberOfSteps || 0})
                                    </label>
                                    <FormattedNumberInput
                                      value={stairSystemConfig.riser.quantity || stairSystemConfig.numberOfSteps || 0}
                                      onChange={(value) => {
                                        updateStairPart('riser', { quantity: value || 0 });
                                      }}
                                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      min={0}
                                      step={1}
                                      placeholder={`${stairSystemConfig.numberOfSteps || 0}`}
                                    />
                                    <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                      Ø¨Ù‡ Ø·ÙˆØ± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø§ ØªØ¹Ø¯Ø§Ø¯ Ù¾Ù„Ù‡ Ù‡Ù…Ú¯Ø§Ù… Ø§Ø³ØªØŒ Ø§Ù…Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯
                                    </p>
                                  </div>

                                  {/* Riser Calculations */}
                                  {(() => {
                                    const treadWidth = stairSystemConfig.tread.treadWidth || 100;
                                    const treadWidthUnit = stairSystemConfig.tread.lengthUnit || 'm';
                                    
                                    const riserMetrics = calculateRiserMetrics({
                                      treadWidth: treadWidth,
                                      treadWidthUnit: treadWidthUnit,
                                      riserHeight: stairSystemConfig.riser.riserHeight || 17,
                                      quantity: stairSystemConfig.riser.quantity || stairSystemConfig.numberOfSteps || 0,
                                      quantityType: stairSystemConfig.quantityType,
                                      numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                                    });
                                    
                                    const basePrice = riserMetrics.totalArea * (stairSystemConfig.riser.pricePerSquareMeter || 0);
                                    const mandatoryPrice = stairSystemConfig.riser.isMandatory && stairSystemConfig.riser.mandatoryPercentage
                                      ? basePrice * (stairSystemConfig.riser.mandatoryPercentage / 100)
                                      : 0;
                                    const totalPrice = basePrice + mandatoryPrice;
                                    
                                    // Update riser part with calculated values
                                    // Always update if squareMeters or totalPrice changed (to handle price/mandatory changes)
                                    // Use Math.abs to handle floating point comparison issues
                                    const squareMetersChanged = Math.abs((stairSystemConfig.riser.squareMeters || 0) - riserMetrics.totalArea) > 0.001;
                                    const totalPriceChanged = Math.abs((stairSystemConfig.riser.totalPrice || 0) - totalPrice) > 0.01;
                                    
                                    if (squareMetersChanged || totalPriceChanged) {
                                      // Use requestAnimationFrame for better state update timing
                                      requestAnimationFrame(() => {
                                        updateStairPart('riser', {
                                          squareMeters: riserMetrics.totalArea,
                                          totalPrice: totalPrice,
                                          originalTotalPrice: basePrice
                                        });
                                      });
                                    }
                                    
                                    return (
                                      <div className="space-y-3">
                                        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                                          <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">Ù…ØªØ± Ù…Ø±Ø¨Ø¹:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatSquareMeters(riserMetrics.totalArea)}
                                              </span>
                                            </div>
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">ØªØ¹Ø¯Ø§Ø¯:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatDisplayNumber(riserMetrics.totalQuantity)}
                                              </span>
                                            </div>
                                          </div>
                                        </div>

                                        {/* Price per Square Meter */}
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (ØªÙˆÙ…Ø§Ù†):
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.riser.pricePerSquareMeter || 0}
                                            onChange={(value) => {
                                              updateStairPart('riser', { pricePerSquareMeter: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={1000}
                                            placeholder="Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹"
                                          />
                                        </div>

                                        {/* Mandatory Pricing for Riser */}
                                        <div className="border-t border-gray-200 dark:border-gray-600 pt-3">
                                          <div className="flex items-center space-x-3 space-x-reverse mb-2">
                                            <input
                                              type="checkbox"
                                              checked={stairSystemConfig.riser.isMandatory || false}
                                              onChange={(e) => {
                                                updateStairPart('riser', { isMandatory: e.target.checked });
                                              }}
                                              className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                                            />
                                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                              Ø­Ú©Ù…ÛŒ (Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª)
                                            </label>
                                          </div>
                                          {stairSystemConfig.riser.isMandatory && (
                                            <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-3">
                                              <div className="flex items-center space-x-3 space-x-reverse">
                                                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                                  Ø¯Ø±ØµØ¯ Ø§ÙØ²Ø§ÛŒØ´:
                                                </label>
                                                <FormattedNumberInput
                                                  value={stairSystemConfig.riser.mandatoryPercentage || 20}
                                                  onChange={(value) => {
                                                    updateStairPart('riser', { mandatoryPercentage: value || 20 });
                                                  }}
                                                  className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                                  min={0}
                                                  max={100}
                                                />
                                                <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                                              </div>
                                            </div>
                                          )}
                                        </div>

                                        {/* Total Price for Riser */}
                                        {totalPrice > 0 && (
                                          <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border border-teal-200 dark:border-teal-800 rounded-lg p-3">
                                            <div className="flex justify-between items-center">
                                              <span className="text-sm font-medium text-teal-800 dark:text-teal-200">
                                                Ù‚ÛŒÙ…Øª Ú©Ù„ Ø®ÛŒØ² Ù¾Ù„Ù‡:
                                              </span>
                                              <span className="text-lg font-bold text-teal-900 dark:text-teal-100">
                                                {formatPrice(totalPrice, 'ØªÙˆÙ…Ø§Ù†')}
                                              </span>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })()}
                                </>
                              )}
                            </div>
                          )}
                        </div>
                        {/* Section 3: Ù¾Ø§Ú¯Ø±Ø¯ (Landing) */}
                        <div className="border border-gray-200 dark:border-gray-600 rounded-lg overflow-hidden">
                          <button
                            type="button"
                            onClick={() => setLandingExpanded(!landingExpanded)}
                            className="w-full flex items-center justify-between p-4 bg-gray-50 dark:bg-gray-700/50 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                          >
                            <div className="flex items-center gap-3">
                              <input
                                type="checkbox"
                                checked={stairSystemConfig?.landing.isSelected || false}
                                onChange={(e) => {
                                  updateStairPart('landing', { isSelected: e.target.checked });
                                }}
                                onClick={(e) => e.stopPropagation()}
                                className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                              />
                              <span className="font-semibold text-gray-800 dark:text-white">Ù¾Ø§Ú¯Ø±Ø¯ (Landing)</span>
                            </div>
                            {landingExpanded ? (
                              <FaChevronUp className="text-gray-500 dark:text-gray-400" />
                            ) : (
                              <FaChevronDown className="text-gray-500 dark:text-gray-400" />
                            )}
                          </button>
                          
                          {landingExpanded && stairSystemConfig && (
                            <div className="p-4 space-y-4 border-t border-gray-200 dark:border-gray-600">
                              {/* Product Selection for Landing */}
                              <div>
                                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                  Ø§Ù†ØªØ®Ø§Ø¨ Ù…Ø­ØµÙˆÙ„:
                                </label>
                                {stairSystemConfig.landing.product ? (
                                  <div className="p-3 bg-teal-50 dark:bg-teal-900/20 border border-teal-200 dark:border-teal-800 rounded-lg mb-2">
                                    <div className="flex items-center justify-between">
                                      <div>
                                        <p className="font-medium text-gray-800 dark:text-white">
                                          {generateFullProductName(stairSystemConfig.landing.product)}
                                        </p>
                                        <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                                          {stairSystemConfig.landing.product.stoneTypeNamePersian} â€¢ Ø¹Ø±Ø¶ {stairSystemConfig.landing.product.widthValue}Ã—Ø¶Ø®Ø§Ù…Øª {stairSystemConfig.landing.product.thicknessValue}cm
                                        </p>
                                      </div>
                                      <button
                                        type="button"
                                        onClick={() => {
                                          updateStairPart('landing', {
                                            productId: null,
                                            product: null,
                                            pricePerSquareMeter: 0
                                          });
                                          syncDraftWithProduct('landing', null);
                                          if (stairSystemV2.stairActivePart === 'landing') {
                                            stairSystemV2.setStoneSearchTerm('');
                                          }
                                          setLandingProductSearchTerm('');
                                        }}
                                        className="text-sm text-teal-600 dark:text-teal-400 hover:text-teal-700 dark:hover:text-teØ§Ù„-300"
                                      >
                                        ØªØºÛŒÛŒØ±
                                      </button>
                                    </div>
                                  </div>
                                ) : (
                                  <div className="mb-2">
                                    <div className="relative">
                                      <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                        <FaSearch className="h-5 w-5 text-gray-400" />
                                      </div>
                                      <input
                                        type="text"
                                        placeholder="Ø¬Ø³ØªØ¬Ùˆ Ù…Ø­ØµÙˆÙ„..."
                                        value={landingProductSearchTerm}
                                        onChange={(e) => setLandingProductSearchTerm(e.target.value)}
                                        className="w-full pr-10 pl-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                      />
                                    </div>
                                    {landingProductSearchTerm && (
                                      <div className="mt-2 max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800">
                                        {filteredLandingProducts.map((product) => (
                                          <div
                                            key={product.id}
                                            onClick={() => {
                                              selectProductForStairPart('landing', product);
                                              setLandingProductSearchTerm('');
                                            }}
                                            className="p-3 hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-700 last:border-b-0"
                                          >
                                            <p className="font-medium text-gray-800 dark:text-white text-sm">
                                              {generateFullProductName(product)}
                                            </p>
                                            <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                                              {product.basePrice ? formatPrice(product.basePrice, product.currency) : 'Ù‚ÛŒÙ…Øª ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡'}
                                            </p>
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </div>
                                )}
                              </div>

                              {/* Landing Dimensions */}
                              {stairSystemConfig.landing.product && (
                                <>
                                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                    <div>
                                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                        ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø§Ú¯Ø±Ø¯
                                      </label>
                                      <FormattedNumberInput
                                        value={stairSystemConfig.landing.numberOfLandings || 0}
                                        onChange={(value) => {
                                          updateStairPart('landing', { numberOfLandings: value || 0 });
                                        }}
                                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                        min={0}
                                        step={1}
                                        placeholder="0"
                                      />
                                    </div>
                                    {stairSystemConfig.landing.numberOfLandings && stairSystemConfig.landing.numberOfLandings > 0 && (
                                      <>
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            Ø¹Ø±Ø¶ Ù¾Ø§Ú¯Ø±Ø¯ (cm)
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.landing.landingWidth || 0}
                                            onChange={(value) => {
                                              updateStairPart('landing', { landingWidth: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={0.1}
                                            placeholder="Ø¹Ø±Ø¶"
                                          />
                                        </div>
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            Ø¹Ù…Ù‚ Ù¾Ø§Ú¯Ø±Ø¯ (cm)
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.landing.landingDepth || 0}
                                            onChange={(value) => {
                                              updateStairPart('landing', { landingDepth: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={0.1}
                                            placeholder="Ø¹Ù…Ù‚"
                                          />
                                        </div>
                                      </>
                                    )}
                                  </div>

                                  {/* Landing Calculations */}
                                  {(() => {
                                    const landingMetrics = calculateLandingMetrics({
                                      landingWidth: stairSystemConfig.landing.landingWidth || 0,
                                      landingDepth: stairSystemConfig.landing.landingDepth || 0,
                                      numberOfLandings: stairSystemConfig.landing.numberOfLandings || 0,
                                      quantityType: stairSystemConfig.quantityType,
                                      numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                                    });
                                    
                                    const basePrice = landingMetrics.totalArea * (stairSystemConfig.landing.pricePerSquareMeter || 0);
                                    const mandatoryPrice = stairSystemConfig.landing.isMandatory && stairSystemConfig.landing.mandatoryPercentage
                                      ? basePrice * (stairSystemConfig.landing.mandatoryPercentage / 100)
                                      : 0;
                                    const totalPrice = basePrice + mandatoryPrice;
                                    
                                    // Update landing part with calculated values
                                    // Always update if squareMeters or totalPrice changed (to handle price/mandatory changes)
                                    // Use Math.abs to handle floating point comparison issues
                                    const squareMetersChanged = Math.abs((stairSystemConfig.landing.squareMeters || 0) - landingMetrics.totalArea) > 0.001;
                                    const totalPriceChanged = Math.abs((stairSystemConfig.landing.totalPrice || 0) - totalPrice) > 0.01;
                                    
                                    if (squareMetersChanged || totalPriceChanged) {
                                      // Use requestAnimationFrame for better state update timing
                                      requestAnimationFrame(() => {
                                        updateStairPart('landing', {
                                          squareMeters: landingMetrics.totalArea,
                                          quantity: landingMetrics.totalQuantity,
                                          totalPrice: totalPrice,
                                          originalTotalPrice: basePrice
                                        });
                                      });
                                    }
                                    
                                    return (
                                      <div className="space-y-3">
                                        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                                          <div className="grid grid-cols-2 gap-3 text-sm">
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">Ù…ØªØ± Ù…Ø±Ø¨Ø¹:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatSquareMeters(landingMetrics.totalArea)}
                                              </span>
                                            </div>
                                            <div>
                                              <span className="text-gray-600 dark:text-gray-400">ØªØ¹Ø¯Ø§Ø¯:</span>
                                              <span className="font-semibold text-gray-800 dark:text-white mr-2">
                                                {formatDisplayNumber(landingMetrics.totalQuantity)}
                                              </span>
                                            </div>
                                          </div>
                                        </div>

                                        {/* Price per Square Meter */}
                                        <div>
                                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                            ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (ØªÙˆÙ…Ø§Ù†):
                                          </label>
                                          <FormattedNumberInput
                                            value={stairSystemConfig.landing.pricePerSquareMeter || 0}
                                            onChange={(value) => {
                                              updateStairPart('landing', { pricePerSquareMeter: value || 0 });
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                                            min={0}
                                            step={1000}
                                            placeholder="Ù‚ÛŒÙ…Øª Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹"
                                          />
                                        </div>

                                        {/* Mandatory Pricing for Landing */}
                                        <div className="border-t border-gray-200 dark:border-gray-600 pt-3">
                                          <div className="flex items-center space-x-3 space-x-reverse mb-2">
                                            <input
                                              type="checkbox"
                                              checked={stairSystemConfig.landing.isMandatory || false}
                                              onChange={(e) => {
                                                updateStairPart('landing', { isMandatory: e.target.checked });
                                              }}
                                              className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                                            />
                                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                              Ø­Ú©Ù…ÛŒ (Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª)
                                            </label>
                                          </div>
                                          {stairSystemConfig.landing.isMandatory && (
                                            <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-3">
                                              <div className="flex items-center space-x-3 space-x-reverse">
                                                <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                                                  Ø¯Ø±ØµØ¯ Ø§ÙØ²Ø§ÛŒØ´:
                                                </label>
                                                <FormattedNumberInput
                                                  value={stairSystemConfig.landing.mandatoryPercentage || 20}
                                                  onChange={(value) => {
                                                    updateStairPart('landing', { mandatoryPercentage: value || 20 });
                                                  }}
                                                  className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                                                  min={0}
                                                  max={100}
                                                />
                                                <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                                              </div>
                                            </div>
                                          )}
                                        </div>

                                        {/* Total Price for Landing */}
                                        {totalPrice > 0 && (
                                          <div className="bg-gradient-to-r from-teal-50 to-teal-100 dark:from-teal-900/30 dark:to-teal-800/30 border border-teal-200 dark:border-teal-800 rounded-lg p-3">
                                            <div className="flex justify-between items-center">
                                              <span className="text-sm font-medium text-teal-800 dark:text-teal-200">
                                                Ù‚ÛŒÙ…Øª Ú©Ù„ Ù¾Ø§Ú¯Ø±Ø¯:
                                              </span>
                                              <span className="text-lg font-bold text-teal-900 dark:text-teal-100">
                                                {formatPrice(totalPrice, 'ØªÙˆÙ…Ø§Ù†')}
                                              </span>
                                            </div>
                                          </div>
                                        )}
                                      </div>
                                    );
                                  })()}
                                </>
                              )}
                            </div>
                          )}
                        </div>
                        {/* Total Summary */}
                        {stairSystemConfig && (() => {
                          // Calculate totals directly from current values to ensure accuracy
                          // This avoids relying on state that might not be updated yet
                          
                          // Calculate Tread Total
                          let treadTotal = 0;
                          if (stairSystemConfig.tread.isSelected && stairSystemConfig.tread.product) {
                            const treadMetrics = calculateTreadMetrics({
                              treadWidth: stairSystemConfig.tread.treadWidth || 0,
                              treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                              treadDepth: stairSystemConfig.tread.treadDepth || 30,
                              quantity: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                              quantityType: stairSystemConfig.quantityType,
                              numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                            });
                            
                            const nosingCost = calculateNosingCuttingCost({
                              nosingType: stairSystemConfig.tread.nosingType || 'none',
                              treadWidth: stairSystemConfig.tread.treadWidth || 0,
                              treadWidthUnit: stairSystemConfig.tread.lengthUnit || 'm',
                              numberOfSteps: stairSystemConfig.tread.quantity || stairSystemConfig.numberOfSteps || 0,
                              numberOfStaircases: stairSystemConfig.quantityType === 'staircases' ? (stairSystemConfig.numberOfStaircases || 1) : 1,
                              quantityType: stairSystemConfig.quantityType
                            });
                            
                            const basePrice = treadMetrics.totalArea * (stairSystemConfig.tread.pricePerSquareMeter || 0);
                            const mandatoryPrice = stairSystemConfig.tread.isMandatory && stairSystemConfig.tread.mandatoryPercentage
                              ? basePrice * (stairSystemConfig.tread.mandatoryPercentage / 100)
                              : 0;
                            treadTotal = basePrice + mandatoryPrice + nosingCost.cuttingCost;
                          }
                          
                          // Calculate Riser Total
                          let riserTotal = 0;
                          if (stairSystemConfig.riser.isSelected && stairSystemConfig.riser.product) {
                            const treadWidth = stairSystemConfig.tread.treadWidth || 100;
                            const treadWidthUnit = stairSystemConfig.tread.lengthUnit || 'm';
                            
                            const riserMetrics = calculateRiserMetrics({
                              treadWidth: treadWidth,
                              treadWidthUnit: treadWidthUnit,
                              riserHeight: stairSystemConfig.riser.riserHeight || 17,
                              quantity: stairSystemConfig.riser.quantity || stairSystemConfig.numberOfSteps || 0,
                              quantityType: stairSystemConfig.quantityType,
                              numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                            });
                            
                            const basePrice = riserMetrics.totalArea * (stairSystemConfig.riser.pricePerSquareMeter || 0);
                            const mandatoryPrice = stairSystemConfig.riser.isMandatory && stairSystemConfig.riser.mandatoryPercentage
                              ? basePrice * (stairSystemConfig.riser.mandatoryPercentage / 100)
                              : 0;
                            riserTotal = basePrice + mandatoryPrice;
                          }
                          
                          // Calculate Landing Total
                          let landingTotal = 0;
                          if (stairSystemConfig.landing.isSelected && stairSystemConfig.landing.product) {
                            const landingMetrics = calculateLandingMetrics({
                              landingWidth: stairSystemConfig.landing.landingWidth || 0,
                              landingDepth: stairSystemConfig.landing.landingDepth || 0,
                              numberOfLandings: stairSystemConfig.landing.numberOfLandings || 0,
                              quantityType: stairSystemConfig.quantityType,
                              numberOfStaircases: stairSystemConfig.numberOfStaircases || 1
                            });
                            
                            const basePrice = landingMetrics.totalArea * (stairSystemConfig.landing.pricePerSquareMeter || 0);
                            const mandatoryPrice = stairSystemConfig.landing.isMandatory && stairSystemConfig.landing.mandatoryPercentage
                              ? basePrice * (stairSystemConfig.landing.mandatoryPercentage / 100)
                              : 0;
                            landingTotal = basePrice + mandatoryPrice;
                          }
                          
                          const grandTotal = treadTotal + riserTotal + landingTotal;
                          
                          return (
                            <div className="bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900/30 dark:to-purple-800/30 border border-purple-200 dark:border-purple-800 rounded-lg p-4">
                              <h4 className="text-sm font-semibold text-purple-800 dark:text-purple-200 mb-3">
                                Ø®Ù„Ø§ØµÙ‡ Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù¾Ù„Ù‡:
                              </h4>
                              <div className="space-y-2 text-sm">
                                {stairSystemConfig.tread.isSelected && treadTotal > 0 && (
                                  <div className="flex justify-between">
                                    <span className="text-gray-700 dark:text-gray-300">Ú©Ù Ù¾Ù„Ù‡:</span>
                                    <span className="font-semibold text-gray-800 dark:text-white">
                                      {formatPrice(treadTotal, 'ØªÙˆÙ…Ø§Ù†')}
                                    </span>
                                  </div>
                                )}
                                {stairSystemConfig.riser.isSelected && riserTotal > 0 && (
                                  <div className="flex justify-between">
                                    <span className="text-gray-700 dark:text-gray-300">Ø®ÛŒØ² Ù¾Ù„Ù‡:</span>
                                    <span className="font-semibold text-gray-800 dark:text-white">
                                      {formatPrice(riserTotal, 'ØªÙˆÙ…Ø§Ù†')}
                                    </span>
                                  </div>
                                )}
                                {stairSystemConfig.landing.isSelected && landingTotal > 0 && (
                                  <div className="flex justify-between">
                                    <span className="text-gray-700 dark:text-gray-300">Ù¾Ø§Ú¯Ø±Ø¯:</span>
                                    <span className="font-semibold text-gray-800 dark:text-white">
                                      {formatPrice(landingTotal, 'ØªÙˆÙ…Ø§Ù†')}
                                    </span>
                                  </div>
                                )}
                                <div className="border-t border-purple-200 dark:border-purple-700 pt-2 mt-2">
                                  <div className="flex justify-between">
                                    <span className="font-bold text-purple-800 dark:text-purple-200">Ø¬Ù…Ø¹ Ú©Ù„:</span>
                                    <span className="font-bold text-lg text-purple-900 dark:text-purple-100">
                                      {formatPrice(grandTotal, 'ØªÙˆÙ…Ø§Ù†')}
                                    </span>
                                  </div>
                                </div>
                              </div>
                            </div>
                          );
                        })()}
                      </div>
                    </>
                  ) : null}
                  
                  {/* Conditional for longitudinal and slab stones (only shown if not stair) */}
                  {(productConfig.productType === 'longitudinal' || productConfig.productType === 'slab') && (
                    <>
                      {/* LONGITUDINAL STONE CONFIGURATION FORM (existing) */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            Ù†Ø§Ù… Ú©Ø§Ù…Ù„ Ø³Ù†Ú¯
                          </label>
                          <div className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-600 text-gray-800 dark:text-white">
                            {selectedProduct ? generateFullProductName(selectedProduct) : 'Ù…Ø­ØµÙˆÙ„ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª'}
                          </div>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            Ù†Ø§Ù… ÛŒØ§ Ù†ÙˆØ¹ Ø³Ù†Ú¯
                          </label>
                          <input
                            type="text"
                            value={productConfig.stoneName || ''}
                            onFocus={() => handleFieldFocus('stoneName', productConfig.stoneName, '')}
                            onChange={(e) => setProductConfig(prev => ({ ...prev, stoneName: e.target.value }))}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                          />
                        </div>
                      </div>
                  {/* For Slab: Enhanced Requested Dimensions Section */}
                  {productConfig.productType === 'slab' ? (
                    <div className="bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-blue-900/20 dark:to-indigo-900/20 border-2 border-blue-200 dark:border-blue-800 rounded-xl p-6 shadow-lg">
                      <div className="flex items-center gap-3 mb-5">
                        <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-500 to-indigo-600 dark:from-blue-600 dark:to-indigo-700 flex items-center justify-center shadow-md">
                          <FaRuler className="text-white text-xl" />
                        </div>
                    <div>
                          <h4 className="text-lg font-bold text-blue-900 dark:text-blue-100">Ø§Ø¨Ø¹Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ</h4>
                          <p className="text-xs text-blue-700 dark:text-blue-300">Ù…Ø´Ø®ØµØ§Øª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ Ù…Ø­ØµÙˆÙ„ Ù†Ù‡Ø§ÛŒÛŒ</p>
                        </div>
                      </div>
                      
                      {/* Length and Width Inputs in Row */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        {/* Length Input */}
                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-blue-200 dark:border-blue-700 shadow-sm">
                          <label className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3 flex items-center gap-2">
                            <FaRuler className="text-blue-600 dark:text-blue-400" />
                            Ø·ÙˆÙ„ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ
                      </label>
                        <FormattedNumberInput
                          value={productConfig.length || 0}
                          onFocus={() => handleFieldFocus('length', productConfig.length, 0)}
                          onChange={(value) => {
                            // Update the length first
                            setProductConfig(prev => {
                              const updatedConfig = { ...prev, length: value };
                              // Trigger smart calculation with updated config
                              const smartResult = handleSmartCalculation('length', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                              const finalConfig = {
                                ...updatedConfig,
                                width: smartResult.width,
                                squareMeters: smartResult.squareMeters
                              };
                              
                              // For slab products, validate length against original length
                              if (prev.productType === 'slab' && value > 0) {
                                const userLengthInCm = lengthUnit === 'm' ? value * 100 : value;
                                const originalLength = (isEditMode && prev.originalLength !== undefined) 
                                  ? prev.originalLength 
                                  : ((selectedProduct as any).lengthValue || 300);
                                const originalLengthCm = lengthUnit === 'm' ? originalLength * 100 : originalLength;
                                
                                if (originalLengthCm > 0 && userLengthInCm > originalLengthCm) {
                                  setErrors({ 
                                    products: `Ø·ÙˆÙ„ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ (${value}${lengthUnit === 'm' ? 'm' : 'cm'}) Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø·ÙˆÙ„ Ø§ØµÙ„ÛŒ Ø§Ø³Ù„Ø¨ (${originalLengthCm / (lengthUnit === 'm' ? 100 : 1)}${lengthUnit === 'm' ? 'm' : 'cm'}) Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø·ÙˆÙ„ÛŒ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.` 
                                  });
                                } else if (errors.products && errors.products.includes('Ø·ÙˆÙ„ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡')) {
                                  setErrors({});
                                }
                              }
                              
                              // Check if we need to auto-select longitudinal cut after smart calculation
                              const userWidthInCm = widthUnit === 'm' ? finalConfig.width * 100 : finalConfig.width;
                              // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
                              const originalWidth = (isEditMode && prev.originalWidth) ? prev.originalWidth : (selectedProduct?.widthValue || 0);
                              const shouldAutoSelectLongitudinalCut = userWidthInCm < originalWidth && userWidthInCm > 0;
                              
                              console.log('ğŸ“ Length Changed - Auto Cut Selection:', {
                                userLength: value,
                                userLengthUnit: lengthUnit,
                                calculatedWidth: finalConfig.width,
                                userWidthInCm,
                                originalWidth,
                                shouldAutoSelectLongitudinalCut,
                                comparison: `${userWidthInCm} < ${originalWidth} = ${userWidthInCm < originalWidth}`
                              });
                              
                              // Automatically get cutting type price if cut should be applied
                              let cuttingCostPerMeter: number | null | undefined = prev.cuttingCostPerMeter || null;
                              if (shouldAutoSelectLongitudinalCut && !cuttingCostPerMeter) {
                                // Fetch price from cutting types for "LONG" (Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ)
                                cuttingCostPerMeter = getCuttingTypePricePerMeter('LONG');
                                console.log('ğŸ”§ Auto-fetched cutting cost per meter from services:', cuttingCostPerMeter);
                              } else if (!shouldAutoSelectLongitudinalCut) {
                                // Clear cutting cost if cut is not needed
                                cuttingCostPerMeter = undefined;
                              }
                              
                              // Calculate cutting cost automatically
                              const effectiveQuantity = getEffectiveQuantity();
                              const updatedCuttingCost = calculateAutoCuttingCost(
                                value,
                                lengthUnit,
                                cuttingCostPerMeter,
                                effectiveQuantity
                              );
                              
                              // Auto-select cut type based on calculated width
                              if (shouldAutoSelectLongitudinalCut && cuttingCostPerMeter) {
                                return {
                                  ...finalConfig,
                                  isCut: true,
                                  cutType: 'longitudinal',
                                  cuttingCostPerMeter: cuttingCostPerMeter,
                                  cuttingCost: updatedCuttingCost
                                };
                              } else {
                                return {
                                  ...finalConfig,
                                  isCut: false,
                                  cutType: null,
                                  cuttingCostPerMeter: undefined,
                                  cuttingCost: 0
                                };
                              }
                            });
                          }}
                          className="w-full px-4 py-3 text-base border-2 border-blue-300 dark:border-blue-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                          min={0}
                          step={0.1}
                          placeholder="Ù…Ù‚Ø¯Ø§Ø± Ø·ÙˆÙ„"
                        />
                          <div className="flex gap-2 mt-3">
                          <button
                            type="button"
                            onClick={() => handleLengthUnitChange('cm')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                              lengthUnit === 'cm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                            }`}
                          >
                            Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                          </button>
                          <button
                            type="button"
                            onClick={() => handleLengthUnitChange('m')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                              lengthUnit === 'm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                            }`}
                          >
                            Ù…ØªØ± (m)
                          </button>
                        </div>
                      </div>
                        
                        {/* Width Input */}
                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-blue-200 dark:border-blue-700 shadow-sm">
                          <label className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3 flex items-center gap-2">
                            <FaRuler className="text-blue-600 dark:text-blue-400" />
                            Ø¹Ø±Ø¶ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ
                      </label>
                        <FormattedNumberInput
                          value={productConfig.width || 0}
                          onFocus={() => {
                            handleFieldFocus('width', productConfig.width, 0);
                            // Clear width error on focus to allow user to fix it
                            if (errors.products && errors.products.includes('Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡')) {
                              setErrors({});
                            }
                          }}
                          onChange={(value) => {
                            // Update the width first
                            setProductConfig(prev => {
                              const updatedConfig = { ...prev, width: value };
                              // Trigger smart calculation with updated config
                              const smartResult = handleSmartCalculation('width', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                              return {
                                ...updatedConfig,
                                length: smartResult.length,
                                squareMeters: smartResult.squareMeters
                              };
                            });
                            
                            // Calculate width in cm for comparison
                            const userWidthInCm = widthUnit === 'm' ? value * 100 : value;
                            
                            // Get original width for validation
                            const originalWidth = (isEditMode && productConfig.originalWidth) 
                              ? productConfig.originalWidth 
                              : (selectedProduct?.widthValue || 0);
                            
                            // Validate: width cannot exceed original width
                            if (value > 0 && originalWidth > 0 && userWidthInCm > originalWidth) {
                              // Show error message
                              setErrors({ 
                                products: `Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ (${value}${widthUnit === 'm' ? 'm' : 'cm'}) Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø³Ù†Ú¯ (${originalWidth}cm) Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¹Ø±Ø¶ÛŒ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ Ø¨Ø§ ${originalWidth}cm ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.` 
                              });
                            } else {
                              // Clear error if width is valid
                              if (errors.products && errors.products.includes('Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡')) {
                                setErrors({});
                              }
                            }
                            
                            // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
                            setProductConfig(prev => {
                              const originalWidth = (isEditMode && prev.originalWidth) ? prev.originalWidth : (selectedProduct?.widthValue || 0);
                              const shouldAutoSelectLongitudinalCut = userWidthInCm < originalWidth && userWidthInCm > 0;
                              
                              // Log width change and auto-selection logic
                              console.log('ğŸ“ Width Changed - Auto Cut Selection:', {
                                userWidth: value,
                                userWidthUnit: widthUnit,
                                userWidthInCm,
                                originalWidth,
                                shouldAutoSelectLongitudinalCut,
                                comparison: `${userWidthInCm} < ${originalWidth} = ${userWidthInCm < originalWidth}`
                              });
                              
                              // Automatically get cutting type price if cut should be applied
                              let cuttingCostPerMeter: number | null | undefined = prev.cuttingCostPerMeter || null;
                              if (shouldAutoSelectLongitudinalCut && !cuttingCostPerMeter) {
                                // Fetch price from cutting types for "LONG" (Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ)
                                cuttingCostPerMeter = getCuttingTypePricePerMeter('LONG');
                                console.log('ğŸ”§ Auto-fetched cutting cost per meter from services:', cuttingCostPerMeter);
                              } else if (!shouldAutoSelectLongitudinalCut) {
                                // Clear cutting cost if cut is not needed
                                cuttingCostPerMeter = undefined;
                              }
                              
                              // Calculate cutting cost automatically
                              const effectiveQuantity = getEffectiveQuantity();
                              const updatedCuttingCost = calculateAutoCuttingCost(
                                prev.length,
                                lengthUnit,
                                cuttingCostPerMeter,
                                effectiveQuantity
                              );
                              
                              // Update cut type based on width comparison
                              if (shouldAutoSelectLongitudinalCut && cuttingCostPerMeter) {
                                return {
                                  ...prev,
                                  isCut: true,
                                  cutType: 'longitudinal',
                                  cuttingCostPerMeter: cuttingCostPerMeter,
                                  cuttingCost: updatedCuttingCost
                                };
                              } else {
                                return {
                                  ...prev,
                                  isCut: false,
                                  cutType: null,
                                  cuttingCostPerMeter: undefined,
                                  cuttingCost: 0
                                };
                              }
                            });
                          }}
                          className={`w-full px-4 py-3 text-base border-2 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 transition-all ${
                            errors.products && errors.products.includes('Ø¹Ø±Ø¶ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡')
                              ? 'border-red-500 dark:border-red-500 focus:ring-red-500 focus:border-red-500'
                              : 'border-blue-300 dark:border-blue-600 focus:ring-blue-500 focus:border-blue-500'
                          }`}
                          min={0}
                          step={0.1}
                          placeholder="Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø±Ø¶"
                        />
                          <div className="flex gap-2 mt-3">
                            <button
                              type="button"
                              onClick={() => handleWidthUnitChange('cm')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                                widthUnit === 'cm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                              }`}
                            >
                              Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                            </button>
                            <button
                              type="button"
                              onClick={() => handleWidthUnitChange('m')}
                              className={`flex-1 px-4 py-2.5 text-sm font-semibold rounded-lg transition-all ${
                                widthUnit === 'm'
                                  ? 'bg-blue-600 text-white shadow-md'
                                  : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                              }`}
                            >
                              Ù…ØªØ± (m)
                            </button>
                          </div>
                        </div>
                      </div>
                      
                      {/* Quantity and Summary Row */}
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-blue-200 dark:border-blue-700">
                          <label className="block text-sm font-semibold text-gray-700 dark:text-gray-300 mb-3">
                            ØªØ¹Ø¯Ø§Ø¯
                          </label>
                          <FormattedNumberInput
                            value={getQuantityDisplayValue()}
                            onFocus={() => handleFieldFocus('quantity', getQuantityDisplayValue(), 0)}
                            onChange={(value) => {
                              // Check if quantity is being cleared/deleted (empty or 0)
                              const isQuantityCleared = !value || value === 0;
                              
                              // Mark quantity as interacted
                              if (!hasQuantityBeenInteracted) {
                                setHasQuantityBeenInteracted(true);
                                console.log('ğŸ¯ Quantity First Interaction');
                              }
                              
                              // Handle mandatory pricing based on quantity state
                              if (isQuantityCleared) {
                                // If quantity is cleared, uncheck mandatory pricing and reset interaction state
                                setIsMandatory(false);
                                setHasQuantityBeenInteracted(false);
                                console.log('ğŸ”„ Quantity Cleared - Deactivating mandatory pricing and resetting interaction state');
                              } else {
                                // If quantity has a value, activate mandatory pricing
                                setIsMandatory(true);
                                console.log('âœ… Quantity Has Value - Activating mandatory pricing');
                              }
                              
                              // Update the quantity
                              setProductConfig(prev => {
                                const updatedConfig = { ...prev, quantity: value };
                                // Use effective quantity for calculations
                                const effectiveQuantity = value || 1;
                                // Trigger smart calculation with effective quantity
                                const smartResult = handleSmartCalculation('quantity', effectiveQuantity, updatedConfig, lengthUnit, widthUnit, effectiveQuantity);
                                
                                // Recalculate cutting cost automatically using helper function
                                const updatedCuttingCost = calculateAutoCuttingCost(
                                  updatedConfig.length,
                                  lengthUnit,
                                  prev.cuttingCostPerMeter || null,
                                  effectiveQuantity
                                );
                                
                                return {
                                  ...updatedConfig,
                                  squareMeters: smartResult.squareMeters,
                                  cuttingCost: updatedCuttingCost
                                };
                              });
                              
                              console.log('ğŸ“Š Quantity Changed:', {
                                displayValue: value,
                                effectiveQuantity: value || 1,
                                isQuantityCleared,
                                hasBeenInteracted: !isQuantityCleared,
                                mandatoryActivated: !isQuantityCleared
                              });
                            }}
                            className="w-full px-4 py-3 text-base border-2 border-blue-300 dark:border-blue-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                            min={1}
                            placeholder="ØªØ¹Ø¯Ø§Ø¯"
                          />
                        </div>
                        
                        {/* Summary Card */}
                        <div className="bg-gradient-to-br from-blue-100 to-indigo-100 dark:from-blue-900/30 dark:to-indigo-900/30 rounded-lg p-4 border-2 border-blue-300 dark:border-blue-600">
                          <p className="text-xs font-semibold text-blue-800 dark:text-blue-200 mb-2">Ø®Ù„Ø§ØµÙ‡ Ø§Ø¨Ø¹Ø§Ø¯</p>
                          <div className="space-y-2">
                            <div className="flex justify-between items-center">
                              <span className="text-sm text-gray-600 dark:text-gray-400">Ø·ÙˆÙ„:</span>
                              <span className="text-sm font-bold text-gray-900 dark:text-white">
                                {productConfig.length ? `${formatDisplayNumber(productConfig.length)} ${lengthUnit === 'm' ? 'm' : 'cm'}` : 'ÙˆØ§Ø±Ø¯ Ù†Ø´Ø¯Ù‡'}
                              </span>
                            </div>
                            <div className="flex justify-between items-center">
                              <span className="text-sm text-gray-600 dark:text-gray-400">Ø¹Ø±Ø¶:</span>
                              <span className="text-sm font-bold text-gray-900 dark:text-white">
                                {productConfig.width ? `${formatDisplayNumber(productConfig.width)} ${widthUnit === 'm' ? 'm' : 'cm'}` : 'ÙˆØ§Ø±Ø¯ Ù†Ø´Ø¯Ù‡'}
                              </span>
                            </div>
                            <div className="flex justify-between items-center pt-2 border-t border-blue-300 dark:border-blue-700">
                              <span className="text-sm text-gray-600 dark:text-gray-400">ØªØ¹Ø¯Ø§Ø¯:</span>
                              <span className="text-sm font-bold text-blue-900 dark:text-blue-100">
                                {productConfig.quantity || 0} Ø¹Ø¯Ø¯
                              </span>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    /* For Non-Slab: Original Layout */
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          Ø·ÙˆÙ„
                        </label>
                        <div className="space-y-2">
                          <FormattedNumberInput
                            value={productConfig.length || 0}
                            onFocus={() => handleFieldFocus('length', productConfig.length, 0)}
                            onChange={(value) => {
                              setProductConfig(prev => {
                                const updatedConfig = { ...prev, length: value };
                                const smartResult = handleSmartCalculation('length', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                                return {
                                  ...updatedConfig,
                                  width: smartResult.width,
                                  squareMeters: smartResult.squareMeters
                                };
                              });
                            }}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                            min={0}
                            step={0.1}
                            placeholder="Ù…Ù‚Ø¯Ø§Ø± Ø·ÙˆÙ„"
                          />
                          <div className="flex gap-1">
                            <button
                              type="button"
                              onClick={() => handleLengthUnitChange('cm')}
                              className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                lengthUnit === 'cm'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                            </button>
                            <button
                              type="button"
                              onClick={() => handleLengthUnitChange('m')}
                              className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                                lengthUnit === 'm'
                                  ? 'bg-teal-500 text-white shadow-lg'
                                  : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                              }`}
                            >
                              Ù…ØªØ± (m)
                            </button>
                          </div>
                        </div>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          Ø¹Ø±Ø¶
                        </label>
                        <div className="space-y-2">
                          <FormattedNumberInput
                            value={productConfig.width || 0}
                            onFocus={() => handleFieldFocus('width', productConfig.width, 0)}
                            onChange={(value) => {
                              setProductConfig(prev => {
                                const updatedConfig = { ...prev, width: value };
                                const smartResult = handleSmartCalculation('width', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                                return {
                                  ...updatedConfig,
                                  length: smartResult.length,
                                  squareMeters: smartResult.squareMeters
                                };
                              });
                            }}
                            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                          min={0}
                          step={0.1}
                          placeholder="Ù…Ù‚Ø¯Ø§Ø± Ø¹Ø±Ø¶"
                        />
                        <div className="flex gap-1">
                          <button
                            type="button"
                            onClick={() => handleWidthUnitChange('cm')}
                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                              widthUnit === 'cm'
                                ? 'bg-teal-500 text-white shadow-lg'
                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                            }`}
                          >
                            Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                          </button>
                          <button
                            type="button"
                            onClick={() => handleWidthUnitChange('m')}
                            className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                              widthUnit === 'm'
                                ? 'bg-teal-500 text-white shadow-lg'
                                : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                            }`}
                          >
                            Ù…ØªØ± (m)
                          </button>
                      </div>
                    </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                          ØªØ¹Ø¯Ø§Ø¯
                        </label>
                        <FormattedNumberInput
                          value={getQuantityDisplayValue()}
                          onFocus={() => handleFieldFocus('quantity', getQuantityDisplayValue(), 0)}
                          onChange={(value) => {
                            const isQuantityCleared = !value || value === 0;
                            if (!hasQuantityBeenInteracted) {
                              setHasQuantityBeenInteracted(true);
                            }
                            if (isQuantityCleared) {
                              setIsMandatory(false);
                              setHasQuantityBeenInteracted(false);
                            } else {
                              setIsMandatory(true);
                            }
                            setProductConfig(prev => {
                              const updatedConfig = { ...prev, quantity: value };
                              const effectiveQuantity = value || 1;
                              const smartResult = handleSmartCalculation('quantity', effectiveQuantity, updatedConfig, lengthUnit, widthUnit, effectiveQuantity);
                              const updatedCuttingCost = calculateAutoCuttingCost(
                                updatedConfig.length,
                                lengthUnit,
                                prev.cuttingCostPerMeter || null,
                                effectiveQuantity
                              );
                              return {
                                ...updatedConfig,
                                squareMeters: smartResult.squareMeters,
                                cuttingCost: updatedCuttingCost
                              };
                            });
                          }}
                          className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                          min={1}
                          placeholder="ØªØ¹Ø¯Ø§Ø¯"
                        />
                      </div>
                        </div>
                      )
                    </div>
                  )}
                  
                  {/* Slab-specific sections */}
                  {productConfig.productType === 'slab' && (() => {
                      const slabCuttingMode = productConfig.slabCuttingMode || 'lineBased';
                      const requestedLengthCm = productConfig.length ? (lengthUnit === 'm' ? productConfig.length * 100 : productConfig.length) : 0;
                      const requestedWidthCm = productConfig.width ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width) : 0;
                      const wantedQuantity = productConfig.quantity || 0;
                      
                      // Get standard dimensions array or initialize empty
                      const standardDimensions = productConfig.slabStandardDimensions || [];
                      
                      // Calculate total quantity from standard dimensions
                      const totalStandardQuantity = standardDimensions.reduce((sum, entry) => sum + (entry.quantity || 0), 0);
                      
                      // Calculate total area for pricing
                      const totalStandardAreaSqm = standardDimensions.reduce((sum, entry) => {
                        return sum + ((entry.standardLengthCm * entry.standardWidthCm * entry.quantity) / 10000);
                      }, 0);
                      
                      // Validation: check if standard dimensions are >= wanted dimensions
                      const validateStandardDimensions = (entry: SlabStandardDimensionEntry): string | null => {
                        if (entry.standardLengthCm < requestedLengthCm) {
                          return `Ø·ÙˆÙ„ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (${entry.standardLengthCm}cm) Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ù…ØªØ± Ø§Ø² Ø·ÙˆÙ„ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ (${requestedLengthCm}cm) Ø¨Ø§Ø´Ø¯`;
                        }
                        if (entry.standardWidthCm < requestedWidthCm) {
                          return `Ø¹Ø±Ø¶ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (${entry.standardWidthCm}cm) Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ú©Ù…ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ (${requestedWidthCm}cm) Ø¨Ø§Ø´Ø¯`;
                        }
                        if (entry.quantity <= 0) {
                          return 'ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² ØµÙØ± Ø¨Ø§Ø´Ø¯';
                        }
                        return null;
                      };
                      
                      // Add new standard dimension entry
                      const handleAddStandardDimension = () => {
                        const newEntry: SlabStandardDimensionEntry = {
                          id: `std_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                          standardLengthCm: requestedLengthCm || 300,
                          standardWidthCm: requestedWidthCm || 200,
                          quantity: 1
                        };
                        setProductConfig(prev => ({
                          ...prev,
                          slabStandardDimensions: [...(prev.slabStandardDimensions || []), newEntry]
                        }));
                      };
                      
                      // Update standard dimension entry
                      const handleUpdateStandardDimension = (id: string, field: keyof SlabStandardDimensionEntry, value: number) => {
                        setProductConfig(prev => {
                          const updated = (prev.slabStandardDimensions || []).map(entry => 
                            entry.id === id ? { ...entry, [field]: value } : entry
                          );
                          return { ...prev, slabStandardDimensions: updated };
                        });
                      };
                      
                      // Remove standard dimension entry
                      const handleRemoveStandardDimension = (id: string) => {
                        setProductConfig(prev => ({
                          ...prev,
                          slabStandardDimensions: (prev.slabStandardDimensions || []).filter(entry => entry.id !== id)
                        }));
                      };
                      
                      return (
                        <div className="space-y-6">
                          {/* Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Section */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-indigo-200 dark:border-indigo-800 shadow-lg overflow-hidden">
                            <div className="bg-gradient-to-r from-indigo-500 to-indigo-600 dark:from-indigo-600 dark:to-indigo-700 px-6 py-4">
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                  <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                    <FaWarehouse className="text-white text-lg" />
                                  </div>
                                  <div>
                                    <h4 className="text-lg font-bold text-white">Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Ø§Ù†Ø¨Ø§Ø±</h4>
                                    <p className="text-xs text-indigo-100">Ø§Ø¨Ø¹Ø§Ø¯ Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± Ø§Ù†Ø¨Ø§Ø± Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯</p>
                                  </div>
                                </div>
                                <button
                                  type="button"
                                  onClick={handleAddStandardDimension}
                                  className="flex items-center gap-2 px-4 py-2.5 text-sm font-semibold text-indigo-700 bg-white rounded-lg hover:bg-indigo-50 transition-all shadow-md hover:shadow-lg transform hover:scale-105"
                                >
                                  <FaPlus className="text-base" />
                                  Ø§ÙØ²ÙˆØ¯Ù† Ø§Ø¨Ø¹Ø§Ø¯
                                </button>
                              </div>
                            </div>
                            
                            <div className="p-6">
                              {standardDimensions.length > 0 ? (
                                <div className="space-y-4">
                                  <div className="overflow-x-auto -mx-6 px-6">
                                    <table className="w-full text-sm">
                                      <thead>
                                        <tr className="bg-indigo-50 dark:bg-indigo-900/30 border-b-2 border-indigo-200 dark:border-indigo-700">
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">Ø·ÙˆÙ„ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (cm)</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">Ø¹Ø±Ø¶ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ (cm)</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">ØªØ¹Ø¯Ø§Ø¯</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">Ù…Ø³Ø§Ø­Øª (mÂ²)</th>
                                          <th className="text-right py-3 px-4 font-semibold text-indigo-900 dark:text-indigo-100">Ø¹Ù…Ù„ÛŒØ§Øª</th>
                                        </tr>
                                      </thead>
                                      <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                                        {standardDimensions.map((entry, index) => {
                                          const validationError = validateStandardDimensions(entry);
                                          const entryAreaSqm = (entry.standardLengthCm * entry.standardWidthCm * entry.quantity) / 10000;
                                          const isValid = !validationError && entry.standardLengthCm >= requestedLengthCm && entry.standardWidthCm >= requestedWidthCm;
                                          
                                          return (
                                            <tr 
                                              key={entry.id} 
                                              className={`transition-colors hover:bg-indigo-50/50 dark:hover:bg-indigo-900/10 ${
                                                validationError 
                                                  ? 'bg-red-50 dark:bg-red-900/20' 
                                                  : isValid 
                                                    ? 'bg-green-50/30 dark:bg-green-900/10' 
                                                    : ''
                                              }`}
                                            >
                                              <td className="py-3 px-4">
                                                <div className="space-y-1">
                                                  <FormattedNumberInput
                                                    value={entry.standardLengthCm}
                                                    onChange={(value) => handleUpdateStandardDimension(entry.id, 'standardLengthCm', value || 0)}
                                                    min={requestedLengthCm}
                                                    className={`w-full px-3 py-2 text-sm border rounded-lg transition-all ${
                                                      validationError && entry.standardLengthCm < requestedLengthCm 
                                                        ? 'border-red-500 bg-red-50 dark:bg-red-900/20' 
                                                        : isValid
                                                          ? 'border-green-500 bg-green-50 dark:bg-green-900/20'
                                                          : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700'
                                                    } focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`}
                                                  />
                                                  {validationError && entry.standardLengthCm < requestedLengthCm && (
                                                    <p className="text-xs text-red-600 dark:text-red-400 flex items-center gap-1">
                                                      <FaTimes className="text-xs" />
                                                      {validationError}
                                                    </p>
                                                  )}
                                                  {isValid && entry.standardLengthCm >= requestedLengthCm && (
                                                    <p className="text-xs text-green-600 dark:text-green-400 flex items-center gap-1">
                                                      <FaCheck className="text-xs" />
                                                      Ù…Ù†Ø§Ø³Ø¨
                                                    </p>
                                                  )}
                                                </div>
                                              </td>
                                              <td className="py-3 px-4">
                                                <div className="space-y-1">
                                                  <FormattedNumberInput
                                                    value={entry.standardWidthCm}
                                                    onChange={(value) => handleUpdateStandardDimension(entry.id, 'standardWidthCm', value || 0)}
                                                    min={requestedWidthCm}
                                                    className={`w-full px-3 py-2 text-sm border rounded-lg transition-all ${
                                                      validationError && entry.standardWidthCm < requestedWidthCm 
                                                        ? 'border-red-500 bg-red-50 dark:bg-red-900/20' 
                                                        : isValid
                                                          ? 'border-green-500 bg-green-50 dark:bg-green-900/20'
                                                          : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700'
                                                    } focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`}
                                                  />
                                                  {validationError && entry.standardWidthCm < requestedWidthCm && (
                                                    <p className="text-xs text-red-600 dark:text-red-400 flex items-center gap-1">
                                                      <FaTimes className="text-xs" />
                                                      {validationError}
                                                    </p>
                                                  )}
                                                  {isValid && entry.standardWidthCm >= requestedWidthCm && (
                                                    <p className="text-xs text-green-600 dark:text-green-400 flex items-center gap-1">
                                                      <FaCheck className="text-xs" />
                                                      Ù…Ù†Ø§Ø³Ø¨
                                                    </p>
                                                  )}
                                                </div>
                                              </td>
                                              <td className="py-3 px-4">
                                                <FormattedNumberInput
                                                  value={entry.quantity}
                                                  onChange={(value) => handleUpdateStandardDimension(entry.id, 'quantity', value || 0)}
                                                  min={1}
                                                  className={`w-full px-3 py-2 text-sm border rounded-lg ${
                                                    validationError && entry.quantity <= 0 
                                                      ? 'border-red-500 bg-red-50 dark:bg-red-900/20' 
                                                      : 'border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700'
                                                  } focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`}
                                                />
                                              </td>
                                              <td className="py-3 px-4">
                                                <div className="text-sm font-semibold text-gray-700 dark:text-gray-300">
                                                  {formatSquareMeters(entryAreaSqm)}
                                                </div>
                                              </td>
                                              <td className="py-3 px-4">
                                                <button
                                                  type="button"
                                                  onClick={() => handleRemoveStandardDimension(entry.id)}
                                                  className="p-2 text-red-600 dark:text-red-400 hover:text-white hover:bg-red-600 dark:hover:bg-red-700 rounded-lg transition-all"
                                                  title="Ø­Ø°Ù"
                                                >
                                                  <FaTrash className="text-base" />
                                                </button>
                                              </td>
                                            </tr>
                                          );
                                        })}
                                      </tbody>
                                    </table>
                                  </div>
                                  
                                  {/* Summary Footer */}
                                  <div className="bg-gradient-to-r from-indigo-50 to-blue-50 dark:from-indigo-900/30 dark:to-blue-900/30 rounded-lg p-4 border border-indigo-200 dark:border-indigo-700">
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-3">
                                      <div className="bg-white dark:bg-gray-800 rounded-lg p-3 border border-indigo-200 dark:border-indigo-700">
                                        <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ù…Ø¬Ù…ÙˆØ¹ ØªØ¹Ø¯Ø§Ø¯</p>
                                        <p className={`text-xl font-bold ${totalStandardQuantity === wantedQuantity ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                                          {totalStandardQuantity}
                                        </p>
                                        <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">Ø§Ø² {wantedQuantity} Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²</p>
                                      </div>
                                      <div className="bg-white dark:bg-gray-800 rounded-lg p-3 border border-indigo-200 dark:border-indigo-700">
                                        <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ù…Ø¬Ù…ÙˆØ¹ Ù…Ø³Ø§Ø­Øª</p>
                                        <p className="text-xl font-bold text-indigo-600 dark:text-indigo-400">
                                          {formatSquareMeters(totalStandardAreaSqm)}
                                        </p>
                                      </div>
                                      <div className="bg-white dark:bg-gray-800 rounded-lg p-3 border border-indigo-200 dark:border-indigo-700">
                                        <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">ÙˆØ¶Ø¹ÛŒØª</p>
                                        {totalStandardQuantity === wantedQuantity ? (
                                          <div className="flex items-center gap-2">
                                            <FaCheck className="text-green-600 dark:text-green-400" />
                                            <span className="text-sm font-semibold text-green-600 dark:text-green-400">ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§ÙÛŒ Ø§Ø³Øª</span>
                                          </div>
                                        ) : totalStandardQuantity < wantedQuantity ? (
                                          <div className="flex items-center gap-2">
                                            <FaTimes className="text-red-600 dark:text-red-400" />
                                            <span className="text-sm font-semibold text-red-600 dark:text-red-400">
                                              {wantedQuantity - totalStandardQuantity} Ø¹Ø¯Ø¯ Ú©Ù… Ø§Ø³Øª
                                            </span>
                                          </div>
                                        ) : (
                                          <div className="flex items-center gap-2">
                                            <FaTimes className="text-orange-600 dark:text-orange-400" />
                                            <span className="text-sm font-semibold text-orange-600 dark:text-orange-400">
                                              {totalStandardQuantity - wantedQuantity} Ø¹Ø¯Ø¯ Ø§Ø¶Ø§ÙÙ‡
                                            </span>
                                          </div>
                                        )}
                                      </div>
                                    </div>
                                  </div>
                                </div>
                              ) : (
                                <div className="text-center py-12">
                                  <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-indigo-100 dark:bg-indigo-900/30 flex items-center justify-center">
                                    <FaWarehouse className="text-2xl text-indigo-500 dark:text-indigo-400" />
                                  </div>
                                  <p className="text-gray-600 dark:text-gray-400 mb-2">Ù‡Ù†ÙˆØ² Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª</p>
                                  <p className="text-sm text-gray-500 dark:text-gray-500">Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ Ø¯Ú©Ù…Ù‡ "Ø§ÙØ²ÙˆØ¯Ù† Ø§Ø¨Ø¹Ø§Ø¯" Ø±Ø§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯</p>
                                </div>
                              )}
                            </div>
                          </div>

                          {/* Ù†ÙˆØ¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø±Ø´ Section */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-indigo-200 dark:border-indigo-800 shadow-lg overflow-hidden">
                            <div className="bg-gradient-to-r from-purple-500 to-purple-600 dark:from-purple-600 dark:to-purple-700 px-6 py-4">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                  <FaTools className="text-white text-lg" />
                                </div>
                                <div>
                                  <h4 className="text-lg font-bold text-white">Ù†ÙˆØ¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø±Ø´</h4>
                                  <p className="text-xs text-purple-100">Ø±ÙˆØ´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</p>
                                </div>
                              </div>
                            </div>
                            
                            <div className="p-6">
                              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <button
                                  type="button"
                                  onClick={() => setProductConfig(prev => ({ ...prev, slabCuttingMode: 'perSquareMeter' }))}
                                  className={`relative p-5 rounded-xl border-2 transition-all transform hover:scale-105 ${
                                    slabCuttingMode === 'perSquareMeter'
                                      ? 'bg-gradient-to-br from-indigo-500 to-indigo-600 text-white border-indigo-600 shadow-xl'
                                      : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:border-indigo-400 dark:hover:border-indigo-500'
                                  }`}
                                >
                                  {slabCuttingMode === 'perSquareMeter' && (
                                    <div className="absolute top-3 right-3">
                                      <div className="w-6 h-6 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                        <FaCheck className="text-white text-sm" />
                                      </div>
                                    </div>
                                  )}
                                  <div className="text-center">
                                    <div className={`w-12 h-12 mx-auto mb-3 rounded-lg flex items-center justify-center ${
                                      slabCuttingMode === 'perSquareMeter' ? 'bg-white/20' : 'bg-indigo-100 dark:bg-indigo-900/30'
                                    }`}>
                                      <FaSquare className={`text-2xl ${slabCuttingMode === 'perSquareMeter' ? 'text-white' : 'text-indigo-600 dark:text-indigo-400'}`} />
                                    </div>
                                    <h5 className="font-bold text-lg mb-1">Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ØªØ± Ù…Ø±Ø¨Ø¹</h5>
                                    <p className="text-xs opacity-90">Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ø³Ø§Ø­Øª Ù‚Ø·Ø¹Ù‡ Ù†Ù‡Ø§ÛŒÛŒ</p>
                                  </div>
                                </button>
                                
                                <button
                                  type="button"
                                  onClick={() => setProductConfig(prev => ({ ...prev, slabCuttingMode: 'lineBased' }))}
                                  className={`relative p-5 rounded-xl border-2 transition-all transform hover:scale-105 ${
                                    slabCuttingMode === 'lineBased'
                                      ? 'bg-gradient-to-br from-indigo-500 to-indigo-600 text-white border-indigo-600 shadow-xl'
                                      : 'bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-600 hover:border-indigo-400 dark:hover:border-indigo-500'
                                  }`}
                                >
                                  {slabCuttingMode === 'lineBased' && (
                                    <div className="absolute top-3 right-3">
                                      <div className="w-6 h-6 rounded-full bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                        <FaCheck className="text-white text-sm" />
                                      </div>
                                    </div>
                                  )}
                                  <div className="text-center">
                                    <div className={`w-12 h-12 mx-auto mb-3 rounded-lg flex items-center justify-center ${
                                      slabCuttingMode === 'lineBased' ? 'bg-white/20' : 'bg-indigo-100 dark:bg-indigo-900/30'
                                    }`}>
                                      <FaRuler className={`text-2xl ${slabCuttingMode === 'lineBased' ? 'text-white' : 'text-indigo-600 dark:text-indigo-400'}`} />
                                    </div>
                                    <h5 className="font-bold text-lg mb-1">Ø¨Ø± Ø§Ø³Ø§Ø³ Ø®Ø·ÙˆØ·</h5>
                                    <p className="text-xs opacity-90">Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø·ÙˆÙ„ Ø®Ø·ÙˆØ· Ø¨Ø±Ø´</p>
                                  </div>
                                </button>
                              </div>
                              
                              {slabCuttingMode === 'perSquareMeter' ? (
                                <div className="bg-indigo-50 dark:bg-indigo-900/20 rounded-lg p-4 border border-indigo-200 dark:border-indigo-700">
                                  <label className="block text-sm font-semibold text-indigo-900 dark:text-indigo-100 mb-2">
                                    Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (ØªÙˆÙ…Ø§Ù†)
                                  </label>
                                  <FormattedNumberInput
                                    value={productConfig.slabCuttingPricePerSquareMeter || 0}
                                    onChange={(value) => setProductConfig(prev => ({ ...prev, slabCuttingPricePerSquareMeter: value || 0 }))}
                                    min={0}
                                    placeholder="Ù…Ø«Ù„Ø§Ù‹ 150,000"
                                    className="w-full px-4 py-3 text-base border-2 border-indigo-300 dark:border-indigo-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                  />
                                  <p className="text-xs text-indigo-700 dark:text-indigo-300 mt-2 flex items-center gap-1">
                                    <FaSquare className="text-xs" />
                                    Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ù‚Ø·Ø¹Ù‡ Ù†Ù‡Ø§ÛŒÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                  </p>
                                </div>
                              ) : (
                                <div className="bg-indigo-50 dark:bg-indigo-900/20 rounded-lg p-4 border border-indigo-200 dark:border-indigo-700">
                                  <p className="text-sm text-indigo-800 dark:text-indigo-200 mb-3 leading-relaxed">
                                    Ø¯Ø± Ø§ÛŒÙ† Ø­Ø§Ù„Øª Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø·ÙˆÙ„ Ø®Ø·ÙˆØ· Ø·ÙˆÙ„ÛŒ Ùˆ Ø¹Ø±Ø¶ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø·ÙˆÙ„ Ø¨Ø±Ø´ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø¹Ø¯ÛŒ Ø§Ø³Øª Ú©Ù‡ Ø¨Ù‡ Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ± Ø¨Ø§Ø´Ø¯ Ùˆ Ø¨Ø±Ø´ Ø¯ÛŒÚ¯Ø± Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¨Ø¹Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø¯.
                                  </p>
                                  {(() => {
                                    if (standardDimensions.length > 0 && requestedLengthCm > 0 && requestedWidthCm > 0) {
                                      const firstEntry = standardDimensions[0];
                                      const linePlanPreview = determineSlabLineCutPlan({
                                        requestedLengthCm,
                                        requestedWidthCm,
                                        standardLengthCm: firstEntry.standardLengthCm,
                                        standardWidthCm: firstEntry.standardWidthCm
                                      });
                                      return (
                                        <div className="bg-white dark:bg-gray-800 rounded-lg p-4 border-2 border-indigo-300 dark:border-indigo-600">
                                          <p className="font-semibold mb-3 text-indigo-900 dark:text-indigo-100 flex items-center gap-2">
                                            <FaRuler className="text-indigo-600 dark:text-indigo-400" />
                                            Ø®Ù„Ø§ØµÙ‡ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø®Ø·ÙˆØ· (Ù†Ù…ÙˆÙ†Ù‡ Ø¨Ø±Ø§ÛŒ Ø§ÙˆÙ„ÛŒÙ† Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯)
                                          </p>
                                          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3">
                                              <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ø¨Ø±Ø´ Ø§ØµÙ„ÛŒ</p>
                                              <p className="font-bold text-indigo-700 dark:text-indigo-300">
                                                {linePlanPreview.axisUsingStandard === 'length' ? 'Ø·ÙˆÙ„' : 'Ø¹Ø±Ø¶'}
                                              </p>
                                            </div>
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3">
                                              <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ø®Ø·ÙˆØ· Ø·ÙˆÙ„ÛŒ</p>
                                              <p className="font-bold text-indigo-700 dark:text-indigo-300">
                                                {formatDisplayNumber(linePlanPreview.longitudinalMeters)} m
                                              </p>
                                            </div>
                                            <div className="bg-indigo-50 dark:bg-indigo-900/30 rounded-lg p-3">
                                              <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ø®Ø·ÙˆØ· Ø¹Ø±Ø¶ÛŒ</p>
                                              <p className="font-bold text-indigo-700 dark:text-indigo-300">
                                                {formatDisplayNumber(linePlanPreview.crossMeters)} m
                                              </p>
                                            </div>
                                          </div>
                                          {standardDimensions.length > 1 && (
                                            <div className="mt-3 pt-3 border-t border-indigo-200 dark:border-indigo-700">
                                              <p className="text-xs text-indigo-600 dark:text-indigo-400 flex items-center gap-1">
                                                <FaTimes className="text-xs" />
                                                ØªÙˆØ¬Ù‡: Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø¨Ù‡ ØµÙˆØ±Øª Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                              </p>
                                            </div>
                                          )}
                                        </div>
                                      );
                                    }
                                    return null;
                                  })()}
                                </div>
                              )}
                            </div>
                          </div>

                          {/* Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… Section - 4 Side Edge Cuts */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-teal-200 dark:border-teal-800 shadow-lg overflow-hidden">
                            <div className="bg-gradient-to-r from-teal-500 to-teal-600 dark:from-teal-600 dark:to-teal-700 px-6 py-4">
                              <div className="flex items-center gap-3">
                                <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                  <FaRuler className="text-white text-lg" />
                                </div>
                                <div>
                                  <h4 className="text-lg font-bold text-white">Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… (Ù¾Ø±Ø¯Ø§Ø®Øª Ù„Ø¨Ù‡â€ŒÙ‡Ø§)</h4>
                                  <p className="text-xs text-teal-100">Ø§Ù†ØªØ®Ø§Ø¨ Ù„Ø¨Ù‡â€ŒÙ‡Ø§ÛŒÛŒ Ú©Ù‡ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… Ø¯Ø§Ø±Ù†Ø¯</p>
                                </div>
                              </div>
                            </div>
                            
                            <div className="p-6">
                              <p className="text-sm text-gray-700 dark:text-gray-300 mb-4 leading-relaxed">
                                Ù‡Ø± Ø³Ù†Ú¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø§Ø³Ù„Ø¨ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… Ø±ÙˆÛŒ Ù„Ø¨Ù‡â€ŒÙ‡Ø§ Ø¯Ø§Ø±Ø¯ ØªØ§ ØªÙ…Ø§Ù… Ù„Ø¨Ù‡â€ŒÙ‡Ø§ ØµØ§Ù Ùˆ Ø¯Ù‚ÛŒÙ‚ Ø´ÙˆÙ†Ø¯ Ùˆ Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø´â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø§Ø´Ù†Ø¯.
                              </p>
                              
                              {/* Visual representation of slab with 4 sides */}
                              <div className="bg-gradient-to-br from-teal-50 to-cyan-50 dark:from-teal-900/20 dark:to-cyan-900/20 rounded-xl p-6 border-2 border-teal-200 dark:border-teal-700 mb-4">
                                <div className="relative mx-auto" style={{ width: '200px', height: '150px' }}>
                                  {/* Slab representation */}
                                  <div className="absolute inset-0 bg-white dark:bg-gray-700 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-md"></div>
                                  
                                  {/* Top side checkbox */}
                                  <div className="absolute -top-3 left-1/2 transform -translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.top !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: e.target.checked,
                                            bottom: prev.slabVerticalCutSides?.bottom !== false,
                                            left: prev.slabVerticalCutSides?.left !== false,
                                            right: prev.slabVerticalCutSides?.right !== false
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">Ø¨Ø§Ù„Ø§</span>
                                    </label>
                                  </div>
                                  
                                  {/* Bottom side checkbox */}
                                  <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.bottom !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: prev.slabVerticalCutSides?.top !== false,
                                            bottom: e.target.checked,
                                            left: prev.slabVerticalCutSides?.left !== false,
                                            right: prev.slabVerticalCutSides?.right !== false
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">Ù¾Ø§ÛŒÛŒÙ†</span>
                                    </label>
                                  </div>
                                  
                                  {/* Left side checkbox */}
                                  <div className="absolute left-0 top-1/2 transform -translate-y-1/2 -translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.left !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: prev.slabVerticalCutSides?.top !== false,
                                            bottom: prev.slabVerticalCutSides?.bottom !== false,
                                            left: e.target.checked,
                                            right: prev.slabVerticalCutSides?.right !== false
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">Ú†Ù¾</span>
                                    </label>
                                  </div>
                                  
                                  {/* Right side checkbox */}
                                  <div className="absolute right-0 top-1/2 transform -translate-y-1/2 translate-x-1/2">
                                    <label className="flex items-center gap-2 cursor-pointer bg-white dark:bg-gray-800 px-3 py-1.5 rounded-lg border-2 border-teal-300 dark:border-teal-600 shadow-sm hover:shadow-md transition-all">
                                      <input
                                        type="checkbox"
                                        checked={productConfig.slabVerticalCutSides?.right !== false}
                                        onChange={(e) => setProductConfig(prev => ({
                                          ...prev,
                                          slabVerticalCutSides: {
                                            top: prev.slabVerticalCutSides?.top !== false,
                                            bottom: prev.slabVerticalCutSides?.bottom !== false,
                                            left: prev.slabVerticalCutSides?.left !== false,
                                            right: e.target.checked
                                          }
                                        }))}
                                        className="w-4 h-4 text-teal-600 rounded focus:ring-teal-500"
                                      />
                                      <span className="text-sm font-semibold text-gray-700 dark:text-gray-300">Ø±Ø§Ø³Øª</span>
                                    </label>
                                  </div>
                                </div>
                              </div>
                              
                              {/* Cost preview */}
                              {(() => {
                                const verticalCutSides = productConfig.slabVerticalCutSides || { top: true, bottom: true, left: true, right: true };
                                const activeSides = Object.values(verticalCutSides).filter(Boolean).length;
                                const hasActiveSides = activeSides > 0;
                                const verticalCutCostPerMeter = getCuttingTypePricePerMeter('VERTICAL') || getCuttingTypePricePerMeter('LONG') || 0;
                                
                                // Calculate Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… for each standard dimension entry
                                let totalMeters = 0;
                                let totalEstimatedCost = 0;
                                
                                if (hasActiveSides && verticalCutCostPerMeter > 0 && standardDimensions.length > 0) {
                                  // Loop through each standard dimension entry
                                  for (const entry of standardDimensions) {
                                    // Calculate perimeter for this entry based on standard dimensions
                                    let entryMeters = 0;
                                    if (verticalCutSides.top) entryMeters += entry.standardWidthCm / 100; // width in meters
                                    if (verticalCutSides.bottom) entryMeters += entry.standardWidthCm / 100;
                                    if (verticalCutSides.left) entryMeters += entry.standardLengthCm / 100; // length in meters
                                    if (verticalCutSides.right) entryMeters += entry.standardLengthCm / 100;
                                    
                                    // Multiply by quantity for this entry
                                    const entryTotalMeters = entryMeters * entry.quantity;
                                    totalMeters += entryTotalMeters;
                                    
                                    // Calculate cost for this entry
                                    const entryCost = entryTotalMeters * verticalCutCostPerMeter;
                                    totalEstimatedCost += entryCost;
                                  }
                                }
                                
                                if (hasActiveSides && totalMeters > 0 && verticalCutCostPerMeter > 0) {
                                  return (
                                    <div className="bg-teal-50 dark:bg-teal-900/20 rounded-lg p-4 border border-teal-200 dark:border-teal-700">
                                      <div className="flex items-center justify-between mb-2">
                                        <p className="text-sm font-semibold text-teal-900 dark:text-teal-100">
                                          Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ù‚Ø§Ø¦Ù… (Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´)
                                        </p>
                                        <span className="text-xs text-teal-700 dark:text-teal-300">
                                          {activeSides} Ù„Ø¨Ù‡ ÙØ¹Ø§Ù„
                                        </span>
                                      </div>
                                      <div className="grid grid-cols-2 gap-3 text-sm">
                                        <div>
                                          <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ù…Ø¬Ù…ÙˆØ¹ Ø·ÙˆÙ„ Ù„Ø¨Ù‡â€ŒÙ‡Ø§</p>
                                          <p className="font-bold text-teal-700 dark:text-teal-300">
                                            {formatDisplayNumber(totalMeters)} Ù…ØªØ±
                                          </p>
                                        </div>
                                        <div>
                                          <p className="text-xs text-gray-600 dark:text-gray-400 mb-1">Ù‡Ø²ÛŒÙ†Ù‡ Ú©Ù„</p>
                                          <p className="font-bold text-teal-700 dark:text-teal-300">
                                            {formatPrice(totalEstimatedCost, 'ØªÙˆÙ…Ø§Ù†')}
                                          </p>
                                        </div>
                                      </div>
                                      {standardDimensions.length > 1 && (
                                        <div className="mt-3 pt-3 border-t border-teal-200 dark:border-teal-700">
                                          <p className="text-xs text-teal-600 dark:text-teal-400 flex items-center gap-1">
                                            <FaTimes className="text-xs" />
                                            Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø¨Ù‡ ØµÙˆØ±Øª Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯.
                                          </p>
                                        </div>
                                      )}
                        </div>
                      );
                                }
                                return null;
                              })()}
                            </div>
                          </div>

                          {/* CAD Designer Section */}
                          <div className="bg-white dark:bg-gray-800 rounded-xl border-2 border-indigo-200 dark:border-indigo-800 shadow-lg overflow-hidden mt-6">
                            <div className="bg-gradient-to-r from-indigo-500 to-indigo-600 dark:from-indigo-600 dark:to-indigo-700 px-6 py-4">
                              <div className="flex items-center justify-between">
                                <div className="flex items-center gap-3">
                                  <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                                    <FaRuler className="text-white text-lg" />
                                  </div>
                                  <div>
                                    <h4 className="text-lg font-bold text-white">Ø§Ø¨Ø²Ø§Ø± Ø·Ø±Ø§Ø­ÛŒ CAD</h4>
                                    <p className="text-xs text-indigo-100">Ø·Ø±Ø§Ø­ÛŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¨Ø±Ø´â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¨ØµØ±ÛŒ</p>
                                  </div>
                                </div>
                                <button
                                  type="button"
                                  onClick={() => setShowCADDesigner(!showCADDesigner)}
                                  className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg transition-colors text-sm font-medium"
                                >
                                  {showCADDesigner ? 'Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù†' : 'Ù†Ù…Ø§ÛŒØ´'}
                                </button>
                              </div>
                            </div>
                            
                            {showCADDesigner && (
                              <div className="p-6">
                                <p className="text-sm text-gray-700 dark:text-gray-300 mb-4 leading-relaxed">
                                  Ø§Ø² Ø§ÛŒÙ† Ø§Ø¨Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø·Ø±Ø§Ø­ÛŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø¨Ø±Ø´â€ŒÙ‡Ø§ Ø±ÙˆÛŒ Ø³Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø¨Ø¹Ø§Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø±Ø³Ù… Ú©Ù†ÛŒØ¯ Ùˆ Ù‡Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
                                </p>
                                
                                {standardDimensions && standardDimensions.length > 0 ? (
                                  <StoneCADDesigner
                                    originalLength={productConfig.length || 0}
                                    originalWidth={productConfig.width || 0}
                                    lengthUnit={lengthUnit}
                                    widthUnit={widthUnit}
                                    standardDimensions={standardDimensions}
                                    productType="slab"
                                    mode="design"
                                    enableCostCalculation={true}
                                    enableAutoSync={true}
                                    onDimensionsCalculated={(dims) => {
                                      // Sync CAD dimensions with product config
                                      if (dims.length && dims.width) {
                                        setProductConfig(prev => ({
                                          ...prev,
                                          length: dims.length,
                                          width: dims.width,
                                          squareMeters: dims.squareMeters
                                        }));
                                      }
                                    }}
                                    onCostCalculated={(cost) => {
                                      // Update cutting cost in product config
                                      setProductConfig(prev => ({
                                        ...prev,
                                        cuttingCost: cost
                                      }));
                                    }}
                                    onDesignChange={(design) => {
                                      // Store CAD design for later use
                                      setProductConfig(prev => ({
                                        ...prev,
                                        cadDesign: design
                                      }));
                                    }}
                                    initialDesign={productConfig.cadDesign || null}
                                  />
                                ) : (
                                  <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
                                    <p className="text-sm text-yellow-800 dark:text-yellow-200">
                                      Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø§Ø¨Ø¹Ø§Ø¯ Ø§Ø³ØªØ§Ù†Ø¯Ø§Ø±Ø¯ Ø±Ø§ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯ ØªØ§ Ø¨ØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ø§Ø¨Ø²Ø§Ø± Ø·Ø±Ø§Ø­ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.
                                    </p>
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })()}
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        ØªØ¹Ø¯Ø§Ø¯
                      </label>
                      <FormattedNumberInput
                        value={getQuantityDisplayValue()}
                        onFocus={() => handleFieldFocus('quantity', getQuantityDisplayValue(), 0)}
                        onChange={(value) => {
                          // Check if quantity is being cleared/deleted (empty or 0)
                          const isQuantityCleared = !value || value === 0;
                          
                          // Mark quantity as interacted
                          if (!hasQuantityBeenInteracted) {
                            setHasQuantityBeenInteracted(true);
                            console.log('ğŸ¯ Quantity First Interaction');
                          }
                          
                          // Handle mandatory pricing based on quantity state
                          if (isQuantityCleared) {
                            // If quantity is cleared, uncheck mandatory pricing and reset interaction state
                            setIsMandatory(false);
                            setHasQuantityBeenInteracted(false);
                            console.log('ğŸ”„ Quantity Cleared - Deactivating mandatory pricing and resetting interaction state');
                          } else {
                            // If quantity has a value, activate mandatory pricing
                            setIsMandatory(true);
                            console.log('âœ… Quantity Has Value - Activating mandatory pricing');
                          }
                          
                          // Update the quantity
                          setProductConfig(prev => {
                            const updatedConfig = { ...prev, quantity: value };
                            // Use effective quantity for calculations
                            const effectiveQuantity = value || 1;
                            // Trigger smart calculation with effective quantity
                            const smartResult = handleSmartCalculation('quantity', effectiveQuantity, updatedConfig, lengthUnit, widthUnit, effectiveQuantity);
                            
                            // Recalculate cutting cost automatically using helper function
                            const updatedCuttingCost = calculateAutoCuttingCost(
                              updatedConfig.length,
                              lengthUnit,
                              prev.cuttingCostPerMeter || null,
                              effectiveQuantity
                            );
                            
                            return {
                              ...updatedConfig,
                              squareMeters: smartResult.squareMeters,
                              cuttingCost: updatedCuttingCost
                            };
                          });
                          
                          console.log('ğŸ“Š Quantity Changed:', {
                            displayValue: value,
                            effectiveQuantity: value || 1,
                            isQuantityCleared,
                            hasBeenInteracted: !isQuantityCleared,
                            mandatoryActivated: !isQuantityCleared
                          });
                        }}
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                        min={1}
                        placeholder="ØªØ¹Ø¯Ø§Ø¯"
                      />
                    </div>
                  </>)}

                  {/* Unit Selection Help Text - Only for slab/longitudinal */}
                  {(productConfig.productType === 'longitudinal' || productConfig.productType === 'slab') && (
                    <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                      <p className="text-sm text-blue-700 dark:text-blue-300">
                        <strong>Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ÙˆØ§Ø­Ø¯:</strong> Ø¨Ø±Ø§ÛŒ Ù‡Ø± ÙÛŒÙ„Ø¯ Ø·ÙˆÙ„ Ùˆ Ø¹Ø±Ø¶ØŒ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ "Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ±" ÛŒØ§ "Ù…ØªØ±" Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØªØ§ ÙˆØ§Ø­Ø¯ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯. 
                        Ø¯Ú©Ù…Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ø¨Ø§ Ø±Ù†Ú¯ Ø¢Ø¨ÛŒ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø³ÛŒØ³ØªÙ… Ø¨Ù‡ Ø·ÙˆØ± Ø®ÙˆØ¯Ú©Ø§Ø± Ù…Ø­Ø§Ø³Ø¨Ø§Øª Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.
                      </p>
                    </div>
                  )}

                  {/* Slab 2D Cutting Info Cards */}
                  {productConfig.productType === 'slab' && selectedProduct && (() => {
                    const { standardLengthCm, standardWidthCm } = getSlabStandardDimensions();
                    const originalWidth = standardWidthCm || selectedProduct.widthValue || 0;
                    const originalLengthCm = standardLengthCm || (selectedProduct as any)?.lengthValue || 300;
                    
                    const userWidthInCm = productConfig.width 
                      ? (widthUnit === 'm' ? productConfig.width * 100 : productConfig.width)
                      : 0;
                    const userLengthInCm = productConfig.length 
                      ? (lengthUnit === 'm' ? productConfig.length * 100 : productConfig.length)
                      : 0;
                    const needsLongitudinalCut = userWidthInCm > 0 && userWidthInCm < originalWidth && originalWidth > 0;
                    const needsCrossCut = userLengthInCm > 0 && userLengthInCm < originalLengthCm && originalLengthCm > 0;
                    const hasCuts = needsLongitudinalCut || needsCrossCut;
                    const slabCuttingMode = productConfig.slabCuttingMode || 'lineBased';
                    const effectiveQuantity = getEffectiveQuantity();
                    const linePlan = determineSlabLineCutPlan({
                      requestedLengthCm: userLengthInCm,
                      requestedWidthCm: userWidthInCm,
                      standardLengthCm,
                      standardWidthCm
                    });
                    
                    const requestedAreaSqm = productConfig.squareMeters && productConfig.squareMeters > 0
                      ? productConfig.squareMeters
                      : (userLengthInCm > 0 && userWidthInCm > 0
                          ? (userLengthInCm * userWidthInCm * effectiveQuantity) / 10000
                          : 0);
                    
                    const cuttingCostPerMeterLongitudinal = needsLongitudinalCut ? (getCuttingTypePricePerMeter('LONG') || 0) : 0;
                    const cuttingCostPerMeterCross = needsCrossCut ? (getCuttingTypePricePerMeter('CROSS') || getCuttingTypePricePerMeter('LONG') || 0) : 0;
                    
                    const longitudinalCuttingCost = needsLongitudinalCut && slabCuttingMode === 'lineBased' && cuttingCostPerMeterLongitudinal > 0
                      ? linePlan.longitudinalMeters * cuttingCostPerMeterLongitudinal * effectiveQuantity
                      : 0;
                    const crossCuttingCost = needsCrossCut && slabCuttingMode === 'lineBased' && cuttingCostPerMeterCross > 0
                      ? linePlan.crossMeters * cuttingCostPerMeterCross * effectiveQuantity
                      : 0;
                    const totalCuttingCost = slabCuttingMode === 'lineBased' ? (longitudinalCuttingCost + crossCuttingCost) : 0;
                    
                    const remainingWidth = originalWidth - userWidthInCm;
                    const remainingLength = originalLengthCm - userLengthInCm;
                    const remainingPiecesCount = (remainingWidth > 0 ? 1 : 0) + (remainingLength > 0 ? 1 : 0) + (remainingWidth > 0 && remainingLength > 0 ? 1 : 0);
                    const showLineCard = slabCuttingMode === 'lineBased' && hasCuts && productConfig.length && productConfig.width;
                    
                    if (!showLineCard && slabCuttingMode === 'lineBased' && !requestedAreaSqm) {
                      return null;
                    }
                    
                    return (
                      <div className="space-y-3">
                        {slabCuttingMode === 'perSquareMeter' ? (
                          <div className="bg-indigo-50 dark:bg-indigo-900/20 border border-indigo-200 dark:border-indigo-800 rounded-lg p-4">
                            <div className="flex items-center gap-2 mb-2">
                              <div className="w-2 h-2 rounded-full bg-indigo-500"></div>
                              <h5 className="text-sm font-semibold text-indigo-800 dark:text-indigo-200">
                                Ø¨Ø±Ø´ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…ØªØ± Ù…Ø±Ø¨Ø¹
                              </h5>
                            </div>
                            <p className="text-xs text-indigo-700 dark:text-indigo-300">
                              {requestedAreaSqm > 0
                                ? `Ù…Ø³Ø§Ø­Øª Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ: ${formatSquareMeters(requestedAreaSqm)}`
                                : 'Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¯Ù‚ÛŒÙ‚ØŒ Ø·ÙˆÙ„ Ùˆ Ø¹Ø±Ø¶ Ø¯Ø±Ø®ÙˆØ§Ø³ØªÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.'}
                            </p>
                            {productConfig.slabCuttingPricePerSquareMeter ? (
                              <p className="text-xs text-indigo-700 dark:text-indigo-300 mt-1">
                                Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´: {formatPrice(productConfig.slabCuttingPricePerSquareMeter)} Ã— {formatSquareMeters(requestedAreaSqm || 0)}
                              </p>
                            ) : (
                              <p className="text-xs text-indigo-500 dark:text-indigo-200 mt-1">
                                Ù„Ø·ÙØ§Ù‹ Ù‡Ø²ÛŒÙ†Ù‡ Ø¨Ø±Ø´ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.
                              </p>
                            )}
                          </div>
                        ) : showLineCard ? (
                        <div className="bg-indigo-50 dark:bg-indigo-900/20 border border-indigo-200 dark:border-indigo-800 rounded-lg p-4">
                          <div className="flex items-center gap-2 mb-2">
                            <div className="w-2 h-2 rounded-full bg-indigo-500"></div>
                            <h5 className="text-sm font-semibold text-indigo-800 dark:text-indigo-200">
                              Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø±Ø´ Ø¯Ùˆ Ø¨Ø¹Ø¯ÛŒ
                            </h5>
                          </div>
                          <div className="space-y-2 text-xs text-indigo-700 dark:text-indigo-300">
                            {needsLongitudinalCut && (
                              <div>
                                <span className="font-medium">Ø¨Ø±Ø´ Ø·ÙˆÙ„ÛŒ:</span> Ø¹Ø±Ø¶ {formatDisplayNumber(originalWidth)}cm â†’ {formatDisplayNumber(userWidthInCm)}cm
                                {cuttingCostPerMeterLongitudinal > 0 && (
                                  <span className="ml-2">
                                      ({formatDisplayNumber(linePlan.longitudinalMeters)} m Ã— {formatPrice(cuttingCostPerMeterLongitudinal)} = {formatPrice(longitudinalCuttingCost)})
                                  </span>
                                )}
                              </div>
                            )}
                            {needsCrossCut && (
                              <div>
                                <span className="font-medium">{needsLongitudinalCut ? 'Ø¨Ø±Ø´ Ø¹Ø±Ø¶ÛŒ' : 'Ø¨Ø±Ø´ Ú©Ù„Ù‡ Ø¨Ø±'}:</span> Ø·ÙˆÙ„ {formatDisplayNumber(originalLengthCm)}cm â†’ {formatDisplayNumber(userLengthInCm)}cm
                                {cuttingCostPerMeterCross > 0 && (
                                  <span className="ml-2">
                                      ({formatDisplayNumber(linePlan.crossMeters)} m Ã— {formatPrice(cuttingCostPerMeterCross)} = {formatPrice(crossCuttingCost)})
                                  </span>
                                )}
                              </div>
                            )}
                            {totalCuttingCost > 0 && (
                              <div className="mt-2 pt-2 border-t border-indigo-200 dark:border-indigo-700">
                                <span className="font-semibold">Ù‡Ø²ÛŒÙ†Ù‡ Ú©Ù„ Ø¨Ø±Ø´: {formatPrice(totalCuttingCost)}</span>
                              </div>
                            )}
                          </div>
                        </div>
                        ) : null}
                        
                        {hasCuts && productConfig.length && productConfig.width && remainingPiecesCount > 0 && (
                          <div className="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
                            <div className="flex items-center gap-2 mb-2">
                              <div className="w-2 h-2 rounded-full bg-amber-500"></div>
                              <h5 className="text-sm font-semibold text-amber-800 dark:text-amber-200">
                                Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ù„Ø¨ ({remainingPiecesCount} Ù‚Ø·Ø¹Ù‡)
                              </h5>
                            </div>
                            <div className="space-y-1 text-xs text-amber-700 dark:text-amber-300">
                              {remainingWidth > 0 && userLengthInCm > 0 && (
                                <div>
                                  â€¢ Ù‚Ø·Ø¹Ù‡ Ø¹Ø±Ø¶ÛŒ: {formatDisplayNumber(remainingWidth)}cm Ã— {formatDisplayNumber(userLengthInCm)}cm
                                  <span className="text-amber-600 dark:text-amber-400 ml-1">
                                    ({formatSquareMeters((remainingWidth * userLengthInCm * effectiveQuantity) / 10000)})
                                  </span>
                                </div>
                              )}
                              {remainingLength > 0 && userWidthInCm > 0 && (
                                <div>
                                  â€¢ Ù‚Ø·Ø¹Ù‡ Ø·ÙˆÙ„ÛŒ: {formatDisplayNumber(userWidthInCm)}cm Ã— {formatDisplayNumber(remainingLength)}cm
                                  <span className="text-amber-600 dark:text-amber-400 ml-1">
                                    ({formatSquareMeters((userWidthInCm * remainingLength * effectiveQuantity) / 10000)})
                                  </span>
                                </div>
                              )}
                              {remainingWidth > 0 && remainingLength > 0 && (
                                <div>
                                  â€¢ Ù‚Ø·Ø¹Ù‡ Ú¯ÙˆØ´Ù‡: {formatDisplayNumber(remainingWidth)}cm Ã— {formatDisplayNumber(remainingLength)}cm
                                  <span className="text-amber-600 dark:text-amber-400 ml-1">
                                    ({formatSquareMeters((remainingWidth * remainingLength * effectiveQuantity) / 10000)})
                                  </span>
                                </div>
                              )}
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })()}

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (ØªÙˆÙ…Ø§Ù†)
                      </label>
                      <FormattedNumberInput
                        value={productConfig.pricePerSquareMeter || 0}
                        onFocus={() => handleFieldFocus('pricePerSquareMeter', productConfig.pricePerSquareMeter, 0)}
                        onChange={(value) => setProductConfig(prev => ({ ...prev, pricePerSquareMeter: value }))}
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                        min={0}
                        step={1000}
                        placeholder="ÙÛŒ Ù‡Ø± Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (ØªÙˆÙ…Ø§Ù†)"
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        Ù…ØªØ± Ù…Ø±Ø¨Ø¹
                      </label>
                      <FormattedNumberInput
                        key={`square-meters-${lengthUnit}-${widthUnit}`}
                        value={(() => {
                          console.log('ğŸ¯ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Field Value:', {
                            productConfigSquareMeters: productConfig.squareMeters,
                            lengthUnit,
                            widthUnit,
                            finalValue: productConfig.squareMeters || 0
                          });
                          return productConfig.squareMeters || 0;
                        })()}
                        onFocus={() => handleFieldFocus('squareMeters', productConfig.squareMeters, 0)}
                        onChange={(value) => {
                          // Update the square meters first
                          setProductConfig(prev => {
                            // Get original width for calculations
                            const originalWidth = (isEditMode && prev.originalWidth) ? prev.originalWidth : (selectedProduct?.widthValue || 0);
                            
                            // Check if user entered ONLY squareMeters (no length, no width)
                            const hasNoLength = !prev.length || prev.length === 0;
                            const hasNoWidth = !prev.width || prev.width === 0;
                            const onlySquareMetersEntered = hasNoLength && hasNoWidth && value > 0;
                            
                            let updatedConfig = { ...prev, squareMeters: value };
                            
                            // If only squareMeters is entered, automatically set width to original width
                            if (onlySquareMetersEntered && originalWidth > 0) {
                              // Convert original width to the selected width unit
                              const originalWidthInSelectedUnit = widthUnit === 'cm' 
                                ? originalWidth 
                                : (originalWidth / 100);
                              
                              // Set width to original width
                              updatedConfig = {
                                ...updatedConfig,
                                width: originalWidthInSelectedUnit
                              };
                              
                              console.log('ğŸ¯ Auto-setting width to original width:', {
                                originalWidth,
                                widthUnit,
                                originalWidthInSelectedUnit,
                                squareMeters: value
                              });
                            }
                            
                            // Trigger smart calculation with updated config
                            const smartResult = handleSmartCalculation('squareMeters', value, updatedConfig, lengthUnit, widthUnit, getEffectiveQuantity());
                            const finalConfig = {
                              ...updatedConfig,
                              length: smartResult.length,
                              width: smartResult.width || updatedConfig.width // Preserve auto-set width if smart calculation doesn't return width
                            };
                            
                            // Check if we need to auto-select longitudinal cut after smart calculation
                            const userWidthInCm = widthUnit === 'm' ? (finalConfig.width || 0) * 100 : (finalConfig.width || 0);
                            
                            // Validate: calculated width cannot exceed original width
                            if (finalConfig.width && finalConfig.width > 0 && originalWidth > 0 && userWidthInCm > originalWidth) {
                              // Show error message
                              setErrors({ 
                                products: `Ø¹Ø±Ø¶ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ (${finalConfig.width.toFixed(2)}${widthUnit === 'm' ? 'm' : 'cm'}) Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¹Ø±Ø¶ Ø§ØµÙ„ÛŒ Ø³Ù†Ú¯ (${originalWidth}cm) Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ù‡ÛŒØ¯ ØªØ§ Ø¹Ø±Ø¶ Ú©Ù…ØªØ± ÛŒØ§ Ù…Ø³Ø§ÙˆÛŒ Ø¨Ø§ ${originalWidth}cm Ø¨Ø§Ø´Ø¯.` 
                              });
                            } else {
                              // Clear error if calculated width is valid
                              if (errors.products && errors.products.includes('Ø¹Ø±Ø¶ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡')) {
                                setErrors({});
                              }
                            }
                            
                            const shouldAutoSelectLongitudinalCut = userWidthInCm < originalWidth;
                            
                            console.log('ğŸ“ Square Meters Changed - Auto Cut Selection:', {
                              userSquareMeters: value,
                              calculatedWidth: finalConfig.width,
                              userWidthInCm,
                              originalWidth,
                              shouldAutoSelectLongitudinalCut,
                              comparison: `${userWidthInCm} < ${originalWidth} = ${userWidthInCm < originalWidth}`
                            });
                            
                            // Auto-select cut type based on calculated width
                            if (shouldAutoSelectLongitudinalCut) {
                              return {
                                ...finalConfig,
                                isCut: true,
                                cutType: 'longitudinal'
                              };
                            } else {
                              return {
                                ...finalConfig,
                                isCut: false,
                                cutType: null
                              };
                            }
                          });
                        }}
                        className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                        min={0}
                        step={0.01}
                        placeholder="Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ ÛŒØ§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
                      />
                    </div>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      ØªÙˆØ¶ÛŒØ­Ø§Øª
                    </label>
                    <textarea
                      value={productConfig.description || ''}
                      onFocus={() => handleFieldFocus('description', productConfig.description, '')}
                      onChange={(e) => setProductConfig(prev => ({ ...prev, description: e.target.value }))}
                      rows={3}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent"
                      placeholder="ØªÙˆØ¶ÛŒØ­Ø§Øª Ø§Ø¶Ø§ÙÛŒ..."
                    />
                  </div>
                  {/* Mandatory Pricing Section - Only for longitudinal stones, not for slab */}
                  {productConfig.productType !== 'slab' && (
                  <div className="border-t border-gray-200 dark:border-gray-600 pt-4">
                    <div className="flex items-center space-x-3 space-x-reverse mb-4">
                      <input
                        type="checkbox"
                        id="isMandatory"
                        checked={isMandatory}
                        onChange={(e) => setIsMandatory(e.target.checked)}
                        className="w-4 h-4 text-teal-600 bg-gray-100 border-gray-300 rounded focus:ring-teal-500 dark:focus:ring-teal-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600"
                      />
                      <div className="flex flex-col">
                        <label htmlFor="isMandatory" className="text-sm font-medium text-gray-700 dark:text-gray-300">
                          Ø­Ú©Ù…ÛŒ (Ø§ÙØ²Ø§ÛŒØ´ Ù‚ÛŒÙ…Øª)
                        </label>
                        {hasQuantityBeenInteracted && (
                          <span className="text-xs text-blue-600 dark:text-blue-400 mt-1">
                            {isMandatory ? 'âœ… ÙØ¹Ø§Ù„ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· ØªØ¹Ø¯Ø§Ø¯' : 'âŒ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· ØªØ¹Ø¯Ø§Ø¯'}
                          </span>
                        )}
                      </div>
                    </div>
                    
                    {isMandatory && (
                      <div className="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4">
                        <div className="flex items-center space-x-3 space-x-reverse">
                          <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                            Ø¯Ø±ØµØ¯ Ø§ÙØ²Ø§ÛŒØ´:
                          </label>
                          <FormattedNumberInput
                            value={mandatoryPercentage}
                            onChange={(value) => setMandatoryPercentage(value)}
                            className="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-teal-500 focus:border-transparent text-sm"
                            min={0}
                            max={100}
                          />
                          <span className="text-sm text-gray-600 dark:text-gray-400">%</span>
                        </div>
                        <p className="text-xs text-yellow-700 dark:text-yellow-300 mt-2">
                          Ù‚ÛŒÙ…Øª Ù†Ù‡Ø§ÛŒÛŒ Ø¨Ø§ {mandatoryPercentage}% Ø§ÙØ²Ø§ÛŒØ´ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯
                        </p>
                        
                        {/* Price Preview */}
                        {(() => {
                          console.log('ğŸ” Price Preview Calculation:', {
                            productConfigWidth: productConfig.width,
                            length: productConfig.length,
                            quantity: productConfig.quantity,
                            pricePerSquareMeter: productConfig.pricePerSquareMeter
                          });
                          
                          // Use productConfig.originalWidth when editing, otherwise use selectedProduct.widthValue
                          const originalWidthForCalculation = (isEditMode && productConfig.originalWidth) 
                            ? productConfig.originalWidth 
                            : (selectedProduct?.widthValue || 0);
                          
                          const calculated = calculateStoneMetrics({
                            length: productConfig.length,
                            width: productConfig.width,
                            quantity: productConfig.quantity,
                            squareMeters: productConfig.squareMeters,
                            pricePerSquareMeter: productConfig.pricePerSquareMeter,
                            lengthUnit: lengthUnit,
                            widthUnit: widthUnit,
                            isMandatory: isMandatory,
                            mandatoryPercentage: mandatoryPercentage,
                            isCut: productConfig.isCut || false,
                            originalWidth: originalWidthForCalculation,
                            cuttingCostPerMeter: productConfig.cuttingCostPerMeter || 0
                          });
                          
                          console.log('ğŸ” Price Preview Result:', {
                            originalTotalPrice: calculated.originalTotalPrice,
                            totalPrice: calculated.totalPrice,
                            squareMeters: calculated.squareMeters
                          });
                          
                          if (calculated.originalTotalPrice > 0) {
                            return (
                              <div className="mt-3 p-2 bg-white dark:bg-gray-800 rounded border border-yellow-300 dark:border-yellow-600">
                                <div className="text-xs text-gray-600 dark:text-gray-400">
                                  Ù‚ÛŒÙ…Øª Ø§ØµÙ„ÛŒ: {formatPrice(calculated.originalTotalPrice, 'ØªÙˆÙ…Ø§Ù†')}
                                </div>
                                <div className="text-sm font-medium text-yellow-800 dark:text-yellow-200">
                                  Ù‚ÛŒÙ…Øª Ù†Ù‡Ø§ÛŒÛŒ: {formatPrice(calculated.totalPrice, 'ØªÙˆÙ…Ø§Ù†')}
                                </div>
                              </div>
                            );
                          }
                          return null;
                        })()}
                      </div>
                    )}
                </div>
              )}
            </div>

                {/* Action Buttons */}
                <div className="flex justify-end gap-3 mt-6">
                  <button
                    onClick={() => {
                      // Validate before closing if it's a stair system
                      if (productConfig.productType === 'stair' && stairSystemConfig) {
                        const hasSelectedPart = stairSystemConfig.tread.isSelected || 
                                                stairSystemConfig.riser.isSelected || 
                                                stairSystemConfig.landing.isSelected;
                        
                        if (!hasSelectedPart) {
                          setErrors({ products: 'Ù„Ø·ÙØ§Ù‹ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ©ÛŒ Ø§Ø² Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ù¾Ù„Ù‡ (Ú©Ù Ù¾Ù„Ù‡ØŒ Ø®ÛŒØ² Ù¾Ù„Ù‡ØŒ ÛŒØ§ Ù¾Ø§Ú¯Ø±Ø¯) Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯' });
                          return;
                        }
                      }
                      
                      setShowProductModal(false);
                      setSelectedProduct(null);
                      setProductConfig({});
                      setLengthUnit('m');
                      setWidthUnit('cm');
                      setIsMandatory(false);
                      setMandatoryPercentage(20);
                      setIsEditMode(false);
                      setEditingProductIndex(null);
                      setTouchedFields(new Set()); // Reset touched fields
                      setStairSystemConfig(null);
                      setErrors({});
                    }}
                    className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                  >
                    Ø§Ù†ØµØ±Ø§Ù
                  </button>
                  <button
                    onClick={() => {
                      console.log('ğŸ”˜ Main Product Button clicked!');
                      handleAddProductToContract();
                    }}
                    className="px-6 py-2 bg-gradient-to-r from-teal-500 to-teal-600 hover:from-teal-600 hover:to-teal-700 text-white rounded-lg transition-all duration-200 font-medium"
                  >
                    {isEditMode ? 'Ø°Ø®ÛŒØ±Ù‡ ØªØºÛŒÛŒØ±Ø§Øª' : 'Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ Ù‚Ø±Ø§Ø±Ø¯Ø§Ø¯'}
                  </button>
                </div>
              </div>
            </div>
            </div>
        )}
        {/* Remaining Stone Configuration Modal */}
        {remainingStoneModal.showRemainingStoneModal && remainingStoneModal.selectedRemainingStone && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
            <div className="bg-white dark:bg-gray-800 rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
              <div className="p-6">
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-xl font-semibold text-gray-800 dark:text-white">
                    Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ØµÙˆÙ„ Ø§Ø² Ø³Ù†Ú¯ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡
                  </h3>
                  <button
                    onClick={() => {
                      remainingStoneModal.setShowRemainingStoneModal(false);
                      remainingStoneModal.setSelectedRemainingStone(null);
                      remainingStoneModal.setRemainingStoneConfig({});
                      remainingStoneModal.setPartitions([{
                        id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        width: 0,
                        length: 0,
                        squareMeters: 0
                      }]);
                      remainingStoneModal.setRemainingStoneLengthUnit('cm');
                      remainingStoneModal.setRemainingStoneWidthUnit('cm');
                      remainingStoneModal.setPartitionLengthUnit('m');
                      remainingStoneModal.setPartitionWidthUnit('cm');
                      remainingStoneModal.setRemainingStoneIsMandatory(false);
                      remainingStoneModal.setRemainingStoneMandatoryPercentage(20);
                    }}
                    className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                  >
                    <FaTimes className="w-6 h-6" />
                  </button>
                </div>

                {/* Error Display */}
                {errors.products && (
                  <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
                    <p className="text-red-600 dark:text-red-400 text-sm">{errors.products}</p>
                  </div>
                )}

                {/* Remaining Stone Info */}
                {remainingStoneModal.selectedRemainingStone && (
                  <div className="mb-6 p-4 bg-orange-50 dark:bg-orange-900/20 rounded-lg border border-orange-200 dark:border-orange-800">
                    <div className="flex items-center justify-between mb-2">
                      <h4 className="font-medium text-orange-800 dark:text-orange-200">
                        Ø³Ù†Ú¯ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡
                      </h4>
                      <span className="px-2 py-1 bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-200 text-xs rounded-full">
                        Ø¹Ø±Ø¶: {formatDisplayNumber(remainingStoneModal.selectedRemainingStone.width)}cm
                      </span>
                    </div>
                    <div className="grid grid-cols-3 gap-4 text-sm">
                      <div>
                        <span className="text-orange-600 dark:text-orange-400">Ø¹Ø±Ø¶ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡:</span>
                        <span className="font-medium text-orange-800 dark:text-orange-200 mr-2">{formatDisplayNumber(remainingStoneModal.selectedRemainingStone.width)}cm</span>
                      </div>
                      <div>
                        <span className="text-orange-600 dark:text-orange-400">Ø·ÙˆÙ„ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡:</span>
                        <span className="font-medium text-orange-800 dark:text-orange-200 mr-2">{formatDisplayNumber(remainingStoneModal.selectedRemainingStone.length * 100)}cm</span>
                      </div>
                      <div>
                        <span className="text-orange-600 dark:text-orange-400">Ù…ØªØ± Ù…Ø±Ø¨Ø¹:</span>
                        <span className="font-medium text-orange-800 dark:text-orange-200 mr-2">{formatDisplayNumber(remainingStoneModal.selectedRemainingStone.squareMeters)}</span>
                      </div>
                    </div>
                  </div>
                )}

                {/* Partitions Table */}
                <div className="mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <h4 className="text-lg font-semibold text-gray-800 dark:text-white">
                      Ù¾Ø§Ø±ØªÛŒØ´Ù†â€ŒÙ‡Ø§
                    </h4>
                    <button
                      onClick={remainingStoneModal.handleAddPartition}
                      className="px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg transition-colors flex items-center gap-2 text-sm"
                    >
                      <FaPlus className="w-4 h-4" />
                      Ø§ÙØ²ÙˆØ¯Ù† Ø±Ø¯ÛŒÙ
                    </button>
                  </div>

                  {/* Unit Selectors */}
                  <div className="mb-4 flex gap-4">
                    <div className="flex-1">
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        ÙˆØ§Ø­Ø¯ Ø¹Ø±Ø¶
                      </label>
                      <div className="flex gap-1">
                        <button
                          type="button"
                          onClick={() => remainingStoneModal.setPartitionWidthUnit('cm')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            remainingStoneModal.partitionWidthUnit === 'cm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                        </button>
                        <button
                          type="button"
                          onClick={() => remainingStoneModal.setPartitionWidthUnit('m')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            remainingStoneModal.partitionWidthUnit === 'm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          Ù…ØªØ± (m)
                        </button>
                      </div>
                    </div>
                    <div className="flex-1">
                      <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
                        ÙˆØ§Ø­Ø¯ Ø·ÙˆÙ„
                      </label>
                      <div className="flex gap-1">
                        <button
                          type="button"
                          onClick={() => remainingStoneModal.setPartitionLengthUnit('cm')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            remainingStoneModal.partitionLengthUnit === 'cm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± (cm)
                        </button>
                        <button
                          type="button"
                          onClick={() => remainingStoneModal.setPartitionLengthUnit('m')}
                          className={`flex-1 px-3 py-2 text-sm font-medium rounded-lg transition-all ${
                            remainingStoneModal.partitionLengthUnit === 'm'
                              ? 'bg-orange-500 text-white shadow-lg'
                              : 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-500'
                          }`}
                        >
                          Ù…ØªØ± (m)
                        </button>
                      </div>
                    </div>
                  </div>

                  {/* Partitions Table */}
                  <div className="overflow-x-auto border border-gray-200 dark:border-gray-700 rounded-lg">
                    <table className="w-full">
                      <thead className="bg-gray-50 dark:bg-gray-700">
                        <tr>
                          <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                            Ø¹Ø±Ø¶ ({remainingStoneModal.partitionWidthUnit === 'm' ? 'm' : 'cm'})
                          </th>
                          <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                            Ø·ÙˆÙ„ ({remainingStoneModal.partitionLengthUnit === 'm' ? 'm' : 'cm'})
                          </th>
                          <th className="px-4 py-3 text-right text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600">
                            Ù…ØªØ± Ù…Ø±Ø¨Ø¹ (Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡)
                          </th>
                          <th className="px-4 py-3 text-center text-xs font-medium text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-600 w-20">
                            Ø¹Ù…Ù„ÛŒØ§Øª
                          </th>
                        </tr>
                      </thead>
                      <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                        {remainingStoneModal.partitions.map((partition, index) => {
                          if (!remainingStoneModal.selectedRemainingStone) return null;
                          const widthInCm = remainingStoneModal.partitionWidthUnit === 'm' ? partition.width * 100 : partition.width;
                          const lengthInCm = remainingStoneModal.partitionLengthUnit === 'm' ? partition.length * 100 : partition.length;
                          const isValidWidth = widthInCm <= remainingStoneModal.selectedRemainingStone.width && widthInCm > 0;
                          const isValidLength = lengthInCm <= (remainingStoneModal.selectedRemainingStone.length * 100) && lengthInCm > 0;
                          
                          // Get validation error for this partition (from state or partition.validationError)
                          const partitionError = partition.validationError || remainingStoneModal.partitionValidationErrors.get(partition.id);
                          const hasError = !!partitionError || (!isValidWidth && partition.width > 0) || (!isValidLength && partition.length > 0);

                          return (
                            <tr 
                              key={partition.id} 
                              className={`hover:bg-gray-50 dark:hover:bg-gray-700/50 ${
                                hasError ? 'bg-red-50/50 dark:bg-red-900/10' : ''
                              }`}
                            >
                              <td className="px-4 py-3">
                                <FormattedNumberInput
                                  value={partition.width}
                                  onChange={(value) => remainingStoneModal.handleUpdatePartition(partition.id, 'width', value)}
                                  className={`w-full px-3 py-2 border rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-orange-500 focus:border-transparent text-sm ${
                                    hasError
                                      ? 'border-red-500 dark:border-red-400'
                                      : 'border-gray-300 dark:border-gray-600'
                                  }`}
                                  min={0}
                                  step={0.1}
                                  placeholder="0"
                                />
                                {!isValidWidth && partition.width > 0 && (
                                  <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                                    Ø­Ø¯Ø§Ú©Ø«Ø±: {formatDisplayNumber(remainingStoneModal.selectedRemainingStone.width)}cm
                                  </p>
                                )}
                              </td>
                              <td className="px-4 py-3">
                                <FormattedNumberInput
                                  value={partition.length}
                                  onChange={(value) => remainingStoneModal.handleUpdatePartition(partition.id, 'length', value)}
                                  className={`w-full px-3 py-2 border rounded-lg bg-white dark:bg-gray-700 text-gray-800 dark:text-white focus:ring-2 focus:ring-orange-500 focus:border-transparent text-sm ${
                                    hasError
                                      ? 'border-red-500 dark:border-red-400'
                                      : 'border-gray-300 dark:border-gray-600'
                                  }`}
                                  min={0}
                                  step={0.1}
                                  placeholder="0"
                                />
                                {!isValidLength && partition.length > 0 && (
                                  <p className="text-xs text-red-500 dark:text-red-400 mt-1">
                                    Ø­Ø¯Ø§Ú©Ø«Ø±: {formatDisplayNumber(remainingStoneModal.selectedRemainingStone.length * 100)}cm
                                  </p>
                                )}
                              </td>
                              <td className="px-4 py-3">
                                <div className="text-sm text-gray-700 dark:text-gray-300 font-medium">
                                  {formatDisplayNumber(partition.squareMeters)}
                                </div>
                              </td>
                              <td className="px-4 py-3 text-center">
                                <button
                                  onClick={() => remainingStoneModal.handleRemovePartition(partition.id)}
                                  disabled={remainingStoneModal.partitions.length === 1}
                                  className="p-2 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                  title="Ø­Ø°Ù"
                                >
                                  <FaTrash className="w-4 h-4" />
                                </button>
                              </td>
                            </tr>
                          );
                        })}
                        {/* Display partition-specific validation errors below the table */}
                        {remainingStoneModal.partitions.some(p => p.validationError || remainingStoneModal.partitionValidationErrors.has(p.id)) && (
                          <tr>
                            <td colSpan={4} className="px-4 py-3">
                              <div className="space-y-2">
                                {remainingStoneModal.partitions.map(partition => {
                                  const error = partition.validationError || remainingStoneModal.partitionValidationErrors.get(partition.id);
                                  if (!error) return null;
                                  
                                  return (
                                    <div 
                                      key={`error-${partition.id}`}
                                      className="flex items-start gap-2 p-2 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg"
                                    >
                                      <span className="text-red-600 dark:text-red-400 font-medium text-xs">âš ï¸</span>
                                      <div className="flex-1">
                                        <p className="text-xs text-red-700 dark:text-red-300 font-medium">
                                          Ù¾Ø§Ø±ØªÛŒØ´Ù† #{remainingStoneModal.partitions.findIndex(p => p.id === partition.id) + 1}:
                                        </p>
                                        <p className="text-xs text-red-600 dark:text-red-400 mt-1">
                                          {error}
                                        </p>
                                      </div>
                                    </div>
                                  );
                                })}
                              </div>
                            </td>
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </div>

                  {/* Summary */}
                  {(() => {
                    const validPartitions = remainingStoneModal.partitions.filter(p => p.width > 0 && p.length > 0);
                    const totalUsedSquareMeters = validPartitions.reduce((sum, p) => sum + p.squareMeters, 0);
                    const remainingSquareMeters = remainingStoneModal.selectedRemainingStone.squareMeters - totalUsedSquareMeters;

                    return validPartitions.length > 0 && (
                      <div className="mt-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg border border-blue-200 dark:border-blue-800">
                        <div className="grid grid-cols-3 gap-4 text-sm">
                          <div>
                            <span className="text-blue-600 dark:text-blue-400">Ù…Ø¬Ù…ÙˆØ¹ Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø´Ø¯Ù‡:</span>
                            <span className="font-medium text-blue-800 dark:text-blue-200 mr-2">{formatDisplayNumber(totalUsedSquareMeters)}</span>
                          </div>
                          <div>
                            <span className="text-blue-600 dark:text-blue-400">Ù…ØªØ± Ù…Ø±Ø¨Ø¹ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡:</span>
                            <span className={`font-medium mr-2 ${remainingSquareMeters >= 0 ? 'text-blue-800 dark:text-blue-200' : 'text-red-600 dark:text-red-400'}`}>
                              {formatDisplayNumber(remainingSquareMeters)}
                            </span>
                          </div>
                          <div>
                            <span className="text-blue-600 dark:text-blue-400">ØªØ¹Ø¯Ø§Ø¯ Ù¾Ø§Ø±ØªÛŒØ´Ù†â€ŒÙ‡Ø§:</span>
                            <span className="font-medium text-blue-800 dark:text-blue-200 mr-2">{validPartitions.length}</span>
                          </div>
                        </div>
                      </div>
                    );
                  })()}
                </div>

                {/* CAD Designer for Remaining Stone */}
                <div className="mt-6 bg-white dark:bg-gray-800 rounded-xl border-2 border-orange-200 dark:border-orange-800 shadow-lg overflow-hidden">
                  <div className="bg-gradient-to-r from-orange-500 to-orange-600 dark:from-orange-600 dark:to-orange-700 px-6 py-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-3">
                        <div className="w-10 h-10 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center">
                          <FaRuler className="text-white text-lg" />
                        </div>
                        <div>
                          <h4 className="text-lg font-bold text-white">Ø§Ø¨Ø²Ø§Ø± Ø·Ø±Ø§Ø­ÛŒ CAD</h4>
                          <p className="text-xs text-orange-100">Ø·Ø±Ø§Ø­ÛŒ Ù¾Ø§Ø±ØªÛŒØ´Ù†â€ŒÙ‡Ø§ Ø±ÙˆÛŒ Ø³Ù†Ú¯ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡</p>
                        </div>
                      </div>
                      <button
                        type="button"
                        onClick={() => remainingStoneModal.setShowRemainingStoneCAD(!remainingStoneModal.showRemainingStoneCAD)}
                        className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg transition-colors text-sm font-medium"
                      >
                        {remainingStoneModal.showRemainingStoneCAD ? 'Ù…Ø®ÙÛŒ Ú©Ø±Ø¯Ù†' : 'Ù†Ù…Ø§ÛŒØ´'}
                      </button>
                    </div>
                  </div>
                  
                  {remainingStoneModal.showRemainingStoneCAD && remainingStoneModal.selectedRemainingStone && (
                    <div className="p-6">
                      <p className="text-sm text-gray-700 dark:text-gray-300 mb-4 leading-relaxed">
                        Ø§Ø² Ø§ÛŒÙ† Ø§Ø¨Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ Ø·Ø±Ø§Ø­ÛŒ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ù¾Ø§Ø±ØªÛŒØ´Ù†â€ŒÙ‡Ø§ Ø±ÙˆÛŒ Ø³Ù†Ú¯ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯. Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ù¾Ø§Ø±ØªÛŒØ´Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¨ØµØ±ÛŒ Ø±Ø³Ù… Ú©Ù†ÛŒØ¯.
                      </p>
                      
                      <StoneCADDesigner
                        originalLength={remainingStoneModal.selectedRemainingStone.length}
                        originalWidth={remainingStoneModal.selectedRemainingStone.width}
                        lengthUnit="m"
                        widthUnit="cm"
                        productType="longitudinal"
                        mode="design"
                        enableCostCalculation={false}
                        enableAutoSync={true}
                        onDimensionsCalculated={(dims) => {
                          // When dimensions are drawn in CAD, update partitions
                          if (dims.length && dims.width && remainingStoneModal.partitions.length > 0) {
                            const firstPartition = remainingStoneModal.partitions[0];
                            remainingStoneModal.handleUpdatePartition(firstPartition.id, 'width', dims.width);
                            remainingStoneModal.handleUpdatePartition(firstPartition.id, 'length', dims.length);
                          }
                        }}
                      />
                    </div>
                  )}
                </div>

                {/* Action Buttons */}
                <div className="flex justify-end gap-3 mt-6">
                  <button
                    onClick={() => {
                      remainingStoneModal.setShowRemainingStoneModal(false);
                      remainingStoneModal.setSelectedRemainingStone(null);
                      remainingStoneModal.setRemainingStoneConfig({});
                      remainingStoneModal.setPartitions([{
                        id: `partition_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        width: 0,
                        length: 0,
                        squareMeters: 0
                      }]);
                      remainingStoneModal.setRemainingStoneLengthUnit('cm');
                      remainingStoneModal.setRemainingStoneWidthUnit('cm');
                      remainingStoneModal.setPartitionLengthUnit('m');
                      remainingStoneModal.setPartitionWidthUnit('cm');
                      remainingStoneModal.setRemainingStoneIsMandatory(false);
                      remainingStoneModal.setRemainingStoneMandatoryPercentage(20);
                    }}
                    className="px-4 py-2 text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors"
                  >
                    Ø§Ù†ØµØ±Ø§Ù
                  </button>
                  <button
                    onClick={() => {
                      console.log('ğŸ”˜ Partition Button clicked!');
                      remainingStoneModal.handleAddRemainingStoneToContract();
                    }}
                    className="px-6 py-2 bg-gradient-to-r from-orange-500 to-orange-600 hover:from-orange-600 hover:to-orange-700 text-white rounded-lg transition-all duration-200 font-medium"
                  >
                    Ø§ÛŒØ¬Ø§Ø¯ Ù¾Ø§Ø±ØªÛŒØ´Ù†â€ŒÙ‡Ø§
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}
        {/* SubService Selection Modal - Now using SubServiceModal component (see below) */}

        {/* New Modal Components */}
        <ProductConfigurationModal
          isOpen={productModal.showProductModal && !useStairFlowV2}
          onClose={() => {
            productModal.setShowProductModal(false);
            productModal.setSelectedProduct(null);
          }}
          selectedProduct={productModal.selectedProduct}
          productConfig={productModal.productConfig}
          setProductConfig={productModal.setProductConfig}
          lengthUnit={productModal.lengthUnit}
          setLengthUnit={productModal.setLengthUnit}
          widthUnit={productModal.widthUnit}
          setWidthUnit={productModal.setWidthUnit}
          isMandatory={productModal.isMandatory}
          setIsMandatory={productModal.setIsMandatory}
          mandatoryPercentage={productModal.mandatoryPercentage}
          setMandatoryPercentage={productModal.setMandatoryPercentage}
          isEditMode={productModal.isEditMode}
          setIsEditMode={productModal.setIsEditMode}
          editingProductIndex={productModal.editingProductIndex}
          setEditingProductIndex={productModal.setEditingProductIndex}
          touchedFields={productModal.touchedFields}
          setTouchedFields={productModal.setTouchedFields}
          stairSystemConfig={productModal.stairSystemConfig}
          setStairSystemConfig={productModal.setStairSystemConfig}
          quantityType={productModal.quantityType}
          setQuantityType={productModal.setQuantityType}
          treadExpanded={productModal.treadExpanded}
          setTreadExpanded={productModal.setTreadExpanded}
          riserExpanded={productModal.riserExpanded}
          setRiserExpanded={productModal.setRiserExpanded}
          landingExpanded={productModal.landingExpanded}
          setLandingExpanded={productModal.setLandingExpanded}
          showCADDesigner={productModal.showCADDesigner}
          setShowCADDesigner={productModal.setShowCADDesigner}
          errors={errors}
          setErrors={setErrors}
          hasQuantityBeenInteracted={productModal.hasQuantityBeenInteracted}
          setHasQuantityBeenInteracted={productModal.setHasQuantityBeenInteracted}
          onSave={handleAddProductToContract}
          wizardData={wizardData}
          updateWizardData={updateWizardData}
          handleSmartCalculation={productCalculations.handleSmartCalculation}
          calculateStoneMetrics={productCalculations.calculateStoneMetrics}
          getCuttingTypePricePerMeter={productCalculations.getCuttingTypePricePerMeter}
          calculateAutoCuttingCost={productCalculations.calculateAutoCuttingCost}
          getEffectiveQuantity={productCalculations.getEffectiveQuantity}
          getQuantityDisplayValue={productCalculations.getQuantityDisplayValue}
          handleFieldFocus={productModal.handleFieldFocus}
          handleLengthUnitChange={handleLengthUnitChangeWithCalc}
          handleWidthUnitChange={handleWidthUnitChangeWithCalc}
          generateFullProductName={productCalculations.generateFullProductName}
          calculateTreadMetrics={productCalculations.calculateTreadMetrics}
          calculateRiserMetrics={productCalculations.calculateRiserMetrics}
          calculateLandingMetrics={productCalculations.calculateLandingMetrics}
          calculateNosingCuttingCost={productCalculations.calculateNosingCuttingCost}
          getSlabStandardDimensions={productCalculations.getSlabStandardDimensions}
          determineSlabLineCutPlan={productCalculations.determineSlabLineCutPlan}
          NOSING_TYPES={[...NOSING_TYPES] as any[]}
          cuttingTypes={cuttingTypes}
          products={products}
          updateStairSystemConfig={updateStairSystemConfig}
          updateStairPart={updateStairPart}
          selectProductForStairPart={selectProductForStairPart}
          syncDraftWithProduct={syncDraftWithProduct}
          filteredTreadProducts={filteredTreadProducts}
          filteredRiserProducts={filteredRiserProducts}
          filteredLandingProducts={filteredLandingProducts}
          treadProductSearchTerm={treadProductSearchTerm}
          setTreadProductSearchTerm={setTreadProductSearchTerm}
          riserProductSearchTerm={riserProductSearchTerm}
          setRiserProductSearchTerm={setRiserProductSearchTerm}
          landingProductSearchTerm={landingProductSearchTerm}
          setLandingProductSearchTerm={setLandingProductSearchTerm}
          useStairFlowV2={useStairFlowV2}
          stairActivePart={stairSystemV2.stairActivePart}
          setStoneSearchTerm={stairSystemV2.setStoneSearchTerm}
        />

        <StairSystemModal
          isOpen={productModal.showProductModal && useStairFlowV2 && (wizardData.selectedProductTypeForAddition === 'stair')}
          onClose={() => {
            productModal.setShowProductModal(false);
            productModal.setSelectedProduct(null);
          }}
          onSave={() => {
            // Handle stair system save
            setShowProductModal(false);
          }}
          wizardData={wizardData}
          updateWizardData={updateWizardData}
          draftTread={stairSystemV2.draftTread}
          draftRiser={stairSystemV2.draftRiser}
          draftLanding={stairSystemV2.draftLanding}
          stairActivePart={stairSystemV2.stairActivePart}
          setStairActivePart={stairSystemV2.setStairActivePart}
        />

        <RemainingStoneModal
          isOpen={remainingStoneModal.showRemainingStoneModal}
          onClose={() => {
            remainingStoneModal.setShowRemainingStoneModal(false);
            remainingStoneModal.setSelectedRemainingStone(null);
          }}
          remainingStone={remainingStoneModal.selectedRemainingStone}
          onCreatePartitions={remainingStoneModal.handleAddRemainingStoneToContract}
          wizardData={wizardData}
          partitions={remainingStoneModal.partitions}
          setPartitions={remainingStoneModal.setPartitions}
          partitionWidthUnit={remainingStoneModal.partitionWidthUnit}
          setPartitionWidthUnit={remainingStoneModal.setPartitionWidthUnit}
          partitionLengthUnit={remainingStoneModal.partitionLengthUnit}
          setPartitionLengthUnit={remainingStoneModal.setPartitionLengthUnit}
          showRemainingStoneCAD={remainingStoneModal.showRemainingStoneCAD}
          setShowRemainingStoneCAD={remainingStoneModal.setShowRemainingStoneCAD}
          handleAddPartition={remainingStoneModal.handleAddPartition}
          handleUpdatePartition={remainingStoneModal.handleUpdatePartition}
          handleRemovePartition={remainingStoneModal.handleRemovePartition}
          partitionValidationErrors={remainingStoneModal.partitionValidationErrors}
          errors={errors}
          remainingStoneIsMandatory={remainingStoneModal.remainingStoneIsMandatory}
          setRemainingStoneIsMandatory={remainingStoneModal.setRemainingStoneIsMandatory}
          remainingStoneMandatoryPercentage={remainingStoneModal.remainingStoneMandatoryPercentage}
          setRemainingStoneMandatoryPercentage={remainingStoneModal.setRemainingStoneMandatoryPercentage}
        />

        <SubServiceModal
          isOpen={subServiceModal.showSubServiceModal}
          onClose={subServiceModal.closeModal}
          productIndex={subServiceModal.selectedSubServiceProductIndex || 0}
          onSave={() => {
            // Handle sub-service save - the modal will use its internal state
            subServiceModal.closeModal();
          }}
          wizardData={wizardData}
          updateWizardData={updateWizardData}
          subServices={subServices}
          selectedSubServices={subServiceModal.selectedSubServices}
          setSelectedSubServices={subServiceModal.setSelectedSubServices}
          subServiceMeterValues={subServiceModal.subServiceMeterValues}
          setSubServiceMeterValues={subServiceModal.setSubServiceMeterValues}
          subServiceCalculationBases={subServiceModal.subServiceCalculationBases}
          setSubServiceCalculationBases={subServiceModal.setSubServiceCalculationBases}
          errors={errors}
          setErrors={setErrors}
        />
      </div>
    </div>
  );
}